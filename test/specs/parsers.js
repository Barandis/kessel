// Copyright (c) 2020 Thomas J. Otterson
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

import {
  all,
  any,
  eof,
  noneOf,
  oneOf,
  regex,
  satisfies,
  string,
  stringi,
} from 'kessel/parsers'
import { error, fail, pass } from 'test/helper'

describe('Recognizers', () => {
  describe('string', () => {
    it('throws an error if a non-string is passed in', () => {
      error(
        string(23),
        'some text',
        'String parser requires string input; got [object Number]'
      )
    })

    context('1-byte characters', () => {
      const parser = string('Onoma')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, 'Onomatopoeia', { result: 'Onoma', index: 5 })
      })
      it('fails if case does not match', () => {
        fail(parser, 'onomatopoeia', {
          expected: ['"Onoma"'],
          actual: '"onoma"',
          index: 0,
        })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, 'Ono', {
          expected: ['"Onoma"'],
          actual: '"Ono"',
          index: 0,
        })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), 'Onomatopoeia', { result: '', index: 0 })
      })
    })

    context('2-byte characters', () => {
      const parser = string('–ó–≤—É–∫–æ')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '–ó–≤—É–∫–æ', index: 10 })
      })
      it('fails if case does not match', () => {
        fail(parser, '–∑–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { actual: '"–∑–≤—É–∫–æ"', index: 0 })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, '–ó–≤—É', { actual: '"–ó–≤—É"', index: 0 })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '', index: 0 })
      })
    })

    context('3-byte characters', () => {
      const parser = string('‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ', index: 15 })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, '‡∏Ñ‡∏≥‡πÄ', { actual: '"‡∏Ñ‡∏≥‡πÄ"', index: 0 })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '', index: 0 })
      })
    })

    context('4-byte characters', () => {
      const parser = string('ùëÇùëõùëúùëöùëé')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: 'ùëÇùëõùëúùëöùëé', index: 20 })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, 'ùëÇùëõùëú', { actual: '"ùëÇùëõùëú"', index: 0 })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: '', index: 0 })
      })
    })
  })

  describe('stringi', () => {
    it('throws an error if a non-string is passed in', () => {
      error(
        stringi(23),
        'some text',
        'String parser requires string input; got [object Number]'
      )
    })

    context('1-byte characters', () => {
      const parser = stringi('Onoma')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, 'Onomatopoeia', { result: 'Onoma', index: 5 })
      })
      it('succeeds if case does not match', () => {
        pass(parser, 'onomatopoeia', { result: 'onoma', index: 5 })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, 'Ono', {
          expected: ['"Onoma"'],
          actual: '"Ono"',
          index: 0,
        })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), 'Onomatopoeia', { result: '', index: 0 })
      })
    })

    context('2-byte characters', () => {
      const parser = stringi('–ó–≤—É–∫–æ')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '–ó–≤—É–∫–æ', index: 10 })
      })
      it('succeeds if case does not match', () => {
        pass(parser, '–∑–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '–∑–≤—É–∫–æ', index: 10 })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, '–ó–≤—É', { actual: '"–ó–≤—É"', index: 0 })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '', index: 0 })
      })
    })

    context('3-byte characters', () => {
      const parser = stringi('‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ', index: 15 })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, '‡∏Ñ‡∏≥‡πÄ', { actual: '"‡∏Ñ‡∏≥‡πÄ"', index: 0 })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '', index: 0 })
      })
    })

    context('4-byte characters', () => {
      const parser = stringi('ùëÇùëõùëúùëöùëé')

      it('succeeds if the same number of characters is matched', () => {
        pass(parser, 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: 'ùëÇùëõùëúùëöùëé', index: 20 })
      })
      it('fails if the string is longer than the remaining text', () => {
        fail(parser, 'ùëÇùëõùëú', { actual: '"ùëÇùëõùëú"', index: 0 })
      })
      it('succeeds with an empty string', () => {
        pass(string(''), 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: '', index: 0 })
      })
    })
  })

  describe('regex', () => {
    it('throws an error if the input is neither a string or a regex', () => {
      error(
        () => regex(23),
        'some text',
        'Regex parser requires regular expression or string input; got '
          + '[object Number]'
      )
    })
    it('accepts a string as input', () => {
      pass(regex('^\\w{3}'), 'Onomatopoeia', 'Ono')
    })
    it('accepts a regular expression as input', () => {
      pass(regex(/^\w{3}/i), 'onomatopoeia', 'ono')
    })
    it('is anchored even if an anchor is not in the regex', () => {
      fail(regex(/poe/), 'Onomatopoeia', {
        actual: '"Ono"',
        expected: ['a string matching /^poe/'],
      })
    })
    it('fails if the input is at its end', () => {
      fail(regex(/^./), '', 'EOF')
    })
    it('matches 1-byte characters', () => {
      pass(regex(/^Onoma/), 'Onomatopoeia', 'Onoma')
      pass(regex(/^.{5}/), 'Onomatopoeia', 'Onoma')
      fail(regex(/^\d/), 'Onomatopoeia', '"On"')
    })
    it('matches 2-byte characters', () => {
      pass(regex(/^–ó–≤—É–∫–æ/), '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', '–ó–≤—É–∫–æ')
      pass(regex(/^.{5}/), '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', '–ó–≤—É–∫–æ')
      fail(regex(/^\d/), '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', '"–ó–≤"')
    })
    it('matches 3-byte characters (with the u flag)', () => {
      pass(regex(/^‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ/u), '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ')
      pass(regex(/^.{5}/u), '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ')
      fail(regex(/^\d/u), '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', '"‡∏Ñ‡∏≥"')
    })
    it('matches 4-byte characters (with the u flag)', () => {
      pass(regex(/^ùëÇùëõùëúùëöùëé/u), 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', 'ùëÇùëõùëúùëöùëé')
      pass(regex(/^.{5}/u), 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', 'ùëÇùëõùëúùëöùëé')
      fail(regex(/^\d/u), 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', '"ùëÇùëõ"')
    })
  })

  describe('any', () => {
    it('results in the next 1-byte character', () => {
      pass(any, 'Onomatopoeia', { result: 'O', index: 1 })
    })
    it('results in the next 2-byte character', () => {
      pass(any, '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '–ó', index: 2 })
    })
    it('results in the next 3-byte character', () => {
      pass(any, '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '‡∏Ñ', index: 3 })
    })
    it('results in the next 4-byte character', () => {
      pass(any, 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: 'ùëÇ', index: 4 })
    })
    it('fails at EOF', () => {
      fail(any, '', { expected: ['any character'], actual: 'EOF' })
    })
  })

  describe('all', () => {
    it('results in all remaining 1-byte characters', () => {
      pass(all, 'Onomatopoeia', { result: 'Onomatopoeia', index: 12 })
    })
    it('results in all remaining 2-byte characters', () => {
      pass(all, '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', index: 30 })
    })
    it('results in all remaining 3-byte characters', () => {
      pass(all, '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', index: 36 })
    })
    it('results in all remaining 4-byte characters', () => {
      pass(all, 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', index: 48 })
    })
    it('succeeds at EOF', () => {
      pass(all, '', { result: '', index: 0 })
    })
  })

  describe('eof', () => {
    it('fails if there are any remaining 1-byte characters', () => {
      fail(eof, 'Onomatopoeia', { expected: ['EOF'], actual: '"O"' })
    })
    it('fails if there are any remaining 2-byte characters', () => {
      fail(eof, '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { expected: ['EOF'], actual: '"–ó"' })
    })
    it('fails if there are any remaining 3-byte characters', () => {
      fail(eof, '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { expected: ['EOF'], actual: '"‡∏Ñ"' })
    })
    it('fails if there are any remaining 4-byte characters', () => {
      fail(eof, 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { expected: ['EOF'], actual: '"ùëÇ"' })
    })
    it('succeeds only at EOF', () => {
      pass(eof, '', { result: null, index: 0 })
    })
  })

  describe('satisfies', () => {
    it('fails if the supplied value is not a function', () => {
      error(
        satisfies(23),
        'some text',
        'satisfies parser requires a function; got [object Number]'
      )
    })

    const fn = char => char === char.toUpperCase()

    it('tests the next 1-byte character', () => {
      pass(satisfies(fn), 'Onomatopoeia', { result: 'O', index: 1 })
      fail(satisfies(fn), 'onomatopoeia', {
        expected: ['a character satisfying function fn'],
        actual: '"o"',
      })
    })

    it('tests the next 2-byte character', () => {
      pass(satisfies(fn), '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '–ó', index: 2 })
      fail(satisfies(fn), '–∑–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', {
        expected: ['a character satisfying function fn'],
        actual: '"–∑"',
      })
    })

    it('tests the next 3-byte character', () => {
      pass(satisfies(fn), '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '‡∏Ñ', index: 3 })
    })

    it('tests the next 4-byte character', () => {
      pass(satisfies(fn), 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: 'ùëÇ', index: 4 })
    })

    it('names an unnamed function <anonymous>', () => {
      fail(satisfies(char => char === char.toUpperCase()), 'onomatopoeia', {
        expected: ['a character satisfying function <anonymous>'],
        actual: '"o"',
      })
    })

    it('fails automatically at EOF', () => {
      fail(satisfies(fn), '', {
        expected: ['a character satisfying function fn'],
        actual: 'EOF',
      })
    })
  })

  describe('oneOf', () => {
    it('checks the next charater against 1-byte characters', () => {
      const parser = oneOf('Onoma')
      pass(parser, 'Onomatopoeia', { result: 'O', index: 1 })
      pass(parser, 'matriculate', { result: 'm', index: 1 })
      fail(parser, 'Matriculate', {
        expected: ['one of "Onoma"'],
        actual: '"M"',
      })
    })

    it('checks the next character against 2-byte characters', () => {
      const parser = oneOf('–ó–≤—É–∫–æ')
      pass(parser, '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', { result: '–ó', index: 2 })
      pass(parser, '—É—á–∏—Ç–µ–ª—å', { result: '—É', index: 2 })
      fail(parser, '–£—á–∏—Ç–µ–ª—å', { expected: ['one of "–ó–≤—É–∫–æ"'], actual: '"–£"' })
    })

    it('checks the next character against 3-byte characters', () => {
      const parser = oneOf('‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ')
      pass(parser, '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', { result: '‡∏Ñ', index: 3 })
      pass(parser, '‡∏•‡∏µ‡∏¢‡∏ô', { result: '‡∏•', index: 3 })
      fail(parser, '‡∏¢‡∏á', { expected: ['one of "‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ"'], actual: '"‡∏¢"' })
    })

    it('checks the next character against 4-byte characters', () => {
      const parser = oneOf('ùëÇùëõùëúùëöùëé')
      pass(parser, 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', { result: 'ùëÇ', index: 4 })
      pass(parser, 'ùëöùëéùë°ùëüùëñùëêùë¢ùëôùëéùë°ùëí', { result: 'ùëö', index: 4 })
      fail(parser, 'matriculate', {
        expected: ['one of "ùëÇùëõùëúùëöùëé"'],
        actual: '"m"',
      })
    })
  })

  describe('noneOf', () => {
    it('checks the next charater against 1-byte characters', () => {
      const parser = noneOf('Onoma')
      fail(parser, 'Onomatopoeia', {
        expected: ['none of "Onoma"'],
        actual: '"O"',
      })
      fail(parser, 'matriculate', {
        expected: ['none of "Onoma"'],
        actual: '"m"',
      })
      pass(parser, 'Matriculate', { result: 'M', index: 1 })
    })

    it('checks the next character against 2-byte characters', () => {
      const parser = noneOf('–ó–≤—É–∫–æ')
      fail(parser, '–ó–≤—É–∫–æ–ø–æ–¥—Ä–∞–∂–∞–Ω–∏–µ', {
        expected: ['none of "–ó–≤—É–∫–æ"'],
        actual: '"–ó"',
      })
      fail(parser, '—É—á–∏—Ç–µ–ª—å', { expected: ['none of "–ó–≤—É–∫–æ"'], actual: '"—É"' })
      pass(parser, '–£—á–∏—Ç–µ–ª—å', { result: '–£', index: 2 })
    })

    it('checks the next character against 3-byte characters', () => {
      const parser = noneOf('‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ')
      fail(parser, '‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ‡∏¢‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á', {
        expected: ['none of "‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ"'],
        actual: '"‡∏Ñ"',
      })
      fail(parser, '‡∏•‡∏µ‡∏¢‡∏ô', { expected: ['none of "‡∏Ñ‡∏≥‡πÄ‡∏•‡∏µ"'], actual: '"‡∏•"' })
      pass(parser, '‡∏¢‡∏á', { result: '‡∏¢', index: 3 })
    })

    it('checks the next character against 4-byte characters', () => {
      const parser = noneOf('ùëÇùëõùëúùëöùëé')
      fail(parser, 'ùëÇùëõùëúùëöùëéùë°ùëúùëùùëúùëíùëñùëé', {
        expected: ['none of "ùëÇùëõùëúùëöùëé"'],
        actual: '"ùëÇ"',
      })
      fail(parser, 'ùëöùëéùë°ùëüùëñùëêùë¢ùëôùëéùë°ùëí', {
        expected: ['none of "ùëÇùëõùëúùëöùëé"'],
        actual: '"ùëö"',
      })
      pass(parser, 'matriculate', { result: 'm', index: 1 })
    })
  })
})
