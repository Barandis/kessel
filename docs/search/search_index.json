{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kessel Kessel is a full-featured parser combinator library written in JavaScript. Its aim is to make it easy to produce robust, arbitrarily complex parsers for any conceivable use. Status Kessel is currently alpha-quality software. The author had no more than a vague notion of parser combinators before embarking upon this project, and while he has learned much about the deep workings of such a library, it's likely that there's more to learn that will result in API changes. The test suite is considerable (over 600 tests at the time of writing) and code coverage is very nearly or at 100%, but that doesn't guarantee that the software is bug free. If you find a bug or want to request a feature, please use the GitHub issue tracker for the project. Changelog Version 0.1.0-alpha, 2020-12-03 Initial release. License Kessel is released under the MIT License. MIT License Copyright \u00a9 2020 Thomas Otterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contact Kessel is written and presently maintained by Thomas Otterson, who can be reached at tjotterson [at] gmail.com.","title":"Home"},{"location":"#kessel","text":"Kessel is a full-featured parser combinator library written in JavaScript. Its aim is to make it easy to produce robust, arbitrarily complex parsers for any conceivable use.","title":"Kessel"},{"location":"#status","text":"Kessel is currently alpha-quality software. The author had no more than a vague notion of parser combinators before embarking upon this project, and while he has learned much about the deep workings of such a library, it's likely that there's more to learn that will result in API changes. The test suite is considerable (over 600 tests at the time of writing) and code coverage is very nearly or at 100%, but that doesn't guarantee that the software is bug free. If you find a bug or want to request a feature, please use the GitHub issue tracker for the project.","title":"Status"},{"location":"#changelog","text":"","title":"Changelog"},{"location":"#version-010-alpha-2020-12-03","text":"Initial release.","title":"Version 0.1.0-alpha, 2020-12-03"},{"location":"#license","text":"Kessel is released under the MIT License. MIT License Copyright \u00a9 2020 Thomas Otterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"#contact","text":"Kessel is written and presently maintained by Thomas Otterson, who can be reached at tjotterson [at] gmail.com.","title":"Contact"},{"location":"api/","text":"Summary Terminology A couple notes on terms you'll find in this API documentation. Parser Everything in the Parser API Reference is referred to as a parser . This is not exactly accurate; in Kessel, a parser is a function that takes a context as an argument and returns a tuple of an updated context and a result. By that definition, the only parsers in here are things like any and letter that don't take any additional parameters. A number of items in the reference are functions that produce parsers. Examples are char and string . These require extra information to know what to parse - char needs to know which character it's looking for, for example - so they have parameters to let them accept that information. But these functions return parsers. In other words, char is not a parser, but char('a') is. Because of that, it's safe enough to refer to these functions as parsers as well. The final class of object in the Parser API Reference is the combinator . A combinator is a function that takes one or more parsers as parameters, maybe with other parameters as well, and return another parser. ( block and blockB take generator functions instead of parsers, but since those generator functions can call parsers in their bodies, they can also be considered combinators.) Combinators are a little different because they don't actually read text. Every parser or parser-producing function, at the core, is a function that reads one or more characters of text and either succeeds or fails depending on whether it read the character(s) it was expecting. Combinators don't do that; they modify or compose other parsers. For example, many doesn't read any text at all, but it tells the parser passed into it to read text zero or more times. But in the end it's all the same. many may not parse text directly, but it has a value passed to it which may be a parser itself. If it's not, then it must be a combinator that has a value passed to it . Eventually, there's going to be a parser, and it will read text. So many may not be a parser, and the same with choice and pipe and join , but pipe(choice(char('_'), letter), join(many(choice(char('_'), letter, digit))), (first, rest) => first + rest) is definitely a parser. (One which does a pretty reasonable job of parsing a programming language identifier..md) In summary, every entry in the Parser API Reference either is a function that takes a context and returns a tuple of a context and a result, or it produces one. And directly or indirectly, every entry reads text. So unless there needs to be some distinction between these three different kinds of objects, it's safe to just call them all parsers . Return As has already been stated way more times than is necessary, a parser returns a tuple of a context and a result. But as is also very clear, that's way too many words to use too many times. In this documentation, we will talk about parsers returning values. In this case, \"this parser returns a string\" means \"this parser returns a tuple of a context and a result, and upon success, the value of that result is a string.\" I think we can all agree that one is more fun to read (and write) than the other. Parsers Table 1: Single character parsers Parser Description char Parses a single character. charI Parses a single character, but without case sensitivity. satisfy Parses a single character for which a predicate returns true . satisfyM Parses a single character for which a predicate returns true . Fails with a message string if the predicate returns false . range Parses a single character whose code point is between two other characters. any Parses any one character. anyOf Parses a single character which is included in a string or an array. noneOf Parses a single character which is not in included in a string or an array. digit Parses a single decimal digit ( 0-9 ). hex Parses a single hexadecmial digit ( 0-9 , a-f , or A-F ). octal Parses a single octal digit ( 0-7 ). letter Parses a single ASCII letter ( a-z or A-Z ). alpha Parses a single ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). lower Parses a single ASCII lowercase letter ( a-z ). upper Parses a single ASCII uppercase letter ( A-Z ). letterU Parses a single UTF-8 letter. alphaU Parses a single UTF-8 alphanumeric character. lowerU Parses a single UTF-8 lowercase letter. upperU Parses a single UTF-8 uppercase letter. Table 2: String (multiple-character) parsers Parser Description string Parses a string. stringI Parses a string, but without case sensitivity. regex Parses a string matching a regular expression pattern. all Parses the remainder of the input as a string. anyString Parses a string of a certain number of characters. Table 3: Whitespace parsers Parser Description newline Parses a single ASCII newline character ( \\r , \\n , or \\r\\n ). space Parses a single ASCII whitespace character ( , \\t , or a newline). spaces Skips zero or more ASCII whitespace characters. spaces1 Skips one or more ASCII whitespace characters. newlineU Parses a single UTF-8 newline character. spaceU Parses a single UTF-8 whitespace character (including newlines.md). spacesU Skips zero or more UTF-8 whitespace characters. spaces1U Skips one or more UTF-8 whitespace characters. eof Succeeds only at the end of the input. Table 4: Miscellaneous parsers Parser Description always Always succeeds and returns a value. empty Always succeeds and returns nothing. apply Parses content and a function, returning the result of the function when passed the content. failNormally Fails with a generic message. failFatally Fails fatally with a generic message. Table 5: Chaining combinators Parser Description chain Applies a parser, then applies a function to the result, then applies the parser returned by the function. value Applies a parser and returns a value. skip Applies a parser and discards the result. map Applies a parser, then applies a function to the result, then returns the result of that function. left Applies two parsers in order and returns the result of the first one. right Applies two parsers in order and returns the result of the second one. pipe Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. between Applies a content parser between two other parsers, returning only the content parser's result. nth Applies a parser and returns the nth element of the resulting array. first Applies a parser and returns the first element of the resulting array. second Applies a parser and returns the second element of the resulting array. third Applies a parser and returns the third element of the resulting array. fourth Applies a parser and returns the fourth element of the resulting array. fifth Applies a parser and returns the fifth element of the resulting array. join Applies a parser and returns its resulting array elements joined together into a string. Table 6: Sequence combinators Parser Description andThen Applies two parsers in order and returns their results in a tuple. sequence Applies a series of parsers in order, returning their results in an array. block Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. many Applies a parser zero or more times until it fails, returning all of the results in an array. many1 Applies a parser one or more times until it fails, returning all of the results in an array. skipMany Applies a parser zero or more times until it fails, discarding the results. skipMany1 Applies a parser one or more times until it fails, discarding the results. sepBy Applies a content parser zero or more times with an application of a separator parser between each. Returns the content parser results. sepBy1 Applies a content parser one or more times with an application of a separator parser between each. Returns the content parser results. sepEndBy Applies a content parser zero or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. sepEndBy1 Applies a content parser one or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. repeat Applies a parser a certain number of times, returning the results in an array. manyTill Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. assocL Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1L Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assocR Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1R Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. Table 7: Alternative combinators Parser Description orElse Applies a parser and, if it fails, a second parser. choice Applies a series of parsers one at a time until one succeeds. optional Applies a parser and returns its result on success. On failure, succeeds but returns nothing. orValue Applies a parser and returns either its result upon success or another value upon failure. Table 8: Backtracking combinators Parser Description attempt Applies a parser, backtracking to its original position if the parser fails and consumes input. sequenceB Applies a series of parsers in order, returning their results in an array. Backtracks to where the first parser was applied if any other of its parsers fails. blockB Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. Backtracks to where the first yielded parser was applied if any later parser fails. chainB Applies a parser, then applies a function to the result, then applies the parser returned by the function. Backtracks to where the first parser was applied if the parser returned by the function fails. leftB Applies two parsers in order and returns the result of the first one. Backtracks to the location where the first parser was applied if the second one fails. rightB Applies two parsers in order and returns the result of the second one. Backtracks to the location where the first parser was applied if the second one fails. andThenB Applies two parsers in order and returns the results of both in a tuple. Backtracks to the location where the first parser was applied if the second one fails. pipeB Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. Backtracks to where the first parser was applied if any other parser fails. repeatB Applies a parser a certain number of times, returning the results in an array. Backtracks to where the first parser was applied if any other parser fails. manyTillB Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. Backtracks to where the content parser was first applied if it fails before the end parser succeeds. betweenB Applies a content parser between two other parsers, returning only the content parser's result. Backtracks to where the first parser was applied if either other parser fails. Table 9: Conditional and lookahead combinators Parser Description lookAhead Applies a parser and returns its result without consuming input. notEmpty Applies a parser and fails if the parser succeeds without consuming input. followedBy Applies a parser and succeeds without consuming input if that parser succeeds. notFollowedBy Applies a parser and succeeds without consuming input if that parser fails. Table 10: Error message combinators Parser Description label Applies a parser and replaces its errors with an expected error if that parser fails. attemptM Applies a parser and replaces its errors with an expected error if that parser fails. Backtracks to where the parser was applied and adds additional information to the error message if that parser consumes input. notEmptyM Applies a parser and fails if the parser succeeds without consuming input. Overwrites the error message with a custom one on failure. followedByM Applies a parser and succeeds without consuming input if that parser succeeds. Overwrites the error message with a custom one on failure. notFollowedByM Applies a parser and succeeds without consuming input if that parser fails. Overwrites the error message with a custom one on failure.","title":"Summary"},{"location":"api/#summary","text":"","title":"Summary"},{"location":"api/#terminology","text":"A couple notes on terms you'll find in this API documentation.","title":"Terminology"},{"location":"api/#parser","text":"Everything in the Parser API Reference is referred to as a parser . This is not exactly accurate; in Kessel, a parser is a function that takes a context as an argument and returns a tuple of an updated context and a result. By that definition, the only parsers in here are things like any and letter that don't take any additional parameters. A number of items in the reference are functions that produce parsers. Examples are char and string . These require extra information to know what to parse - char needs to know which character it's looking for, for example - so they have parameters to let them accept that information. But these functions return parsers. In other words, char is not a parser, but char('a') is. Because of that, it's safe enough to refer to these functions as parsers as well. The final class of object in the Parser API Reference is the combinator . A combinator is a function that takes one or more parsers as parameters, maybe with other parameters as well, and return another parser. ( block and blockB take generator functions instead of parsers, but since those generator functions can call parsers in their bodies, they can also be considered combinators.) Combinators are a little different because they don't actually read text. Every parser or parser-producing function, at the core, is a function that reads one or more characters of text and either succeeds or fails depending on whether it read the character(s) it was expecting. Combinators don't do that; they modify or compose other parsers. For example, many doesn't read any text at all, but it tells the parser passed into it to read text zero or more times. But in the end it's all the same. many may not parse text directly, but it has a value passed to it which may be a parser itself. If it's not, then it must be a combinator that has a value passed to it . Eventually, there's going to be a parser, and it will read text. So many may not be a parser, and the same with choice and pipe and join , but pipe(choice(char('_'), letter), join(many(choice(char('_'), letter, digit))), (first, rest) => first + rest) is definitely a parser. (One which does a pretty reasonable job of parsing a programming language identifier..md) In summary, every entry in the Parser API Reference either is a function that takes a context and returns a tuple of a context and a result, or it produces one. And directly or indirectly, every entry reads text. So unless there needs to be some distinction between these three different kinds of objects, it's safe to just call them all parsers .","title":"Parser"},{"location":"api/#return","text":"As has already been stated way more times than is necessary, a parser returns a tuple of a context and a result. But as is also very clear, that's way too many words to use too many times. In this documentation, we will talk about parsers returning values. In this case, \"this parser returns a string\" means \"this parser returns a tuple of a context and a result, and upon success, the value of that result is a string.\" I think we can all agree that one is more fun to read (and write) than the other.","title":"Return"},{"location":"api/#parsers","text":"","title":"Parsers"},{"location":"api/#table-1-single-character-parsers","text":"Parser Description char Parses a single character. charI Parses a single character, but without case sensitivity. satisfy Parses a single character for which a predicate returns true . satisfyM Parses a single character for which a predicate returns true . Fails with a message string if the predicate returns false . range Parses a single character whose code point is between two other characters. any Parses any one character. anyOf Parses a single character which is included in a string or an array. noneOf Parses a single character which is not in included in a string or an array. digit Parses a single decimal digit ( 0-9 ). hex Parses a single hexadecmial digit ( 0-9 , a-f , or A-F ). octal Parses a single octal digit ( 0-7 ). letter Parses a single ASCII letter ( a-z or A-Z ). alpha Parses a single ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). lower Parses a single ASCII lowercase letter ( a-z ). upper Parses a single ASCII uppercase letter ( A-Z ). letterU Parses a single UTF-8 letter. alphaU Parses a single UTF-8 alphanumeric character. lowerU Parses a single UTF-8 lowercase letter. upperU Parses a single UTF-8 uppercase letter.","title":"Table 1: Single character parsers"},{"location":"api/#table-2-string-multiple-character-parsers","text":"Parser Description string Parses a string. stringI Parses a string, but without case sensitivity. regex Parses a string matching a regular expression pattern. all Parses the remainder of the input as a string. anyString Parses a string of a certain number of characters.","title":"Table 2: String (multiple-character) parsers"},{"location":"api/#table-3-whitespace-parsers","text":"Parser Description newline Parses a single ASCII newline character ( \\r , \\n , or \\r\\n ). space Parses a single ASCII whitespace character ( , \\t , or a newline). spaces Skips zero or more ASCII whitespace characters. spaces1 Skips one or more ASCII whitespace characters. newlineU Parses a single UTF-8 newline character. spaceU Parses a single UTF-8 whitespace character (including newlines.md). spacesU Skips zero or more UTF-8 whitespace characters. spaces1U Skips one or more UTF-8 whitespace characters. eof Succeeds only at the end of the input.","title":"Table 3: Whitespace parsers"},{"location":"api/#table-4-miscellaneous-parsers","text":"Parser Description always Always succeeds and returns a value. empty Always succeeds and returns nothing. apply Parses content and a function, returning the result of the function when passed the content. failNormally Fails with a generic message. failFatally Fails fatally with a generic message.","title":"Table 4: Miscellaneous parsers"},{"location":"api/#table-5-chaining-combinators","text":"Parser Description chain Applies a parser, then applies a function to the result, then applies the parser returned by the function. value Applies a parser and returns a value. skip Applies a parser and discards the result. map Applies a parser, then applies a function to the result, then returns the result of that function. left Applies two parsers in order and returns the result of the first one. right Applies two parsers in order and returns the result of the second one. pipe Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. between Applies a content parser between two other parsers, returning only the content parser's result. nth Applies a parser and returns the nth element of the resulting array. first Applies a parser and returns the first element of the resulting array. second Applies a parser and returns the second element of the resulting array. third Applies a parser and returns the third element of the resulting array. fourth Applies a parser and returns the fourth element of the resulting array. fifth Applies a parser and returns the fifth element of the resulting array. join Applies a parser and returns its resulting array elements joined together into a string.","title":"Table 5: Chaining combinators"},{"location":"api/#table-6-sequence-combinators","text":"Parser Description andThen Applies two parsers in order and returns their results in a tuple. sequence Applies a series of parsers in order, returning their results in an array. block Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. many Applies a parser zero or more times until it fails, returning all of the results in an array. many1 Applies a parser one or more times until it fails, returning all of the results in an array. skipMany Applies a parser zero or more times until it fails, discarding the results. skipMany1 Applies a parser one or more times until it fails, discarding the results. sepBy Applies a content parser zero or more times with an application of a separator parser between each. Returns the content parser results. sepBy1 Applies a content parser one or more times with an application of a separator parser between each. Returns the content parser results. sepEndBy Applies a content parser zero or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. sepEndBy1 Applies a content parser one or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. repeat Applies a parser a certain number of times, returning the results in an array. manyTill Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. assocL Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1L Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assocR Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1R Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser.","title":"Table 6: Sequence combinators"},{"location":"api/#table-7-alternative-combinators","text":"Parser Description orElse Applies a parser and, if it fails, a second parser. choice Applies a series of parsers one at a time until one succeeds. optional Applies a parser and returns its result on success. On failure, succeeds but returns nothing. orValue Applies a parser and returns either its result upon success or another value upon failure.","title":"Table 7: Alternative combinators"},{"location":"api/#table-8-backtracking-combinators","text":"Parser Description attempt Applies a parser, backtracking to its original position if the parser fails and consumes input. sequenceB Applies a series of parsers in order, returning their results in an array. Backtracks to where the first parser was applied if any other of its parsers fails. blockB Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. Backtracks to where the first yielded parser was applied if any later parser fails. chainB Applies a parser, then applies a function to the result, then applies the parser returned by the function. Backtracks to where the first parser was applied if the parser returned by the function fails. leftB Applies two parsers in order and returns the result of the first one. Backtracks to the location where the first parser was applied if the second one fails. rightB Applies two parsers in order and returns the result of the second one. Backtracks to the location where the first parser was applied if the second one fails. andThenB Applies two parsers in order and returns the results of both in a tuple. Backtracks to the location where the first parser was applied if the second one fails. pipeB Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. Backtracks to where the first parser was applied if any other parser fails. repeatB Applies a parser a certain number of times, returning the results in an array. Backtracks to where the first parser was applied if any other parser fails. manyTillB Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. Backtracks to where the content parser was first applied if it fails before the end parser succeeds. betweenB Applies a content parser between two other parsers, returning only the content parser's result. Backtracks to where the first parser was applied if either other parser fails.","title":"Table 8: Backtracking combinators"},{"location":"api/#table-9-conditional-and-lookahead-combinators","text":"Parser Description lookAhead Applies a parser and returns its result without consuming input. notEmpty Applies a parser and fails if the parser succeeds without consuming input. followedBy Applies a parser and succeeds without consuming input if that parser succeeds. notFollowedBy Applies a parser and succeeds without consuming input if that parser fails.","title":"Table 9: Conditional and lookahead combinators"},{"location":"api/#table-10-error-message-combinators","text":"Parser Description label Applies a parser and replaces its errors with an expected error if that parser fails. attemptM Applies a parser and replaces its errors with an expected error if that parser fails. Backtracks to where the parser was applied and adds additional information to the error message if that parser consumes input. notEmptyM Applies a parser and fails if the parser succeeds without consuming input. Overwrites the error message with a custom one on failure. followedByM Applies a parser and succeeds without consuming input if that parser succeeds. Overwrites the error message with a custom one on failure. notFollowedByM Applies a parser and succeeds without consuming input if that parser fails. Overwrites the error message with a custom one on failure.","title":"Table 10: Error message combinators"},{"location":"installation/","text":"Installation npm install @barandis/kessel This won't actually be available on NPM until I finish basic documentation, which should happen around the beginning of December. There are also self-contained files ( kessel.js and the minified kessel.min.js ) in the lib directory of the distribution. These will work in the browser (where a global kessel object is provided) or with CommonJS or AMD. Assertions The default Kessel library uses assertions to ensure that input to parsers is what it's supposed to be. This is more than type-checking like in TypeScript - runtime failures will result if the wrong kind of input is given to a parser. Defensive programming is not normally a philosophy that I take to, but understanding the source of errors is so important in parsing that it seems appropriate here. The assertions slow down parsing, though I suspect that the amount of time added is negligible (this has not yet been benchmarked, though that is on the list of things to do). Every input that has a definitive type is checked, so if you have a choice that takes a thousand parsers, maybe that will be a bit slower. The distribution does contain versions without assertions, named kessel.noassert.js and kessel.noassert.min.js . If you are seriously concerned about performance you can choose to use these instead.","title":"Installation"},{"location":"installation/#installation","text":"npm install @barandis/kessel This won't actually be available on NPM until I finish basic documentation, which should happen around the beginning of December. There are also self-contained files ( kessel.js and the minified kessel.min.js ) in the lib directory of the distribution. These will work in the browser (where a global kessel object is provided) or with CommonJS or AMD.","title":"Installation"},{"location":"installation/#assertions","text":"The default Kessel library uses assertions to ensure that input to parsers is what it's supposed to be. This is more than type-checking like in TypeScript - runtime failures will result if the wrong kind of input is given to a parser. Defensive programming is not normally a philosophy that I take to, but understanding the source of errors is so important in parsing that it seems appropriate here. The assertions slow down parsing, though I suspect that the amount of time added is negligible (this has not yet been benchmarked, though that is on the list of things to do). Every input that has a definitive type is checked, so if you have a choice that takes a thousand parsers, maybe that will be a bit slower. The distribution does contain versions without assertions, named kessel.noassert.js and kessel.noassert.min.js . If you are seriously concerned about performance you can choose to use these instead.","title":"Assertions"},{"location":"overview/","text":"Overview Kessel is a parser combinator library inspired heavily by the Parsec library written in Haskell and its F# counterpart FParsec . It shares many of the features of these libraries, brought to JavaScript, and includes some others. Full UTF-8 support, including 3- and 4-byte characters that JavaScript doesn't regularly support Detailed error messages and facilities to customize error messages Optimized implementations of combinators to help make up for the relative slowness of parser combinators in general Written in a consistent functional style, which makes it natural to create new parsers that look and work just like the packaged ones Selectable backtracking Ability to write arbitrary functions that contain other parsers and can be used as parsers themselves To illustrate, here's a short parser definition for a CSV parser. This is a fully featured parser which can handle quoted commas, escaped quotes, and the like. This example is taken from a similar example in the online book Real World Haskell . It's shorter than the Haskell/Parsec version, but JavaScript's lack of custom operators means it's perhaps a bit more dense. Parser Code import { char , choice , join , label , many , newline , noneOf , run , second , sepBy , sepEndBy , sequenceB , string , value , } from '@barandis/kessel' const quotedChar = choice ( noneOf ( '\"' ), value ( string ( '\"\"' ), '\"' )) const quotedCell = second ( sequenceB ( char ( '\"' ), join ( many ( quotedChar )), label ( char ( '\"' ), 'quote at end of cell' ), )) const cell = choice ( quotedCell , join ( many ( noneOf ( ',\\n\\r' )))) const line = sepBy ( cell , char ( ',' )) const csv = sepEndBy ( line , newline ) const parseCsv = input => run ( csv , input ) Example Run // CSV input is from Wikipedia's article on comma-separated values // https://en.wikipedia.org/wiki/Comma-separated_values#Example const text = `Year,Make,Model,Description,Price 1997,Ford,E350,\"ac, abs, moon\",3000.00 1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00 1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",,5000.00 1996,Jeep,Grand Cherokee,\"MUST SELL! air, moon roof, loaded\",4799.00` const result = parseCsv ( text ) // `result` is equal to the following: // [ // ['Year', 'Make', 'Model', 'Description', 'Price'], // ['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition\"', '', '4900.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition, Very Large\"', '', '5000.00'], // ['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL! air, moon roof, loaded', '4799.00'] // ]","title":"Overview"},{"location":"overview/#overview","text":"Kessel is a parser combinator library inspired heavily by the Parsec library written in Haskell and its F# counterpart FParsec . It shares many of the features of these libraries, brought to JavaScript, and includes some others. Full UTF-8 support, including 3- and 4-byte characters that JavaScript doesn't regularly support Detailed error messages and facilities to customize error messages Optimized implementations of combinators to help make up for the relative slowness of parser combinators in general Written in a consistent functional style, which makes it natural to create new parsers that look and work just like the packaged ones Selectable backtracking Ability to write arbitrary functions that contain other parsers and can be used as parsers themselves To illustrate, here's a short parser definition for a CSV parser. This is a fully featured parser which can handle quoted commas, escaped quotes, and the like. This example is taken from a similar example in the online book Real World Haskell . It's shorter than the Haskell/Parsec version, but JavaScript's lack of custom operators means it's perhaps a bit more dense. Parser Code import { char , choice , join , label , many , newline , noneOf , run , second , sepBy , sepEndBy , sequenceB , string , value , } from '@barandis/kessel' const quotedChar = choice ( noneOf ( '\"' ), value ( string ( '\"\"' ), '\"' )) const quotedCell = second ( sequenceB ( char ( '\"' ), join ( many ( quotedChar )), label ( char ( '\"' ), 'quote at end of cell' ), )) const cell = choice ( quotedCell , join ( many ( noneOf ( ',\\n\\r' )))) const line = sepBy ( cell , char ( ',' )) const csv = sepEndBy ( line , newline ) const parseCsv = input => run ( csv , input ) Example Run // CSV input is from Wikipedia's article on comma-separated values // https://en.wikipedia.org/wiki/Comma-separated_values#Example const text = `Year,Make,Model,Description,Price 1997,Ford,E350,\"ac, abs, moon\",3000.00 1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00 1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",,5000.00 1996,Jeep,Grand Cherokee,\"MUST SELL! air, moon roof, loaded\",4799.00` const result = parseCsv ( text ) // `result` is equal to the following: // [ // ['Year', 'Make', 'Model', 'Description', 'Price'], // ['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition\"', '', '4900.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition, Very Large\"', '', '5000.00'], // ['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL! air, moon roof, loaded', '4799.00'] // ]","title":"Overview"},{"location":"parsers/all/","text":"all Parses the entire remaining input. Example const parser = all const s = parse ( parser , 'content' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"content\" Success Always succeeds. Consumes all remaining characters and returns those characters as a single string. If the current parse location is already at the end of input, all will return the empty string and consume nothing. See Also anyString eof","title":"all"},{"location":"parsers/all/#example","text":"const parser = all const s = parse ( parser , 'content' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"content\"","title":"Example"},{"location":"parsers/all/#success","text":"Always succeeds. Consumes all remaining characters and returns those characters as a single string. If the current parse location is already at the end of input, all will return the empty string and consume nothing.","title":"Success"},{"location":"parsers/all/#see-also","text":"anyString eof","title":"See Also"},{"location":"parsers/alpha/","text":"alpha Parses an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). This does not parse UTF-8 alphanumeric characters in general. Use alphaU for that. Example const parser = alpha const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '---' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected an alphanumeric character Success Succeeds if the next character is an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letter lower upper","title":"alpha"},{"location":"parsers/alpha/#example","text":"const parser = alpha const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '---' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected an alphanumeric character","title":"Example"},{"location":"parsers/alpha/#success","text":"Succeeds if the next character is an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/alpha/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/alpha/#see-also","text":"alphaU letter lower upper","title":"See Also"},{"location":"parsers/alphau/","text":"alphaU Parses a Unicode alphanumeric character. A character is a Unicode alphanumeric character if it has either the Unicode Alphabetic binary property or the Unicode Number binary property. Example const parser = alphaU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '---' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected a Unicode alphanumeric character Success Succeeds if the next character is a Unicode alphanumeric character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letterU lowerU upperU","title":"alphaU"},{"location":"parsers/alphau/#example","text":"const parser = alphaU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '---' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected a Unicode alphanumeric character","title":"Example"},{"location":"parsers/alphau/#success","text":"Succeeds if the next character is a Unicode alphanumeric character. Consumes and returns that character.","title":"Success"},{"location":"parsers/alphau/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/alphau/#see-also","text":"alpha letterU lowerU upperU","title":"See Also"},{"location":"parsers/always/","text":"always(x) Always succeeds and returns its passed value. This is the only parser that can return a value that is not a string. (Some combinators can also do this.) Example const parser = always ( 3.14 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 3.14 Parameters x An arbitrary value that this parser always returns. Success Always succeeds. Returns x and consumes no input. See Also apply value","title":"always"},{"location":"parsers/always/#example","text":"const parser = always ( 3.14 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 3.14","title":"Example"},{"location":"parsers/always/#parameters","text":"x An arbitrary value that this parser always returns.","title":"Parameters"},{"location":"parsers/always/#success","text":"Always succeeds. Returns x and consumes no input.","title":"Success"},{"location":"parsers/always/#see-also","text":"apply value","title":"See Also"},{"location":"parsers/andthen/","text":"andThen(p, q) Applies two parsers in order, returning their results in a tuple. If either parser fails, then the entire andThen parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p or q failed fatally). In the examples, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. This is the primitive combinator for sequencing parsers. In languages that have custom operators, it is often implemented as an operator like .>>. . There is another version of this parser ( andThenB ) that will backtrack and fail non-fatally if p succeeds and q fails non-fatally. andThen does not emulate a member of a Haskell type class, but as the simplest sequential parser, it could be implemented using either chain (monadic style) or apply (applicative style). andThen(p, q) is equivalent to each of the following. // Monadic style, using chain chain ( p , a => chain ( q , b => always ([ a , b ]))) // Applicative style, using apply apply ( p , apply ( q , always ( b => a => [ a , b ]))) andThen is implemented in neither way, using an imperative style for more performance, but it may be useful to know how it fits in with monadic and applicative parsing. Example const parser = andThen ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The first parser to apply. If both parsers succeed, this parser's result will be the first element of andThen 's result. q The second parser to apply. If both parsers succeed, this parser's result will be the second element of andThen 's result. Success Succeeds if both p and q succeed. Returns their results in a tuple. Failure Fails if p fails. Fails if q fails after p succeeds but does not consume input. Fatal Failure Fails fatally if either p or q fails fatally. Fails fatally if q fails after p succeeds and consumes some input. Throws Throws an error if either p or q are not parsers. See Also andThenB apply chain left right sequence","title":"andThen"},{"location":"parsers/andthen/#example","text":"const parser = andThen ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/andthen/#parameters","text":"p The first parser to apply. If both parsers succeed, this parser's result will be the first element of andThen 's result. q The second parser to apply. If both parsers succeed, this parser's result will be the second element of andThen 's result.","title":"Parameters"},{"location":"parsers/andthen/#success","text":"Succeeds if both p and q succeed. Returns their results in a tuple.","title":"Success"},{"location":"parsers/andthen/#failure","text":"Fails if p fails. Fails if q fails after p succeeds but does not consume input.","title":"Failure"},{"location":"parsers/andthen/#fatal-failure","text":"Fails fatally if either p or q fails fatally. Fails fatally if q fails after p succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/andthen/#throws","text":"Throws an error if either p or q are not parsers.","title":"Throws"},{"location":"parsers/andthen/#see-also","text":"andThenB apply chain left right sequence","title":"See Also"},{"location":"parsers/andthenb/","text":"andThenB(p, q) Applies two parsers in order, returning their results in a tuple. If either parser fails, then the entire andThenB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p was applied. Example const parser = andThenB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The first parser to apply. If both parsers succeed, this parser's result will be the first element of andThenB 's result. q The second parser to apply. If both parsers succeed, this parser's result will be the second element of andThenB 's result. Success Succeeds if both p and q succeed. Returns their results in a tuple. Failure Fails if either p or q fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or q fails fatally. Throws Throws an error if either p or q are not parsers. See Also andThen leftB rightB sequenceB","title":"andThenB"},{"location":"parsers/andthenb/#example","text":"const parser = andThenB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/andthenb/#parameters","text":"p The first parser to apply. If both parsers succeed, this parser's result will be the first element of andThenB 's result. q The second parser to apply. If both parsers succeed, this parser's result will be the second element of andThenB 's result.","title":"Parameters"},{"location":"parsers/andthenb/#success","text":"Succeeds if both p and q succeed. Returns their results in a tuple.","title":"Success"},{"location":"parsers/andthenb/#failure","text":"Fails if either p or q fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/andthenb/#fatal-failure","text":"Fails fatally if either p or q fails fatally.","title":"Fatal Failure"},{"location":"parsers/andthenb/#throws","text":"Throws an error if either p or q are not parsers.","title":"Throws"},{"location":"parsers/andthenb/#see-also","text":"andThen leftB rightB sequenceB","title":"See Also"},{"location":"parsers/any/","text":"any Parses any single character. Example const parser = any const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Success Succeeds as long as there is a character to be read. That character is consumed and returned. Failure Fails at the end of input. See Also anyString","title":"any"},{"location":"parsers/any/#example","text":"const parser = any const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/any/#success","text":"Succeeds as long as there is a character to be read. That character is consumed and returned.","title":"Success"},{"location":"parsers/any/#failure","text":"Fails at the end of input.","title":"Failure"},{"location":"parsers/any/#see-also","text":"anyString","title":"See Also"},{"location":"parsers/anyof/","text":"anyOf(cs) Parses a character if that character is included in cs . Example const parser = anyOf ( 'Test' ) const s = parse ( parser , 'Test' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"T\" const f = parse ( parser , 'Exit' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Exit // ^ // Expected any of 'T', 'e', 's', or 't' Parameters cs The set of characters that the next character is expected to be a part of. This can be either a string or an array of single-character strings. Success Succeeds if the next character is one of the characters in cs . Consumes and returns that character. Failure Fails if the next character is any other character. Throws Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length. See Also noneOf","title":"anyOf"},{"location":"parsers/anyof/#example","text":"const parser = anyOf ( 'Test' ) const s = parse ( parser , 'Test' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"T\" const f = parse ( parser , 'Exit' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Exit // ^ // Expected any of 'T', 'e', 's', or 't'","title":"Example"},{"location":"parsers/anyof/#parameters","text":"cs The set of characters that the next character is expected to be a part of. This can be either a string or an array of single-character strings.","title":"Parameters"},{"location":"parsers/anyof/#success","text":"Succeeds if the next character is one of the characters in cs . Consumes and returns that character.","title":"Success"},{"location":"parsers/anyof/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/anyof/#throws","text":"Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length.","title":"Throws"},{"location":"parsers/anyof/#see-also","text":"noneOf","title":"See Also"},{"location":"parsers/anystring/","text":"anyString(n) Parses a string that is n characters long. Example const parser = anyString ( 3 ) const s = parse ( parser , 'abcdef' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"abc\" const f = parse ( parser , 'ab' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // Expected a string of 3 characters Parameters n The number of characters to read. Success Succeeds if there are at least n characters remaining to read. Consumes that many characters and returns them as a single string. If n is less than 1, no characters will be consumed and the empty string will be returned. Failure Fails if there are not at least n characters remaining in the input. Throws Throws an error if n is not a number. See Also all any","title":"anyString"},{"location":"parsers/anystring/#example","text":"const parser = anyString ( 3 ) const s = parse ( parser , 'abcdef' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"abc\" const f = parse ( parser , 'ab' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // Expected a string of 3 characters","title":"Example"},{"location":"parsers/anystring/#parameters","text":"n The number of characters to read.","title":"Parameters"},{"location":"parsers/anystring/#success","text":"Succeeds if there are at least n characters remaining to read. Consumes that many characters and returns them as a single string. If n is less than 1, no characters will be consumed and the empty string will be returned.","title":"Success"},{"location":"parsers/anystring/#failure","text":"Fails if there are not at least n characters remaining in the input.","title":"Failure"},{"location":"parsers/anystring/#throws","text":"Throws an error if n is not a number.","title":"Throws"},{"location":"parsers/anystring/#see-also","text":"all any","title":"See Also"},{"location":"parsers/apply/","text":"apply(p, f) Applies two parsers, the second of which must return a function. Returns the result of that function when the result of the other parser is passed to it. This parser is the applicative-style counterpart of the monadic-style chain . It corresponds to the <*> member of the Applicative type class in Haskell, which basically means that it's used for applying functions that are already \"inside\" a parser. As with chain it's not likely to see a lot of use, as none of the Kessel parsers are actually implemented in terms of it, but it's available should anyone feel the need to write parsers in an applicative style. As this parser requires that one of its parser return a function, always is often used to provide that parser. Example const parser = apply ( left ( letter , digit ), always ( c => c . toUpperCase ())) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Parameters p A parser whose result is passed to the function that results from f . f A parser that returns a function. Success Succeeds if both p and f succeed. Returns the result of the function returned by f when applied to the result of p . Failure Fails if p fails. Fails if f fails after p succeeds without consuming any input. Fatal Failure Fails fatally if either p or f fail fatally. Fails if f fails after p succeeds while consuming some input. Throws Throws an error if either p or f are not parsers. Throws an error if f succeeds but does not return a non-parser function. See Also always andThen chain","title":"apply"},{"location":"parsers/apply/#example","text":"const parser = apply ( left ( letter , digit ), always ( c => c . toUpperCase ())) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a'","title":"Example"},{"location":"parsers/apply/#parameters","text":"p A parser whose result is passed to the function that results from f . f A parser that returns a function.","title":"Parameters"},{"location":"parsers/apply/#success","text":"Succeeds if both p and f succeed. Returns the result of the function returned by f when applied to the result of p .","title":"Success"},{"location":"parsers/apply/#failure","text":"Fails if p fails. Fails if f fails after p succeeds without consuming any input.","title":"Failure"},{"location":"parsers/apply/#fatal-failure","text":"Fails fatally if either p or f fail fatally. Fails if f fails after p succeeds while consuming some input.","title":"Fatal Failure"},{"location":"parsers/apply/#throws","text":"Throws an error if either p or f are not parsers. Throws an error if f succeeds but does not return a non-parser function.","title":"Throws"},{"location":"parsers/apply/#see-also","text":"always andThen chain","title":"See Also"},{"location":"parsers/assoc1l/","text":"assoc1L(p, op) Parses one or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content left-associatively. The operation parser op must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so op must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If op succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first op to the values returned by the first two p s, then applying the function returned by the second op to that value and the value returned by the third p , and so on. assoc1L fails if p never succeeds, but it is not required that op ever succeed. If op never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1L ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 34 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocL for an explanation of the example. That example works identically to this one. Parameters p The content parser. op The operation parser. This parser must return a function. Success Succeeds if p succeeds at least once and neither p nor op ever fail fatally. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned. Failure Fails if p fails on its first attempt. Fatal Failure Fails fatally if either p or op fail fatally. Throws Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function. See Also assocL assoc1R","title":"assoc1L"},{"location":"parsers/assoc1l/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1L ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 34 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocL for an explanation of the example. That example works identically to this one.","title":"Example"},{"location":"parsers/assoc1l/#parameters","text":"p The content parser. op The operation parser. This parser must return a function.","title":"Parameters"},{"location":"parsers/assoc1l/#success","text":"Succeeds if p succeeds at least once and neither p nor op ever fail fatally. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned.","title":"Success"},{"location":"parsers/assoc1l/#failure","text":"Fails if p fails on its first attempt.","title":"Failure"},{"location":"parsers/assoc1l/#fatal-failure","text":"Fails fatally if either p or op fail fatally.","title":"Fatal Failure"},{"location":"parsers/assoc1l/#throws","text":"Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function.","title":"Throws"},{"location":"parsers/assoc1l/#see-also","text":"assocL assoc1R","title":"See Also"},{"location":"parsers/assoc1r/","text":"assoc1R(p, op) Parses one or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content right-associatively. The operation parser op must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so op must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If op succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first op to the values returned by the first two p s, then applying the function returned by the second op to that value and the value returned by the third p , and so on. assoc1R fails if p never succeeds, but it is not required that op ever succeed. If op never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1R ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -78 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocR for an explanation of the example. That example works identically to this one. Parameters p The content parser. op The operation parser. This parser must return a function. Success Succeeds if p succeeds at least once and neither p nor op ever fail fatally. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned. Failure Fails if p fails on its first attempt. Fatal Failure Fails fatally if either p or op fail fatally. Throws Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function. See Also assoc1L assocR","title":"assoc1R"},{"location":"parsers/assoc1r/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1R ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -78 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocR for an explanation of the example. That example works identically to this one.","title":"Example"},{"location":"parsers/assoc1r/#parameters","text":"p The content parser. op The operation parser. This parser must return a function.","title":"Parameters"},{"location":"parsers/assoc1r/#success","text":"Succeeds if p succeeds at least once and neither p nor op ever fail fatally. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned.","title":"Success"},{"location":"parsers/assoc1r/#failure","text":"Fails if p fails on its first attempt.","title":"Failure"},{"location":"parsers/assoc1r/#fatal-failure","text":"Fails fatally if either p or op fail fatally.","title":"Fatal Failure"},{"location":"parsers/assoc1r/#throws","text":"Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function.","title":"Throws"},{"location":"parsers/assoc1r/#see-also","text":"assoc1L assocR","title":"See Also"},{"location":"parsers/assocl/","text":"assocL(p, op, x) Parses zero or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content left-associatively. The operation parser op must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so op must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If op succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first op to the values returned by the first two p s, then applying the function returned by the second op to that value and the value returned by the third p , and so on. If p never succeeds, assocL still succeeds, but it returns the value x directly. If op never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocL ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 34 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these left-associatively results in (12 - 34) + 56 , which evaluates to 34 . Parameters p The content parser. op The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once. Success Succeeds if neither p nor op fail fatally. If p never succeeds, x is returned. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned. Fatal Failure Fails fatally if either p or op fail fatally. Throws Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function. See Also assoc1L assocR","title":"assocL"},{"location":"parsers/assocl/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocL ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 34 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these left-associatively results in (12 - 34) + 56 , which evaluates to 34 .","title":"Example"},{"location":"parsers/assocl/#parameters","text":"p The content parser. op The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once.","title":"Parameters"},{"location":"parsers/assocl/#success","text":"Succeeds if neither p nor op fail fatally. If p never succeeds, x is returned. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned.","title":"Success"},{"location":"parsers/assocl/#fatal-failure","text":"Fails fatally if either p or op fail fatally.","title":"Fatal Failure"},{"location":"parsers/assocl/#throws","text":"Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function.","title":"Throws"},{"location":"parsers/assocl/#see-also","text":"assoc1L assocR","title":"See Also"},{"location":"parsers/assocr/","text":"assocR(p, op, x) Parses zero or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content right-associatively. The operation parser op must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so op must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If op succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first op to the values returned by the first two p s, then applying the function returned by the second op to that value and the value returned by the third p , and so on. If p never succeeds, assocR still succeeds, but it returns the value x directly. If op never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocR ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -78 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these right-associatively results in 12 - (34 + 56) , which evaluates to -78 . (This is not mathematically valid \u2014 subtraction is left-associative absent parentheses \u2014 but it serves to illustrate how right-associativity works.) Parameters p The content parser. op The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once. Success Succeeds if neither p nor op fail fatally. If p never succeeds, x is returned. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned. Fatal Failure Fails fatally if either p or op fail fatally. Throws Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function. See Also assocL assoc1R","title":"assocR"},{"location":"parsers/assocr/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocR ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -78 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these right-associatively results in 12 - (34 + 56) , which evaluates to -78 . (This is not mathematically valid \u2014 subtraction is left-associative absent parentheses \u2014 but it serves to illustrate how right-associativity works.)","title":"Example"},{"location":"parsers/assocr/#parameters","text":"p The content parser. op The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once.","title":"Parameters"},{"location":"parsers/assocr/#success","text":"Succeeds if neither p nor op fail fatally. If p never succeeds, x is returned. If p succeeds once and op does not, the result of p is returned. Otherwise, the left associative application of the results of op to the results of p is returned.","title":"Success"},{"location":"parsers/assocr/#fatal-failure","text":"Fails fatally if either p or op fail fatally.","title":"Fatal Failure"},{"location":"parsers/assocr/#throws","text":"Throws an error if either p or op are not parsers. Throws an error if any result of op is not a function.","title":"Throws"},{"location":"parsers/assocr/#see-also","text":"assocL assoc1R","title":"See Also"},{"location":"parsers/attempt/","text":"attempt(p) Applies a parser and, if it fails after consuming input, backtracks to the original location and fails non-fatally. attempt implements general backtracking. It is different from the backtracking B parsers ( sequenceB , leftB , etc.) in that it is meant to deal with all fatal failures (the B parsers only deal with fatal failures that result from non-fatal failures that come after successes). It's common to use this parser in conjunction with choice , optional , and other parsers which only fail if their parsers fail fatally. Take care when using this parser. It attempts to provide information about what caused the backtracking to occur, but it's not hard to get long and convoluted error messages that don't help a lot if it's used to much. Use backtracking as little as can be done and still serve your needs. Example const parser = attempt ( left ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const b = parse ( parser , 'ab' ) console . log ( status ( b )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The parser that is applied and backtracked over if it fails fatally. Success Succeeds if p succeeds. Returns p 's result. Failure Fails if p fails. Fails if p fails fatally. In this case the fatal failure is turned into non-fatal failure and the state is backtracked to where it was before p was applied. Throws Throws an error if p is not a parser. See Also attemptM choice optional orValue","title":"attempt"},{"location":"parsers/attempt/#example","text":"const parser = attempt ( left ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const b = parse ( parser , 'ab' ) console . log ( status ( b )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/attempt/#parameters","text":"p The parser that is applied and backtracked over if it fails fatally.","title":"Parameters"},{"location":"parsers/attempt/#success","text":"Succeeds if p succeeds. Returns p 's result.","title":"Success"},{"location":"parsers/attempt/#failure","text":"Fails if p fails. Fails if p fails fatally. In this case the fatal failure is turned into non-fatal failure and the state is backtracked to where it was before p was applied.","title":"Failure"},{"location":"parsers/attempt/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/attempt/#see-also","text":"attemptM choice optional orValue","title":"See Also"},{"location":"parsers/attemptm/","text":"attemptM(p, msg) Applies a parser, backtracks if necessary, and overwrites its error message on failure. If p succeeds, then attemptM does nothing other than return that parser's result. If p fails, what happens depends on whether input was consumed. If no input was consumed, attemptM acts like label and simply replaces the error message with msg . If some input was consumed, then attemptM backtracks to the location where p was originally applied and adds a more detailed backtracking message using msg as a header. Note that this is slightly different than other xxxM parsers because msg doesn't completely replace the error message. In this case it just provides a header for the backtracking portion of the message. Example const parser = attemptM ( left ( letter , digit ), 'a letter and then a digit' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter and then a digit const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // a letter and then a digit could not be parsed because: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The parser to apply. If it fails, its error message will be changed. msg The error message for when p does not consume input or as a header for backtracking information if p does consume input. Success Succeeds if p succeeds. Returns the result of p . Failure Fails if p fails. In this case, the error message generated by p will be replaced with msg . Fails if p fails fatally. In this case, a new error message is generated, and that generated by p is used as a backtracking message using msg as the header. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also attempt label","title":"attemptM"},{"location":"parsers/attemptm/#example","text":"const parser = attemptM ( left ( letter , digit ), 'a letter and then a digit' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter and then a digit const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // a letter and then a digit could not be parsed because: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/attemptm/#parameters","text":"p The parser to apply. If it fails, its error message will be changed. msg The error message for when p does not consume input or as a header for backtracking information if p does consume input.","title":"Parameters"},{"location":"parsers/attemptm/#success","text":"Succeeds if p succeeds. Returns the result of p .","title":"Success"},{"location":"parsers/attemptm/#failure","text":"Fails if p fails. In this case, the error message generated by p will be replaced with msg . Fails if p fails fatally. In this case, a new error message is generated, and that generated by p is used as a backtracking message using msg as the header.","title":"Failure"},{"location":"parsers/attemptm/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/attemptm/#see-also","text":"attempt label","title":"See Also"},{"location":"parsers/between/","text":"between(pre, post, p) Applies a pre-parser, a content parser, and a post-parser in order, returning the value of the content parser. All three parsers must succeed for between to succeed. Take care to avoid parsing too far with p ; e.g., if the example used join(many(any)) as a content parser instead of what it does, it would also match the ending \" . This would mean that post would never succeed because p already consumed its \" , so between would never succeed. The first failure case in the example ( f ) is non-fatal failure, because no characters were consumed before the failure occurred. The second failure case ( t ) is fatal failure because, though post fails non-fatally, input was consumed before that failure happened. There is another version of this parser, betweenB , which backtracks and fails non-fatally if a non-fatal failure happens after input is consumed. between(pre, post, p) is an optimized implementation of chain(chain(pre, () => p), x => value(post, x)) . (Using higher-level parsers, this can also be written left(right(pre, p), post) .) Example const parser = between ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input Parameters pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself. Success Succeeds if all three parsers succeed. Returns the result of p . Failure Fails if any of its three parsers fails before any input is consumed. Fatal Failure Fails fatally if any of its three parsers fails fatally. Fails fatally if any of its three parsers fails after some input was consumed. Throws Throws an error if any of pre , post , and p are not parsers. See Also betweenB manyTill","title":"between"},{"location":"parsers/between/#example","text":"const parser = between ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/between/#parameters","text":"pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself.","title":"Parameters"},{"location":"parsers/between/#success","text":"Succeeds if all three parsers succeed. Returns the result of p .","title":"Success"},{"location":"parsers/between/#failure","text":"Fails if any of its three parsers fails before any input is consumed.","title":"Failure"},{"location":"parsers/between/#fatal-failure","text":"Fails fatally if any of its three parsers fails fatally. Fails fatally if any of its three parsers fails after some input was consumed.","title":"Fatal Failure"},{"location":"parsers/between/#throws","text":"Throws an error if any of pre , post , and p are not parsers.","title":"Throws"},{"location":"parsers/between/#see-also","text":"betweenB manyTill","title":"See Also"},{"location":"parsers/betweenb/","text":"betweenB(pre, post, p) Applies a pre-parser, a content parser, and a post-parser in order, returning the value of the content parser. All three parsers must succeed for betweenB to succeed. Take care to avoid parsing too far with p ; e.g., if the example used join(many(any)) as a content parser instead of what it does, it would also match the ending \" . This would mean that post would never succeed because p already consumed its \" , so betweenB would never succeed. If any of the parsers fails after some input was consumed, the state will be backtracked to where it was before pre was applied. Example const parser = betweenB ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // \"test // ^ // The parser backtracked after: // // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input Parameters pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself. Success Succeeds if all three parsers succeed. Returns the result of p . Failure Fails if any of its three parsers fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any of its three parsers fails fatally. Throws Throws an error if any of pre , post , and p are not parsers. See Also between manyTillB","title":"betweenB"},{"location":"parsers/betweenb/#example","text":"const parser = betweenB ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // \"test // ^ // The parser backtracked after: // // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/betweenb/#parameters","text":"pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself.","title":"Parameters"},{"location":"parsers/betweenb/#success","text":"Succeeds if all three parsers succeed. Returns the result of p .","title":"Success"},{"location":"parsers/betweenb/#failure","text":"Fails if any of its three parsers fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/betweenb/#fatal-failure","text":"Fails fatally if any of its three parsers fails fatally.","title":"Fatal Failure"},{"location":"parsers/betweenb/#throws","text":"Throws an error if any of pre , post , and p are not parsers.","title":"Throws"},{"location":"parsers/betweenb/#see-also","text":"between manyTillB","title":"See Also"},{"location":"parsers/block/","text":"block(genFn) Executes a generator function that can yield to parsers in its body. block is the most versatile parser in the entire library and provides a way to parse pretty much anything without having to write a custom parser. It corresponds to using do-notation blocks in Haskell (hence the name block ). The generator function can do anything that any function could do. In addition, it can have yield expressions that yield any parser. That parser will be applied at that point, and if it's successful, its result will be fed back into the generator function, able to be used as needed (for example, in const number = yield join(many1(digit)) in the example, the result of the join parser is assigned to the variable number ). When the generator function returns, its return value becomes the value returned by the block parser. If any of the parsers fail when yielded, then block will fail. If any input was consumed before the failure, that failure will be fatal. block can be used to implement pretty much any other combinator. It, in conjunction with any , could be used to implement any other parser in this library. However, if there is a parser that already does what needs to be done, it's sure to be more efficient than just shoving everything into a block . This is most notable with sequences. A block parser that discards a number of parser results and keeps one, returning that result, can very often be implemented as a sequence wrapped in nth . This is a fairly common use case. Example const parser = block ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' 1729 ' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit The first yielded parser here is spaces . This skips zero or more whitespace characters. Its result is discarded as it is not assigned to anything (besides, spaces only returns null so its result isn't useful). The second yielded parser is optional(orElse(char('+'), char('-'))) . This will match either a '+' or '-' if it's there, or return null if the next character is neither of those (without optional it would fail, and we don't want that because it's okay for a number to have no sign). This value (either '+' , '-' , or null ) is assigned to the variable sign . The third yielded parser is join(many1(digit)) . This simply matches a series of one or more digit characters ( 0-9 ), returning them as a single string instead of an array of characters (because of join ). This parses a natural number, assigning the result to number . (When combined with sign , this could be a negative number as well, so the two together parse an integer.) The fourth yielded parser skips whitespace at the end, similar to the first parser. After the parsing is done, sign and number are used in a calculation that turns them into an integer of the JavaScript number type. This number is returned at the end, so the block parser in total results in this number. Note that it isn't a string, like most parsers return; block can return anything that its function can return. The first case ( s ) shows success. Whitespace was skipped before and after the number, an optional sign was parsed (which was not present), and then the string '1729' was parsed. The calculation turned this into the number 1729 , which was returned. The second case ( f ) fails because the first character is not a digit. It does not have to be whitespace ( spaces can match zero spaces) and it does not have to be a sign (that parser is optional), but the digit part of the third parser has to be matched. No input was consumed before this failure, so it is not a fatal failure. The third case ( t ) fails because, while the whitespace was ignored and the optional sign was parsed, the third parser fails against the non-digit 'a' . Since input was consumed (the negative sign) before this failure, it is fatal. Parameters genFn A generator function that provides the body of the block parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the block parser. Success Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function. Failure Fails if any yielded parser fails before any input is consumed. Fatal Failure Fails fatally if any yielded parser fails fatally. Fails fatally if any yielded parser fails non-fatally after some input was consumed. Throws Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser. See Also blockB sequence","title":"block"},{"location":"parsers/block/#example","text":"const parser = block ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' 1729 ' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit The first yielded parser here is spaces . This skips zero or more whitespace characters. Its result is discarded as it is not assigned to anything (besides, spaces only returns null so its result isn't useful). The second yielded parser is optional(orElse(char('+'), char('-'))) . This will match either a '+' or '-' if it's there, or return null if the next character is neither of those (without optional it would fail, and we don't want that because it's okay for a number to have no sign). This value (either '+' , '-' , or null ) is assigned to the variable sign . The third yielded parser is join(many1(digit)) . This simply matches a series of one or more digit characters ( 0-9 ), returning them as a single string instead of an array of characters (because of join ). This parses a natural number, assigning the result to number . (When combined with sign , this could be a negative number as well, so the two together parse an integer.) The fourth yielded parser skips whitespace at the end, similar to the first parser. After the parsing is done, sign and number are used in a calculation that turns them into an integer of the JavaScript number type. This number is returned at the end, so the block parser in total results in this number. Note that it isn't a string, like most parsers return; block can return anything that its function can return. The first case ( s ) shows success. Whitespace was skipped before and after the number, an optional sign was parsed (which was not present), and then the string '1729' was parsed. The calculation turned this into the number 1729 , which was returned. The second case ( f ) fails because the first character is not a digit. It does not have to be whitespace ( spaces can match zero spaces) and it does not have to be a sign (that parser is optional), but the digit part of the third parser has to be matched. No input was consumed before this failure, so it is not a fatal failure. The third case ( t ) fails because, while the whitespace was ignored and the optional sign was parsed, the third parser fails against the non-digit 'a' . Since input was consumed (the negative sign) before this failure, it is fatal.","title":"Example"},{"location":"parsers/block/#parameters","text":"genFn A generator function that provides the body of the block parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the block parser.","title":"Parameters"},{"location":"parsers/block/#success","text":"Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function.","title":"Success"},{"location":"parsers/block/#failure","text":"Fails if any yielded parser fails before any input is consumed.","title":"Failure"},{"location":"parsers/block/#fatal-failure","text":"Fails fatally if any yielded parser fails fatally. Fails fatally if any yielded parser fails non-fatally after some input was consumed.","title":"Fatal Failure"},{"location":"parsers/block/#throws","text":"Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser.","title":"Throws"},{"location":"parsers/block/#see-also","text":"blockB sequence","title":"See Also"},{"location":"parsers/blockb/","text":"blockB(genFn) Executes a generator function that can yield to parsers in its body. This is a backtracking version of the block parser. It operates in exactly the same manner, except that if one of its parsers fail non-fatally after other of its parsers have consumed some input, it will backtrack to the position it was at the beginning of the blockB parser and report a non-fatal failure ( block in this case would not backtrack and its failure would be fatal). The same caveats also apply; blockB can implement any other parser, but it's best to use a more specific one if it suits. Example const parser = blockB ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' -1729 ' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // -abcd // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit See block for a detailed breakdown of the example. That example works exactly the same as this one except with regard to the third case. With block , this case is a fatal error, but blockB backtracks and converts the error to a non-fatal one. Parameters genFn A generator function that provides the body of the blockB parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the blockB parser. Success Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function. Failure Fails if any yielded parser fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any yielded parser fails fatally. Throws Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser. See Also block sequenceB","title":"blockB"},{"location":"parsers/blockb/#example","text":"const parser = blockB ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' -1729 ' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // -abcd // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit See block for a detailed breakdown of the example. That example works exactly the same as this one except with regard to the third case. With block , this case is a fatal error, but blockB backtracks and converts the error to a non-fatal one.","title":"Example"},{"location":"parsers/blockb/#parameters","text":"genFn A generator function that provides the body of the blockB parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the blockB parser.","title":"Parameters"},{"location":"parsers/blockb/#success","text":"Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function.","title":"Success"},{"location":"parsers/blockb/#failure","text":"Fails if any yielded parser fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/blockb/#fatal-failure","text":"Fails fatally if any yielded parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/blockb/#throws","text":"Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser.","title":"Throws"},{"location":"parsers/blockb/#see-also","text":"block sequenceB","title":"See Also"},{"location":"parsers/chain/","text":"chain(p, fn) Applies a parser to the input, passes its result to a function, and then applies the parser that function returns to the input. chain is not used that often itself, but it is a primitive combinator that provides the basis for numerous other parsers. It corresponds to the bind operation in the Monad type class in Haskell, which is often spelled >>= . It can therefore be used to implement sequencing in a monadic style, contrasting with the applicative style offered by apply . This parser is not expected to see a lot of use since none of the Kessels parsers are implemented in terms of it, but it is available in case someone wants to parse monadically without using block . There is another version of this parser ( chainB ) that will backtrack and fail non-fatally if the parser returned by fn fails non-fatally. Example const parser = chain ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' In this example, chain first applies any , which returns the next character of the input. fn then returns char(c) , where c is the result of the any application, and this parser is applied. The upshot is that this example of chain succeeds if the next two characters are the same. In the case of f , chain fails fatally. This is because a character was consumed in p 's success, and if a character is consumed before failure, fatal failure is the result. Parameters p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input. Success Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn . Failure Fails if p fails. Fails if the parser returned by fn fails after p succeeds but consumes no input. Fatal Failure Fails fatally if either p or the parser returned by fn fail fatally. Fails fatally if the parser returned by fn fails after p succeeds and consumes some input. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser. See Also andThen apply chainB map","title":"chain"},{"location":"parsers/chain/#example","text":"const parser = chain ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' In this example, chain first applies any , which returns the next character of the input. fn then returns char(c) , where c is the result of the any application, and this parser is applied. The upshot is that this example of chain succeeds if the next two characters are the same. In the case of f , chain fails fatally. This is because a character was consumed in p 's success, and if a character is consumed before failure, fatal failure is the result.","title":"Example"},{"location":"parsers/chain/#parameters","text":"p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input.","title":"Parameters"},{"location":"parsers/chain/#success","text":"Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn .","title":"Success"},{"location":"parsers/chain/#failure","text":"Fails if p fails. Fails if the parser returned by fn fails after p succeeds but consumes no input.","title":"Failure"},{"location":"parsers/chain/#fatal-failure","text":"Fails fatally if either p or the parser returned by fn fail fatally. Fails fatally if the parser returned by fn fails after p succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/chain/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser.","title":"Throws"},{"location":"parsers/chain/#see-also","text":"andThen apply chainB map","title":"See Also"},{"location":"parsers/chainb/","text":"chainB(p, fn) Example const parser = chainB ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Applies a parser to the input, passes its result to a function, and then applies the parser that function returns to the input. If p succeeds but the parser that is returned by fn fails, the state will backtrack to the location where p was originally applied and chainB will fail non-fatally. Example const parser = chainB ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Parameters p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input. Success Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn . Failure Fails if either p or the parser returned by fn fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or the parser returned by fn fail fatally. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser. See Also chain","title":"chainB"},{"location":"parsers/chainb/#example","text":"const parser = chainB ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Applies a parser to the input, passes its result to a function, and then applies the parser that function returns to the input. If p succeeds but the parser that is returned by fn fails, the state will backtrack to the location where p was originally applied and chainB will fail non-fatally.","title":"Example"},{"location":"parsers/chainb/#example_1","text":"const parser = chainB ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a'","title":"Example"},{"location":"parsers/chainb/#parameters","text":"p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input.","title":"Parameters"},{"location":"parsers/chainb/#success","text":"Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn .","title":"Success"},{"location":"parsers/chainb/#failure","text":"Fails if either p or the parser returned by fn fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/chainb/#fatal-failure","text":"Fails fatally if either p or the parser returned by fn fail fatally.","title":"Fatal Failure"},{"location":"parsers/chainb/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser.","title":"Throws"},{"location":"parsers/chainb/#see-also","text":"chain","title":"See Also"},{"location":"parsers/char/","text":"char(c) Parses the character c . There is no character type in JavaScript, as a \"character\" is just a string with a length of 1. However, using char is a bit more efficient than using string and should be used as long as only one character is needed. Example const parser = char ( 'a' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected 'a' Parameters c The character that the next input character must be in order to succeed. Success Succeeds if the next input character is c . Consumes and returns that character. Failure Fails if the next input character is any other character, including the opposite case version of c . Throws Throws an error if c is not a string or if it isn't exactly one character in length. See Also any charI range string","title":"char"},{"location":"parsers/char/#example","text":"const parser = char ( 'a' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected 'a'","title":"Example"},{"location":"parsers/char/#parameters","text":"c The character that the next input character must be in order to succeed.","title":"Parameters"},{"location":"parsers/char/#success","text":"Succeeds if the next input character is c . Consumes and returns that character.","title":"Success"},{"location":"parsers/char/#failure","text":"Fails if the next input character is any other character, including the opposite case version of c .","title":"Failure"},{"location":"parsers/char/#throws","text":"Throws an error if c is not a string or if it isn't exactly one character in length.","title":"Throws"},{"location":"parsers/char/#see-also","text":"any charI range string","title":"See Also"},{"location":"parsers/chari/","text":"charI(c) Parses the character c or its opposite case equivalent. In other words, this is a case-insensitive version of char . Example const parser = charI ( 'a' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'BCD' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // BCD // ^ // Expected 'a' Parameters c The character that the next input character must be (of any case) in order to succeed. Success Succeeds if the next input character is either c or its opposite case counterpart. Consumes and returns that character. Failure Fails if the next input character is any other character. Throws Throws an error if c is not a string or if it isn't exactly one character in length. See Also any char stringI","title":"charI"},{"location":"parsers/chari/#example","text":"const parser = charI ( 'a' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'BCD' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // BCD // ^ // Expected 'a'","title":"Example"},{"location":"parsers/chari/#parameters","text":"c The character that the next input character must be (of any case) in order to succeed.","title":"Parameters"},{"location":"parsers/chari/#success","text":"Succeeds if the next input character is either c or its opposite case counterpart. Consumes and returns that character.","title":"Success"},{"location":"parsers/chari/#failure","text":"Fails if the next input character is any other character.","title":"Failure"},{"location":"parsers/chari/#throws","text":"Throws an error if c is not a string or if it isn't exactly one character in length.","title":"Throws"},{"location":"parsers/chari/#see-also","text":"any char stringI","title":"See Also"},{"location":"parsers/choice/","text":"choice(...ps) Applies each of its parsers, one at a time, until the first one succeeds, the first one fails fatally, or they all fail. If a parser in ps succeeds, no further parsers will be applied and the result of the successful parser will be returned. If a parser in ps fails fatally, no further parsers will be applied and choice will fail fatally. This rule is necessary to ensure that each branch of the choice is starting from the same state (a fatal failure generally means input is consumed and the state has therefore changed). If all parsers in ps fail, then choice fails as well. choice(p, q) is the same as orElse(p, q) , while choice(p, q, r) is the same as orElse(orElse(p, q), r) , etc. Because of JavaScript's lack of custom operators, choice becomes much more commonly used. In languages with custom operators, that orElse(orElse(p, q), r) would become a much more manageable p <|> q <|> r (if orElse was implemented as <|> , as it is in Parsec and FParsec), and choice itself would be less necessary. orElse(p, q) is more efficient than choice(p, q) , though once a third parser is added choice becomes more efficient. The differences should not be enough to be of concern. Example const parser = choice ( left ( letter , digit ), right ( digit , letter ), space ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const r = parse ( parser , '1a' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"a\" const p = parse ( parser , ' ' ) console . log ( status ( p )) // Symbol(ok) console . log ( success ( p )) // \" \" const f = parse ( parser , '-a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // -a // ^ // Expected a letter, a digit, or whitespace const t = parse ( parser , 'a ' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit or a letter The example shows three success cases, s , r , and p , one for each parser passed to choice . If all of these fail, as in the first failure case ( f ), then failure is the result. In the second failure case ( t ), the first parser fails but consumes input as it does so, so choice is halted at that point without applying its second or third parsers. Fatal failure is the result. Parameters ...ps The parsers to apply one at a time until one succeeds. Success Succeeds if any parser in ps succeeds. Its result is returned. Failure Fails if every parser in ps fails. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws if any member of ps is not a parser. See Also attempt orElse sequence","title":"choice"},{"location":"parsers/choice/#example","text":"const parser = choice ( left ( letter , digit ), right ( digit , letter ), space ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const r = parse ( parser , '1a' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"a\" const p = parse ( parser , ' ' ) console . log ( status ( p )) // Symbol(ok) console . log ( success ( p )) // \" \" const f = parse ( parser , '-a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // -a // ^ // Expected a letter, a digit, or whitespace const t = parse ( parser , 'a ' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit or a letter The example shows three success cases, s , r , and p , one for each parser passed to choice . If all of these fail, as in the first failure case ( f ), then failure is the result. In the second failure case ( t ), the first parser fails but consumes input as it does so, so choice is halted at that point without applying its second or third parsers. Fatal failure is the result.","title":"Example"},{"location":"parsers/choice/#parameters","text":"...ps The parsers to apply one at a time until one succeeds.","title":"Parameters"},{"location":"parsers/choice/#success","text":"Succeeds if any parser in ps succeeds. Its result is returned.","title":"Success"},{"location":"parsers/choice/#failure","text":"Fails if every parser in ps fails.","title":"Failure"},{"location":"parsers/choice/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/choice/#throws","text":"Throws if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/choice/#see-also","text":"attempt orElse sequence","title":"See Also"},{"location":"parsers/digit/","text":"digit Parses a decimal digit ( 0-9 ). Note that this parses ASCII digits, not UTF-8 digits in general. For that, use regex(/^\\p{Nd}/u) . Example const parser = digit const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a digit Success Succeeds if the next character is a decimal digit ( 0-9 ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also hex octal","title":"digit"},{"location":"parsers/digit/#example","text":"const parser = digit const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a digit","title":"Example"},{"location":"parsers/digit/#success","text":"Succeeds if the next character is a decimal digit ( 0-9 ). Consumes and returns that character.","title":"Success"},{"location":"parsers/digit/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/digit/#see-also","text":"hex octal","title":"See Also"},{"location":"parsers/empty/","text":"empty A parser that always succeeds with no result. This primarily exists for completeness, as it corresponds to the same-named operation in the Alternative type class in Haskell. Example const parser = empty const s = parse ( empty , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null Success Always succeeds. Returns nothing and consumes no input. See Also orElse","title":"empty"},{"location":"parsers/empty/#example","text":"const parser = empty const s = parse ( empty , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null","title":"Example"},{"location":"parsers/empty/#success","text":"Always succeeds. Returns nothing and consumes no input.","title":"Success"},{"location":"parsers/empty/#see-also","text":"orElse","title":"See Also"},{"location":"parsers/eof/","text":"eof Attempts to parse a character and succeeds if there is no character to parse. The only time that there is no character to read is at the end of input, so this parser checks specifically for that condition. Example const parser = eof const s = parse ( parser , '' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected end of input Success Succeeds if the current parse location is at the end of input. Returns nothing and consumes no input. Failure Fails if there is any character left to read. See Also all","title":"eof"},{"location":"parsers/eof/#example","text":"const parser = eof const s = parse ( parser , '' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected end of input","title":"Example"},{"location":"parsers/eof/#success","text":"Succeeds if the current parse location is at the end of input. Returns nothing and consumes no input.","title":"Success"},{"location":"parsers/eof/#failure","text":"Fails if there is any character left to read.","title":"Failure"},{"location":"parsers/eof/#see-also","text":"all","title":"See Also"},{"location":"parsers/failfatally/","text":"failFatally(msg) Fails fatally automatically with a custom generic error message. Note that this explicit failure parser is the only way to fail fatally without consuming input. Every other case of fatal failure in Kessel is associated with failure after consuming input. Example const parser = failFatally ( 'a letter please?' ) const t = parse ( parser , '123' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter please? Parameters msg The generic error message to apply. Fatal Failure Always fails fatally. The failure message will be generic(msg) . No input is consumed. Throws Throws an error if msg is not a string. See Also failNormally","title":"failFatally"},{"location":"parsers/failfatally/#example","text":"const parser = failFatally ( 'a letter please?' ) const t = parse ( parser , '123' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter please?","title":"Example"},{"location":"parsers/failfatally/#parameters","text":"msg The generic error message to apply.","title":"Parameters"},{"location":"parsers/failfatally/#fatal-failure","text":"Always fails fatally. The failure message will be generic(msg) . No input is consumed.","title":"Fatal Failure"},{"location":"parsers/failfatally/#throws","text":"Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/failfatally/#see-also","text":"failNormally","title":"See Also"},{"location":"parsers/failnormally/","text":"failNormally(msg) Fails automatically with a custom generic error message. Example const parser = failNormally ( 'a letter, please?' ) const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter, please? Parameters msg The generic error message to apply. Failure Always fails. The failure message will be generic(msg) . Throws Throws an error if msg is not a string. See Also failFatally","title":"failNormally"},{"location":"parsers/failnormally/#example","text":"const parser = failNormally ( 'a letter, please?' ) const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter, please?","title":"Example"},{"location":"parsers/failnormally/#parameters","text":"msg The generic error message to apply.","title":"Parameters"},{"location":"parsers/failnormally/#failure","text":"Always fails. The failure message will be generic(msg) .","title":"Failure"},{"location":"parsers/failnormally/#throws","text":"Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/failnormally/#see-also","text":"failFatally","title":"See Also"},{"location":"parsers/fifth/","text":"fifth(p) Applies a parser and returns the fifth element of the resulting array. This parser works only if p returns an array, and it returns the fifth element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. fifth(p) is an optimized implementation of chain(p, x => always(x[4])) . Example const parser = fifth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"5\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the fifth element of the array that p returns. If there are not at least five elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also first fourth nth second third","title":"fifth"},{"location":"parsers/fifth/#example","text":"const parser = fifth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"5\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/fifth/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/fifth/#success","text":"Succeeds if p succeeds. Returns the fifth element of the array that p returns. If there are not at least five elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/fifth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/fifth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/fifth/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/fifth/#see-also","text":"first fourth nth second third","title":"See Also"},{"location":"parsers/first/","text":"first(p) Applies a parser and returns the first element of the resulting array. This parser works only if p returns an array, and it returns the first element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. first(p) is an optimized implementation of chain(p, x => always(x[0])) . Example const parser = first ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the first element of the array that p returns. If there is not at least one element in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth fourth nth second third","title":"first"},{"location":"parsers/first/#example","text":"const parser = first ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/first/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/first/#success","text":"Succeeds if p succeeds. Returns the first element of the array that p returns. If there is not at least one element in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/first/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/first/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/first/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/first/#see-also","text":"fifth fourth nth second third","title":"See Also"},{"location":"parsers/followedby/","text":"followedBy(p) Applies a parser and succeeds without consuming input if that parser succeeds. This parser is similar to lookAhead except that it does not produce a result. followedBy does not produce an error message on failure. It could, but other related parsers like notEmpty and notFollowedBy cannot, so the choice was made to make followedBy consistent with those parsers. To add an error message, either wrap this parser in label or use followedByM instead. Example const parser = followedBy ( digit ) const s = parse ( parser , '1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Unknown message(s) Parameters p The parser to apply. If it succeeds, followedBy succeeds. Success Succeeds if p succeeds. Does not consume input or return a result. Failure Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case. Throws Throws an error if p is not a parser. See Also followedByM label lookAhead notEmpty notFollowedBy","title":"followedBy"},{"location":"parsers/followedby/#example","text":"const parser = followedBy ( digit ) const s = parse ( parser , '1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Unknown message(s)","title":"Example"},{"location":"parsers/followedby/#parameters","text":"p The parser to apply. If it succeeds, followedBy succeeds.","title":"Parameters"},{"location":"parsers/followedby/#success","text":"Succeeds if p succeeds. Does not consume input or return a result.","title":"Success"},{"location":"parsers/followedby/#failure","text":"Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case.","title":"Failure"},{"location":"parsers/followedby/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/followedby/#see-also","text":"followedByM label lookAhead notEmpty notFollowedBy","title":"See Also"},{"location":"parsers/followedbym/","text":"followedByM(p, msg) Applies a parser and succeeds without consuming input if that parser succeeds. This parser is similar to lookAhead except that it does not produce a result. If followedByM fails, it will add a expected(msg) as an error message. Example const parser = followedByM ( digit , 'a digit' ) const s = parse ( parser , '1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit Parameters p The parser to apply. If it succeeds, followedBy succeeds. msg The expected error message to use on failure. Success Succeeds if p succeeds. Does not consume input or return a result. Failure Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also followedBy lookAhead notEmptyM notFollowedByM","title":"followedByM"},{"location":"parsers/followedbym/#example","text":"const parser = followedByM ( digit , 'a digit' ) const s = parse ( parser , '1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit","title":"Example"},{"location":"parsers/followedbym/#parameters","text":"p The parser to apply. If it succeeds, followedBy succeeds. msg The expected error message to use on failure.","title":"Parameters"},{"location":"parsers/followedbym/#success","text":"Succeeds if p succeeds. Does not consume input or return a result.","title":"Success"},{"location":"parsers/followedbym/#failure","text":"Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case.","title":"Failure"},{"location":"parsers/followedbym/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/followedbym/#see-also","text":"followedBy lookAhead notEmptyM notFollowedByM","title":"See Also"},{"location":"parsers/fourth/","text":"fourth(p) Applies a parser and returns the fourth element of the resulting array. This parser works only if p returns an array, and it returns the fourth element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. fourth(p) is an optimized implementation of chain(p, x => always(x[3])) . Example const parser = fourth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the fourth element of the array that p returns. If there are not at least four elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth first nth second third","title":"fourth"},{"location":"parsers/fourth/#example","text":"const parser = fourth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/fourth/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/fourth/#success","text":"Succeeds if p succeeds. Returns the fourth element of the array that p returns. If there are not at least four elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/fourth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/fourth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/fourth/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/fourth/#see-also","text":"fifth first nth second third","title":"See Also"},{"location":"parsers/hex/","text":"hex Parses a hexadecimal digit ( 0-9 , a-f , or A-F ). Example const parser = hex const s = parse ( parser , 'cafe' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"c\" const f = parse ( parser , 'xyz' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // xyz // ^ // Expected a hexadecimal digit Success Succeeds if the next character is a hexadecimal digit ( 0-9 , a-f , or A-F ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also digit octal","title":"hex"},{"location":"parsers/hex/#example","text":"const parser = hex const s = parse ( parser , 'cafe' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"c\" const f = parse ( parser , 'xyz' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // xyz // ^ // Expected a hexadecimal digit","title":"Example"},{"location":"parsers/hex/#success","text":"Succeeds if the next character is a hexadecimal digit ( 0-9 , a-f , or A-F ). Consumes and returns that character.","title":"Success"},{"location":"parsers/hex/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/hex/#see-also","text":"digit octal","title":"See Also"},{"location":"parsers/join/","text":"join(p) Applies a parser and returns the elements of the resulting array into a string. This combinator solves the problem in JavaScript that there is no separate character type, and therefore a string is not just a list/array of characters. (Parsec parsers, for example, can return arrays of characters which Haskell regards also as strings in their own right.) Parsers like sequence and many return arrays, and often they are arrays of single-character strings. join will turn these results into simple strings. join(p) is an optimized implementation of chain(p, x => x.join('')) . Example const parser = join ( many1 ( any )) const s = parse ( parser , 'abcde' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"abcde\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character Parameters p The parser that is applied, which must return an array. Success Succeeds if p succeeds. Returns the resulting array's elements joined into a string. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also map","title":"join"},{"location":"parsers/join/#example","text":"const parser = join ( many1 ( any )) const s = parse ( parser , 'abcde' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"abcde\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character","title":"Example"},{"location":"parsers/join/#parameters","text":"p The parser that is applied, which must return an array.","title":"Parameters"},{"location":"parsers/join/#success","text":"Succeeds if p succeeds. Returns the resulting array's elements joined into a string.","title":"Success"},{"location":"parsers/join/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/join/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/join/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/join/#see-also","text":"map","title":"See Also"},{"location":"parsers/label/","text":"label(p, msg) Applies a parser and overwrites its error message on failure. label does nothing except pass the result along if its parser consumes any input (parsers/typically, but not always, if it succeeds or fails fatally). If it does not consume input, it replaces whatever error message was generated with expected(msg) . This is typically used to clarify error messages, especially in parsers like choice that might have many branches with their own error messages. For instance, if choice(upper, lower, digit.md) in the example below was not wrapped with label , its expected error message would be 'Expected an uppercase letter, a lowercase letter, or a digit' . label is used to consolidate that message into 'Expected an alphanumeric character' . Example const parser = label ( choice ( upper , lower , digit ), 'an alphanumeric character' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , ' abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an alphanumeric character Parameters p The parser to apply. If it does not consume any input, its error message will be changed. msg The error message for when p does not consume input. Success Succeeds if p succeeds. Returns the result of p . Failure Fails if p fails. In this case, the error message generated by p will be replaced with msg . Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also attemptM choice followedBy notEmpty notFollowedBy satisfy","title":"label"},{"location":"parsers/label/#example","text":"const parser = label ( choice ( upper , lower , digit ), 'an alphanumeric character' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , ' abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an alphanumeric character","title":"Example"},{"location":"parsers/label/#parameters","text":"p The parser to apply. If it does not consume any input, its error message will be changed. msg The error message for when p does not consume input.","title":"Parameters"},{"location":"parsers/label/#success","text":"Succeeds if p succeeds. Returns the result of p .","title":"Success"},{"location":"parsers/label/#failure","text":"Fails if p fails. In this case, the error message generated by p will be replaced with msg .","title":"Failure"},{"location":"parsers/label/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/label/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/label/#see-also","text":"attemptM choice followedBy notEmpty notFollowedBy satisfy","title":"See Also"},{"location":"parsers/left/","text":"left(p, q) Applies two parsers in order, returning the result of the first one. The result of the second parser is discarded. If either parser fails, then the entire left parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p or q failed fatally). There is another version of this parser ( leftB ) that will backtrack and fail non-fatally if p1 succeeds and p2 fails non-fatally. left(p, q) is an optimized implementation of chain(p, x => value(q, x)) . Example const parser = left ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fatal failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. Parameters p The first parser to apply. If both parsers succeed, this parser's result will be left 's result. q The second parser to apply. This parser's result will be discarded. Success Succeeds if both p and q succeed. Returns the result of p . Failure Fails if p fails. Fails if q fails after p succeeds but does not consume input. Fatal Failure Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeds and consumes some input. Throws Throws an error if either p or q are not parsers. See Also andThen leftB right sequence","title":"left"},{"location":"parsers/left/#example","text":"const parser = left ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fatal failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally.","title":"Example"},{"location":"parsers/left/#parameters","text":"p The first parser to apply. If both parsers succeed, this parser's result will be left 's result. q The second parser to apply. This parser's result will be discarded.","title":"Parameters"},{"location":"parsers/left/#success","text":"Succeeds if both p and q succeed. Returns the result of p .","title":"Success"},{"location":"parsers/left/#failure","text":"Fails if p fails. Fails if q fails after p succeeds but does not consume input.","title":"Failure"},{"location":"parsers/left/#fatal-failure","text":"Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/left/#throws","text":"Throws an error if either p or q are not parsers.","title":"Throws"},{"location":"parsers/left/#see-also","text":"andThen leftB right sequence","title":"See Also"},{"location":"parsers/leftb/","text":"leftB(p, q) Applies two parsers in order, returning the result of the first one. The result of the second parser is discarded. If either parser fails, then the entire leftB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p was applied. Example const parser = leftB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The first parser to apply. If both parsers succeed, this parser's result will be leftB 's result. q The second parser to apply. This parser's result will be discarded. Success Succeeds if both p and q succeed. Returns the result of p . Failure Fails if either p or q fail. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or q fail fatally. Throws Throws an error if either p or q are not parsers. See Also andThenB left rightB sequenceB","title":"leftB"},{"location":"parsers/leftb/#example","text":"const parser = leftB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/leftb/#parameters","text":"p The first parser to apply. If both parsers succeed, this parser's result will be leftB 's result. q The second parser to apply. This parser's result will be discarded.","title":"Parameters"},{"location":"parsers/leftb/#success","text":"Succeeds if both p and q succeed. Returns the result of p .","title":"Success"},{"location":"parsers/leftb/#failure","text":"Fails if either p or q fail. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/leftb/#fatal-failure","text":"Fails fatally if either p or q fail fatally.","title":"Fatal Failure"},{"location":"parsers/leftb/#throws","text":"Throws an error if either p or q are not parsers.","title":"Throws"},{"location":"parsers/leftb/#see-also","text":"andThenB left rightB sequenceB","title":"See Also"},{"location":"parsers/letter/","text":"letter Parses an ASCII letter ( a-z or A-Z ). This does not parse UTF-8 letters in general. Use letterU for that. Example const parser = letter const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Success Succeeds if the next character is an ASCII letter ( a-z or A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letterU lower upper","title":"letter"},{"location":"parsers/letter/#example","text":"const parser = letter const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter","title":"Example"},{"location":"parsers/letter/#success","text":"Succeeds if the next character is an ASCII letter ( a-z or A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/letter/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/letter/#see-also","text":"alpha letterU lower upper","title":"See Also"},{"location":"parsers/letteru/","text":"letterU Parses a Unicode letter. A character is a Unicode letter if it has the Unicode Alphabetic binary property. Example const parser = letterU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a Unicode letter Success Succeeds if the next character is a Unicode letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letter lowerU upperU","title":"letterU"},{"location":"parsers/letteru/#example","text":"const parser = letterU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a Unicode letter","title":"Example"},{"location":"parsers/letteru/#success","text":"Succeeds if the next character is a Unicode letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/letteru/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/letteru/#see-also","text":"alphaU letter lowerU upperU","title":"See Also"},{"location":"parsers/lookahead/","text":"lookAhead(p) Applies a parser and returns its result on success, but does not consume input. This parser allows for peeking ahead to see what characters are coming up without actually consuming those characters. It's common to see it in block parsers to drive logic that determines which parser gets applied based on the next character. lookAhead is very similar to optional . The difference is that optional consumes input on success where lookAhead does not. Example const parser = lookAhead ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(ok) console . log ( success ( f )) // null Parameters p The parser to apply without consuming input. If p succeeds, its result will be returned. Success Succeeds as long as p does not fail fatally. If p succeeds, its result is returned. If p fails, nothing is returned. In either case, no input is consumed. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also block optional","title":"lookAhead"},{"location":"parsers/lookahead/#example","text":"const parser = lookAhead ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(ok) console . log ( success ( f )) // null","title":"Example"},{"location":"parsers/lookahead/#parameters","text":"p The parser to apply without consuming input. If p succeeds, its result will be returned.","title":"Parameters"},{"location":"parsers/lookahead/#success","text":"Succeeds as long as p does not fail fatally. If p succeeds, its result is returned. If p fails, nothing is returned. In either case, no input is consumed.","title":"Success"},{"location":"parsers/lookahead/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/lookahead/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/lookahead/#see-also","text":"block optional","title":"See Also"},{"location":"parsers/lower/","text":"lower Parses an ASCII lowercase letter ( a-z ). This does not parse UTF-8 lowercase letters in general. Use lowerU for that. Example const parser = lower const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter Success Succeeds if the next character is an ASCII lowercase letter ( a-z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letter lowerU upper","title":"lower"},{"location":"parsers/lower/#example","text":"const parser = lower const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter","title":"Example"},{"location":"parsers/lower/#success","text":"Succeeds if the next character is an ASCII lowercase letter ( a-z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/lower/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/lower/#see-also","text":"alpha letter lowerU upper","title":"See Also"},{"location":"parsers/loweru/","text":"lowerU Parses a Unicode lowercase letter. A character is a Unicode lowercase letter if it has the Unicode Lowercase . This is approximately equal to characters that match the regular expression /\\p{Ll}/u but includes a few other characters as well. Example const parser = lowerU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0410\u0411\u0412 // ^ // Expected a Unicode lowercase letter Success Succeeds if the next character is a Unicode lowercase letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letterU lower upperU","title":"lowerU"},{"location":"parsers/loweru/#example","text":"const parser = lowerU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0410\u0411\u0412 // ^ // Expected a Unicode lowercase letter","title":"Example"},{"location":"parsers/loweru/#success","text":"Succeeds if the next character is a Unicode lowercase letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/loweru/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/loweru/#see-also","text":"alphaU letterU lower upperU","title":"See Also"},{"location":"parsers/many/","text":"many(p) Applies a parser as many times as possible until it fails, collecting the results into a resulting array. many executes a parser zero or more times, as long as it continues to succeed. The operation of the parser in EBNF is p* . When the parser fails, that does not mean that many fails; that signals that many is through executing and the successful results up to that point are returned. Example const parser = many ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\"] const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter The failure case in this example shows the only way that many can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes many to fail. many does not fail from non-fatal failures of its parser. Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p does not fail fatally. Returns the results that p had before failing in an array. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many1 skipMany","title":"many"},{"location":"parsers/many/#example","text":"const parser = many ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\"] const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter The failure case in this example shows the only way that many can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes many to fail. many does not fail from non-fatal failures of its parser.","title":"Example"},{"location":"parsers/many/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/many/#success","text":"Succeeds if p does not fail fatally. Returns the results that p had before failing in an array.","title":"Success"},{"location":"parsers/many/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/many/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/many/#see-also","text":"many1 skipMany","title":"See Also"},{"location":"parsers/many1/","text":"many1(p) Applies a parser as many times as possible until it fails, collecting the results into a resulting array. many1 executes a parser one or more times, as long as it continues to succeed. The operation of the parser in EBNF is p+ . When the parser fails, that does not mean that many1 fails (as long as the parser succeeded at least once); that signals that many1 is through executing and the successful results up to that point are returned. As long as p succeeds at least once, the only way many1 can fail is if p fails fatally. Example const parser = many1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\"] const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p succeeds at least once and does not fail fatally. Returns the results that p had before failing in an array. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many skipMany1","title":"many1"},{"location":"parsers/many1/#example","text":"const parser = many1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\"] const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter","title":"Example"},{"location":"parsers/many1/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/many1/#success","text":"Succeeds if p succeeds at least once and does not fail fatally. Returns the results that p had before failing in an array.","title":"Success"},{"location":"parsers/many1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/many1/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/many1/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/many1/#see-also","text":"many skipMany1","title":"See Also"},{"location":"parsers/manytill/","text":"manyTill(p, end) Applies a content parser zero or more times as long as an end parser continues to fail. Once the end parser succeeds, the content parser's successes are collected into an array and returned. This parser differs from between in that the end parser is applied first ; because of this, there is no possibility of content parser p consuming whatever end is supposed to match and thereby causing the combinator to fail. The operation of this parser in EBNF is (!end p)* end . Example const parser = manyTill ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter Parameters p The content parser. After end succeeds, the prior results of this parser are returned as an array. end The end parser. p will continue to be applied until end succeeds. Its result is discarded. Success Succeeds as long as end succeeds before p fails. Returns the results of p as an array. If end succeeds on the first attempt, p is never applied and the returned array is empty. Failure Fails if p and end both fail initially. Fails if p fails before end succeeds and prior successes from p did not consume any input. Fatal Failure Fails fatally if either p or end fail fatally. Fails fatally if p fails before end succeeds and prior successes from p consumed some input. Throws Throws an error if either p or end are not parsers. See Also between `manyTillB sequence","title":"manyTill"},{"location":"parsers/manytill/#example","text":"const parser = manyTill ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter","title":"Example"},{"location":"parsers/manytill/#parameters","text":"p The content parser. After end succeeds, the prior results of this parser are returned as an array. end The end parser. p will continue to be applied until end succeeds. Its result is discarded.","title":"Parameters"},{"location":"parsers/manytill/#success","text":"Succeeds as long as end succeeds before p fails. Returns the results of p as an array. If end succeeds on the first attempt, p is never applied and the returned array is empty.","title":"Success"},{"location":"parsers/manytill/#failure","text":"Fails if p and end both fail initially. Fails if p fails before end succeeds and prior successes from p did not consume any input.","title":"Failure"},{"location":"parsers/manytill/#fatal-failure","text":"Fails fatally if either p or end fail fatally. Fails fatally if p fails before end succeeds and prior successes from p consumed some input.","title":"Fatal Failure"},{"location":"parsers/manytill/#throws","text":"Throws an error if either p or end are not parsers.","title":"Throws"},{"location":"parsers/manytill/#see-also","text":"between `manyTillB sequence","title":"See Also"},{"location":"parsers/manytillb/","text":"manyTillB(p, end) Applies a content parser zero or more times as long as an end parser continues to fail. Once the end parser succeeds, the content parser's successes are collected into an array and returned. This parser differs from betweenB in that the end parser is applied first ; because of this, there is no possibility of content parser p consuming whatever end is supposed to match and thereby causing the combinator to fail. If p fails before end succeeds and input was consumed, the state will backtrack to where it was before p was applied the first time. Example const parser = manyTillB ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab12> // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter Parameters p The content parser. After end succeeds, the prior results of this parser are returned as an array. end The end parser. p will continue to be applied until end succeeds. Its result is discarded. Success Succeeds as long as end succeeds before p fails. Returns the results of p as an array. If end succeeds on the first attempt, p is never applied and the returned array is empty. Failure Fails if p fails before end succeeds. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or end fail fatally. Throws Throws an error if either p or end are not parsers. See Also betweenB manyTillB sequenceB","title":"manyTillB"},{"location":"parsers/manytillb/#example","text":"const parser = manyTillB ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab12> // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter","title":"Example"},{"location":"parsers/manytillb/#parameters","text":"p The content parser. After end succeeds, the prior results of this parser are returned as an array. end The end parser. p will continue to be applied until end succeeds. Its result is discarded.","title":"Parameters"},{"location":"parsers/manytillb/#success","text":"Succeeds as long as end succeeds before p fails. Returns the results of p as an array. If end succeeds on the first attempt, p is never applied and the returned array is empty.","title":"Success"},{"location":"parsers/manytillb/#failure","text":"Fails if p fails before end succeeds. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/manytillb/#fatal-failure","text":"Fails fatally if either p or end fail fatally.","title":"Fatal Failure"},{"location":"parsers/manytillb/#throws","text":"Throws an error if either p or end are not parsers.","title":"Throws"},{"location":"parsers/manytillb/#see-also","text":"betweenB manyTillB sequenceB","title":"See Also"},{"location":"parsers/map/","text":"map(p, fn) Applies a parser and returns the value that a function returns when passed the parser's result. fn can return anything, so map is one of the few combinators that can return something other than a string. map corresponds to fmap in Haskell (often simply map in other languages), which is a member of the Functor type class. It is often written <$> in languages that support custom operators. Example const parser = map ( lower , c => c . toUpperCase ()) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter In this example, a lower parser is used to read a lowercase letter. That character is passed into a function that uppercases it, then that uppercase letter is returned. Parameters p A parser to apply to the input. fn A function of one argument which gets passed the result of p . Its return value becomes map 's result. Success Succeeds if p succeeds. Returns the value that fn returns when passed the result of p . Failure Fails if p fails. In this case fn is never invoked. Fatal Failure Fails fatally if p fails fatally. In this case fn is never invoked. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. See Also chain join pipe","title":"map"},{"location":"parsers/map/#example","text":"const parser = map ( lower , c => c . toUpperCase ()) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter In this example, a lower parser is used to read a lowercase letter. That character is passed into a function that uppercases it, then that uppercase letter is returned.","title":"Example"},{"location":"parsers/map/#parameters","text":"p A parser to apply to the input. fn A function of one argument which gets passed the result of p . Its return value becomes map 's result.","title":"Parameters"},{"location":"parsers/map/#success","text":"Succeeds if p succeeds. Returns the value that fn returns when passed the result of p .","title":"Success"},{"location":"parsers/map/#failure","text":"Fails if p fails. In this case fn is never invoked.","title":"Failure"},{"location":"parsers/map/#fatal-failure","text":"Fails fatally if p fails fatally. In this case fn is never invoked.","title":"Fatal Failure"},{"location":"parsers/map/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function.","title":"Throws"},{"location":"parsers/map/#see-also","text":"chain join pipe","title":"See Also"},{"location":"parsers/newline/","text":"newline Parses an ASCII newline. ASCII newlines include \\r , \\n , and \\r\\n . Example const parser = newline const s = parse ( parser , '\\r\\nNext line' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\\r\\n\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a newline Success Succeeds if the next character is either \\r or \\n , or if the next two characters are \\r\\n . This character (or these characters) are consumed and returned as a single string. Failure Fails if the next character is any other character. See Also newlineU space spaces spaces1","title":"newline"},{"location":"parsers/newline/#example","text":"const parser = newline const s = parse ( parser , '\\r\\nNext line' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\\r\\n\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a newline","title":"Example"},{"location":"parsers/newline/#success","text":"Succeeds if the next character is either \\r or \\n , or if the next two characters are \\r\\n . This character (or these characters) are consumed and returned as a single string.","title":"Success"},{"location":"parsers/newline/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/newline/#see-also","text":"newlineU space spaces spaces1","title":"See Also"},{"location":"parsers/newlineu/","text":"newlineU Parses a Unicode newline. Unicode newlines include the ASCII newlines \\r , \\n , and \\r\\n , as well as the characters \"next line\" ( \\u0085 ), \"line separator\" ( \\u2028 ), and \"paragraph separator\" ( \\u2029 ). Example const parser = newlineU const s = parse ( parser , '\\u2028Next line' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\\u2028\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode newline Success Succeeds if the next character (or two characters, for \\r\\n ) is a Unicode newline. This character (or these characters) are consumed and returned as a single string. Failure Fails if the next character is any other character. See Also newline spacesU spaces1U spaceU","title":"newlineU"},{"location":"parsers/newlineu/#example","text":"const parser = newlineU const s = parse ( parser , '\\u2028Next line' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\\u2028\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode newline","title":"Example"},{"location":"parsers/newlineu/#success","text":"Succeeds if the next character (or two characters, for \\r\\n ) is a Unicode newline. This character (or these characters) are consumed and returned as a single string.","title":"Success"},{"location":"parsers/newlineu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/newlineu/#see-also","text":"newline spacesU spaces1U spaceU","title":"See Also"},{"location":"parsers/noneof/","text":"noneOf(cs) Parses a character if that character is not included in cs . Example const parser = noneOf ( 'Test' ) const s = parse ( parser , 'Exit' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"E\" const f = parse ( parser , 'Test' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Test // ^ // Expected none of 'T', 'e', 's', or 't' Parameters cs The set of characters that the next character is excluded from being a part of. This can be either a string or an array of single-character strings. Success Succeeds if the next character is not one of the characters in cs . Consumes and returns that character. Failure Fails if the next character is any character in cs . Throws Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length. See Also anyOf","title":"noneOf"},{"location":"parsers/noneof/#example","text":"const parser = noneOf ( 'Test' ) const s = parse ( parser , 'Exit' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"E\" const f = parse ( parser , 'Test' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Test // ^ // Expected none of 'T', 'e', 's', or 't'","title":"Example"},{"location":"parsers/noneof/#parameters","text":"cs The set of characters that the next character is excluded from being a part of. This can be either a string or an array of single-character strings.","title":"Parameters"},{"location":"parsers/noneof/#success","text":"Succeeds if the next character is not one of the characters in cs . Consumes and returns that character.","title":"Success"},{"location":"parsers/noneof/#failure","text":"Fails if the next character is any character in cs .","title":"Failure"},{"location":"parsers/noneof/#throws","text":"Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length.","title":"Throws"},{"location":"parsers/noneof/#see-also","text":"anyOf","title":"See Also"},{"location":"parsers/notempty/","text":"notEmpty(p) Applies a parser and succeeds if that parser succeeds and returns a result. If the parser does not return a result, notEmpty will fail. This parser cannot produce a useful error message. To provide a custom message, either wrap the parser with label or use notEmptyM . notEmpty can be used to require at least one match from a parser. For example, many1(p) could be naively implemented as notEmpty(many(p)) , though it would not have a good error message. Example const parser = notEmpty ( optional ( char ( '+' ))) const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Unknown error(s) Parameters p The parser to be applied. notEmpty fails if this p succeeds but produces no result. Success Succeeds if p succeeds and returns a result. That result is returned. Failure Fails if p fails. Fails if p succeeds but does not return a result. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also followedBy label notEmptyM notFollowedBy","title":"notEmpty"},{"location":"parsers/notempty/#example","text":"const parser = notEmpty ( optional ( char ( '+' ))) const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Unknown error(s)","title":"Example"},{"location":"parsers/notempty/#parameters","text":"p The parser to be applied. notEmpty fails if this p succeeds but produces no result.","title":"Parameters"},{"location":"parsers/notempty/#success","text":"Succeeds if p succeeds and returns a result. That result is returned.","title":"Success"},{"location":"parsers/notempty/#failure","text":"Fails if p fails. Fails if p succeeds but does not return a result.","title":"Failure"},{"location":"parsers/notempty/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/notempty/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/notempty/#see-also","text":"followedBy label notEmptyM notFollowedBy","title":"See Also"},{"location":"parsers/notemptym/","text":"notEmptyM(p, msg) Applies a parser and succeeds if that parser succeeds and returns a result. If the parser does not return a result, notEmpty will fail. If this parser fails, it will use expected(msg) as an error message. Example const parser = notEmpty ( optional ( char ( '+' )), 'something other than +' ) const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Expected something other than + Parameters p The parser to be applied. notEmpty fails if this p succeeds but produces no result. msg The expected error message to use on failure. Success Succeeds if p succeeds and returns a result. That result is returned. Failure Fails if p fails. Fails if p succeeds but does not return a result. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also followedByM notEmpty notFollowedByM","title":"notEmptyM"},{"location":"parsers/notemptym/#example","text":"const parser = notEmpty ( optional ( char ( '+' )), 'something other than +' ) const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Expected something other than +","title":"Example"},{"location":"parsers/notemptym/#parameters","text":"p The parser to be applied. notEmpty fails if this p succeeds but produces no result. msg The expected error message to use on failure.","title":"Parameters"},{"location":"parsers/notemptym/#success","text":"Succeeds if p succeeds and returns a result. That result is returned.","title":"Success"},{"location":"parsers/notemptym/#failure","text":"Fails if p fails. Fails if p succeeds but does not return a result.","title":"Failure"},{"location":"parsers/notemptym/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/notemptym/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/notemptym/#see-also","text":"followedByM notEmpty notFollowedByM","title":"See Also"},{"location":"parsers/notfollowedby/","text":"notFollowedBy(p) Applies a parser and succeeds without consuming input if that parser fails. notFollowedBy cannot feasibly produce an error message on failure. To add an error message, either wrap this parser in label or use notFollowedByM instead. Example const parser = notFollowedBy ( digit ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Unknown message(s) Parameters p The parser to apply. If it fails, notFollowedBy succeeds. Success Succeeds if p fails or fails fatally. Does not consume input or return a result. Failure Fails if p succeeds. No input is consumed and the state is not changed. Throws Throws an error if p is not a parser. See Also followedBy label notEmpty notFollowedByM","title":"notFollowedBy"},{"location":"parsers/notfollowedby/#example","text":"const parser = notFollowedBy ( digit ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Unknown message(s)","title":"Example"},{"location":"parsers/notfollowedby/#parameters","text":"p The parser to apply. If it fails, notFollowedBy succeeds.","title":"Parameters"},{"location":"parsers/notfollowedby/#success","text":"Succeeds if p fails or fails fatally. Does not consume input or return a result.","title":"Success"},{"location":"parsers/notfollowedby/#failure","text":"Fails if p succeeds. No input is consumed and the state is not changed.","title":"Failure"},{"location":"parsers/notfollowedby/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/notfollowedby/#see-also","text":"followedBy label notEmpty notFollowedByM","title":"See Also"},{"location":"parsers/notfollowedbym/","text":"notFollowedByM(p, msg) Applies a parser and succeeds without consuming input if that parser fails. If this parser fails, it will add expected(msg) as an error message. Example const parser = notFollowedByM ( digit , 'something other than a digit' ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Expected something other than a digit Parameters p The parser to apply. If it fails, notFollowedBy succeeds. msg The expected error message to use on failure. Success Succeeds if p fails or fails fatally. Does not consume input or return a result. Failure Fails if p succeeds. No input is consumed and the state is not changed. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also followedByM notEmptyM notFollowedBy","title":"notFollowedByM"},{"location":"parsers/notfollowedbym/#example","text":"const parser = notFollowedByM ( digit , 'something other than a digit' ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Expected something other than a digit","title":"Example"},{"location":"parsers/notfollowedbym/#parameters","text":"p The parser to apply. If it fails, notFollowedBy succeeds. msg The expected error message to use on failure.","title":"Parameters"},{"location":"parsers/notfollowedbym/#success","text":"Succeeds if p fails or fails fatally. Does not consume input or return a result.","title":"Success"},{"location":"parsers/notfollowedbym/#failure","text":"Fails if p succeeds. No input is consumed and the state is not changed.","title":"Failure"},{"location":"parsers/notfollowedbym/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/notfollowedbym/#see-also","text":"followedByM notEmptyM notFollowedBy","title":"See Also"},{"location":"parsers/nth/","text":"nth(p, n) Applies a parser and returns a given element of the resulting array. This parser works only if p returns an array, and it returns the n th (parsers/0-based) element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. nth(p, n) is an optimized implementation of chain(p, x => always(x[n])) . Example const parser = nth ( many1 ( any ), 3 ) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p The parser to apply. This parser should return an array. n The 0-based index of the element from p 's result that should be returned. Success Succeeds if p succeeds. Returns the element of the array that p returns with the index n . If there are not n + 1 elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if p succeeds but does not return an array. See Also fifth first fourth second third","title":"nth"},{"location":"parsers/nth/#example","text":"const parser = nth ( many1 ( any ), 3 ) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/nth/#parameters","text":"p The parser to apply. This parser should return an array. n The 0-based index of the element from p 's result that should be returned.","title":"Parameters"},{"location":"parsers/nth/#success","text":"Succeeds if p succeeds. Returns the element of the array that p returns with the index n . If there are not n + 1 elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/nth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/nth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/nth/#throws","text":"Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/nth/#see-also","text":"fifth first fourth second third","title":"See Also"},{"location":"parsers/octal/","text":"octal Parses an octal digit ( 0-7 ). Example const parser = octal const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '890' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 890 // ^ // Expected an octal digit Success Succeeds if the next character is an octal digit ( 0-7 ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also digit hex","title":"octal"},{"location":"parsers/octal/#example","text":"const parser = octal const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '890' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 890 // ^ // Expected an octal digit","title":"Example"},{"location":"parsers/octal/#success","text":"Succeeds if the next character is an octal digit ( 0-7 ). Consumes and returns that character.","title":"Success"},{"location":"parsers/octal/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/octal/#see-also","text":"digit hex","title":"See Also"},{"location":"parsers/optional/","text":"optional(p) Optionally matches a parser. If this parser succeeds, its result is returned. If it fails, null is returned. optional will only fail (fatally) if its parser fails fatally. A common use case is to skip some optional input; in this case, optional can be wrapped in skip , it can be placed in a position in another combinator where its output is ignored (such as left 's second parser.md), or its output can simply not be used. Example const parser = optional ( sequence ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const r = parse ( parser , '1' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // null const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The parser that gets applied. Success Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, optional still succeeds, but it returns nothing ( null ). Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also lookAhead orValue skip","title":"optional"},{"location":"parsers/optional/#example","text":"const parser = optional ( sequence ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const r = parse ( parser , '1' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // null const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/optional/#parameters","text":"p The parser that gets applied.","title":"Parameters"},{"location":"parsers/optional/#success","text":"Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, optional still succeeds, but it returns nothing ( null ).","title":"Success"},{"location":"parsers/optional/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/optional/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/optional/#see-also","text":"lookAhead orValue skip","title":"See Also"},{"location":"parsers/orelse/","text":"orElse(p, q) The primitive combinator for alternatives. orElse will apply its two parsers one after another until one of the two succeeds. If one of the two parsers fails fatally, orElse will stop at that point and fail fatally (i.e., if p fails fatally, q will never even be applied). If both parsers simply fail, orElse will also fail. Because of the requirement that failure not be fatal for this parser to continue (input can't be consumed by one parser and there be hope for the other parser to succeed from a different starting point), it isn't unusual to use backtracking parsers or attempt for either p or q . In parser packages in other languages that support custom operators, orElse is often implemented as an operator like <|> . In Haskell this is a member of the Alternative type class. Example const parser = orElse ( left ( letter , digit ), right ( digit , letter )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const r = parse ( parser , '1a' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"a\" const f = parse ( parser , ' a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Expected a letter or a digit const t = parse ( parser , 'a ' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit or a letter Parameters p The first parser to apply. q The second parser to apply. This parser will only be applied if p fails; if p either succeeds or fails fatally, there is no need to apply q to know what the result will be. Success Succeeds if both p and q succeed. Failure Fails if both p and q fail. Fatal Failure Fails fatally if either p or q fail fatally. Throws Throws an error if either p or q are not parsers. See Also andThen attempt choice empty","title":"orElse"},{"location":"parsers/orelse/#example","text":"const parser = orElse ( left ( letter , digit ), right ( digit , letter )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const r = parse ( parser , '1a' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"a\" const f = parse ( parser , ' a' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Expected a letter or a digit const t = parse ( parser , 'a ' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit or a letter","title":"Example"},{"location":"parsers/orelse/#parameters","text":"p The first parser to apply. q The second parser to apply. This parser will only be applied if p fails; if p either succeeds or fails fatally, there is no need to apply q to know what the result will be.","title":"Parameters"},{"location":"parsers/orelse/#success","text":"Succeeds if both p and q succeed.","title":"Success"},{"location":"parsers/orelse/#failure","text":"Fails if both p and q fail.","title":"Failure"},{"location":"parsers/orelse/#fatal-failure","text":"Fails fatally if either p or q fail fatally.","title":"Fatal Failure"},{"location":"parsers/orelse/#throws","text":"Throws an error if either p or q are not parsers.","title":"Throws"},{"location":"parsers/orelse/#see-also","text":"andThen attempt choice empty","title":"See Also"},{"location":"parsers/orvalue/","text":"orValue(p, x) Applies a parser and returns its result on success or an arbitrary value on failure. The only way orValue can fail is if its parser fails fatally. For this reason, a common use case is to wrap the parser in attempt to ensure that the default value is always returned on any kind of failure. Take care when doing this, as backtracking can erase important error information. x can be a value of any type, so this becomes one of the small number of combinators that can return results that are not strings or arrays of strings. Example const parser = orValue ( join ( sequence ( letter , digit )), 'Z0' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a1\" const r = parse ( parser , '12' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"Z0\" const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The parser that gets applied. If it succeeds, its result is returned. x An arbitrary value that is returned if p fails. Success Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, x is returned. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also attempt optional","title":"orValue"},{"location":"parsers/orvalue/#example","text":"const parser = orValue ( join ( sequence ( letter , digit )), 'Z0' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a1\" const r = parse ( parser , '12' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"Z0\" const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/orvalue/#parameters","text":"p The parser that gets applied. If it succeeds, its result is returned. x An arbitrary value that is returned if p fails.","title":"Parameters"},{"location":"parsers/orvalue/#success","text":"Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, x is returned.","title":"Success"},{"location":"parsers/orvalue/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/orvalue/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/orvalue/#see-also","text":"attempt optional","title":"See Also"},{"location":"parsers/pipe/","text":"pipe(...ps, fn) Applies some parsers in order, then returns the result of a function to which all of the parser results have been passed. fn will be passed one argument for every member of ps . JavaScript does not enforce that there has to be a parameter for each passed argument, but likely you will want to provide an fn that has an arity equal to the number of parsers in ps . Unlike sequence , null parser results are not discarded. This ensures that the same number of arguments will be passed to fn no matter the results of the parsers. There is another version of this parser ( pipeB ) that fails non-fatally and backtracks if the parser that fails does so non-fatally. fn can return anything, so this is one of the few combinators that can return something other than a string. pipe(p1, p2, fn) is an optimized implementation of chain(p1, a => chain(p2, b => always(fn(a, b)))) , pipe(p1, p2, p3, fn) is an optimized implementation of chain(p1, a => chain(p2, b => chain(p3, c => always(fn(a, b, c))))) , and so on. Example const parser = pipe ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter In this example, the upper and lower parsers are applied, and the results of each are passed to an arity-2 function which lowercases the first argument and uppercases the second. The first failure example ( f ) shows non-fatal failure caused by the first parser failing non-fatally, but the second ( t ) shows a fatal failure caused by a parser ( upper in this case) consuming a character before a later parser fails. Parameters ...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe . Success Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it. Failure Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the ones before it succeed but do not consume input. Fatal Failure Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after a prior parser succeeds and consumes some input. Throws Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser. See Also map pipeB","title":"pipe"},{"location":"parsers/pipe/#example","text":"const parser = pipe ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter In this example, the upper and lower parsers are applied, and the results of each are passed to an arity-2 function which lowercases the first argument and uppercases the second. The first failure example ( f ) shows non-fatal failure caused by the first parser failing non-fatally, but the second ( t ) shows a fatal failure caused by a parser ( upper in this case) consuming a character before a later parser fails.","title":"Example"},{"location":"parsers/pipe/#parameters","text":"...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe .","title":"Parameters"},{"location":"parsers/pipe/#success","text":"Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it.","title":"Success"},{"location":"parsers/pipe/#failure","text":"Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the ones before it succeed but do not consume input.","title":"Failure"},{"location":"parsers/pipe/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after a prior parser succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/pipe/#throws","text":"Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser.","title":"Throws"},{"location":"parsers/pipe/#see-also","text":"map pipeB","title":"See Also"},{"location":"parsers/pipeb/","text":"pipeB(...ps, fn) Applies some parsers in order, then returns the result of a function to which all of the parser results have been passed. fn will be passed one argument for every member of ps . JavaScript does not enforce that there has to be a parameter for each passed argument, but likely you will want to provide an fn that has an arity equal to the number of parsers in ps . If any of the parsers fail, then backtracking will return the state to where it was before the first parser was applied. fn can return anything, so this is one of the few combinators that can return something other than a string. Example const parser = pipeB ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ABC // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter See pipe for an explanation of this example. It's identical except for the final case failing fatally there and being backtracked and failing non-fatally here. Parameters ...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe . Success Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it. Failure Fails if the any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser. See Also pipe","title":"pipeB"},{"location":"parsers/pipeb/#example","text":"const parser = pipeB ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ABC // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter See pipe for an explanation of this example. It's identical except for the final case failing fatally there and being backtracked and failing non-fatally here.","title":"Example"},{"location":"parsers/pipeb/#parameters","text":"...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe .","title":"Parameters"},{"location":"parsers/pipeb/#success","text":"Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it.","title":"Success"},{"location":"parsers/pipeb/#failure","text":"Fails if the any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/pipeb/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/pipeb/#throws","text":"Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser.","title":"Throws"},{"location":"parsers/pipeb/#see-also","text":"pipe","title":"See Also"},{"location":"parsers/range/","text":"range(s, e) Parses a character between s and e (inclusive). \"Between\" is defined according to code points. This is fine in most cases, but it can get weird with higher code points. For example, there is no \"h\" in the set of mathematical lowercase italic symbols. The \"h\" that would be used in that set of symbols would instead be the Planck's Constant character, which is in a completely different part of the UTF-8 spectrum and therefore is not \"between\" mathematical lowercase italic symbols a and z . Take care with non-ASCII characters. Example const parser = range ( '0' , '3' ) const s = parse ( parser , '246' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"2\" const f = parse ( parser , '468' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 468 // ^ // Expected a character between '0' and '3' Parameters s The character representing the lower bound of the range. The next character's code point must be greater than or equal to s 's code point for the parser to succeed. e The character representing the upper bound of the range. The next character's code point must be less than or equal to e 's code point for the parser to succeed. Success Succeeds if the code point of the next character is between the code points of s and e , inclusive. Consumes and returns that character. Failure Fails if the code point of the next character is less than s 's code point or greater than e 's code point. Throws Throws an error if either s or e are not strings or if either is not exactly one character in length. See Also any char regex satisfy","title":"range"},{"location":"parsers/range/#example","text":"const parser = range ( '0' , '3' ) const s = parse ( parser , '246' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"2\" const f = parse ( parser , '468' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 468 // ^ // Expected a character between '0' and '3'","title":"Example"},{"location":"parsers/range/#parameters","text":"s The character representing the lower bound of the range. The next character's code point must be greater than or equal to s 's code point for the parser to succeed. e The character representing the upper bound of the range. The next character's code point must be less than or equal to e 's code point for the parser to succeed.","title":"Parameters"},{"location":"parsers/range/#success","text":"Succeeds if the code point of the next character is between the code points of s and e , inclusive. Consumes and returns that character.","title":"Success"},{"location":"parsers/range/#failure","text":"Fails if the code point of the next character is less than s 's code point or greater than e 's code point.","title":"Failure"},{"location":"parsers/range/#throws","text":"Throws an error if either s or e are not strings or if either is not exactly one character in length.","title":"Throws"},{"location":"parsers/range/#see-also","text":"any char regex satisfy","title":"See Also"},{"location":"parsers/regex/","text":"regex(pattern) Matches the current input location against a regular expression pattern. Example const parser = regex ( /^\\d+/ ) const s = parse ( parser , '123abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"123\" const f = parse ( parser , 'abc123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc123 // ^ // Expected a string matching /^\\d+/ Parameters pattern The regular expression pattern to match against the current input location. This pattern can be either a RegExp object or a string (which is automatically converted into a RegExp object without flags). It will have an ^ anchor added to it if it doesn't already have one; all regex matches are done against the beginning of the input (based on its current state). No flags are removed, but the g flag is ignored because there can be only one match because of the ^ anchor. Success Succeeds if a match occurs at the current location of the input. The full match is returned as a single string, and that many characters are consumed. It is possible for this match to be zero characters long in the case where a * quantifier is used in the pattern. Failure Fails if there is no match at the current location of the input. Note that some patterns cannot fail; a pattern with a * quantifier, for example, can successfully match on zero characters. Throws Throws an error if pattern is neither a RegExp object or a string. Throws an error if pattern is a string and cannot be converted into a RegExp object because it is not a valid regular expression pattern. See Also satisfy string","title":"regex"},{"location":"parsers/regex/#example","text":"const parser = regex ( /^\\d+/ ) const s = parse ( parser , '123abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"123\" const f = parse ( parser , 'abc123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc123 // ^ // Expected a string matching /^\\d+/","title":"Example"},{"location":"parsers/regex/#parameters","text":"pattern The regular expression pattern to match against the current input location. This pattern can be either a RegExp object or a string (which is automatically converted into a RegExp object without flags). It will have an ^ anchor added to it if it doesn't already have one; all regex matches are done against the beginning of the input (based on its current state). No flags are removed, but the g flag is ignored because there can be only one match because of the ^ anchor.","title":"Parameters"},{"location":"parsers/regex/#success","text":"Succeeds if a match occurs at the current location of the input. The full match is returned as a single string, and that many characters are consumed. It is possible for this match to be zero characters long in the case where a * quantifier is used in the pattern.","title":"Success"},{"location":"parsers/regex/#failure","text":"Fails if there is no match at the current location of the input. Note that some patterns cannot fail; a pattern with a * quantifier, for example, can successfully match on zero characters.","title":"Failure"},{"location":"parsers/regex/#throws","text":"Throws an error if pattern is neither a RegExp object or a string. Throws an error if pattern is a string and cannot be converted into a RegExp object because it is not a valid regular expression pattern.","title":"Throws"},{"location":"parsers/regex/#see-also","text":"satisfy string","title":"See Also"},{"location":"parsers/repeat/","text":"repeat(p, n) Applies a parser a certain number of times, collecting the results into an array to return. The parser p must succeed the full n times for repeat to succeed. Any fewer successes results in failure. As with other combinators that run multiple parsers, it's possible for repeat to fail fatally even if the parser that failed did not fail fatally (because, for example, an earlier success consumed some input). There is another version of this parser, repeatB , that will backtrack and fail non-fatally when this happens. Example const parser = repeat ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter Parameters p The parser to apply. Its results are returned in an array. n The number of times that p is applied. Success Succeeds if p succeeds n times. The results are collected into an array and returned. Failure Fails if p does not succeed at least once. Fails if p succeeds at least once but not n times and if the prior successes of do not consume any input. Fatal Failre Fails fatally if p fails fatally. Fails fatally if p does not succeed n times and if prior successes consume some input. See Also optional repeatB sequence","title":"repeat"},{"location":"parsers/repeat/#example","text":"const parser = repeat ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter","title":"Example"},{"location":"parsers/repeat/#parameters","text":"p The parser to apply. Its results are returned in an array. n The number of times that p is applied.","title":"Parameters"},{"location":"parsers/repeat/#success","text":"Succeeds if p succeeds n times. The results are collected into an array and returned.","title":"Success"},{"location":"parsers/repeat/#failure","text":"Fails if p does not succeed at least once. Fails if p succeeds at least once but not n times and if the prior successes of do not consume any input.","title":"Failure"},{"location":"parsers/repeat/#fatal-failre","text":"Fails fatally if p fails fatally. Fails fatally if p does not succeed n times and if prior successes consume some input.","title":"Fatal Failre"},{"location":"parsers/repeat/#see-also","text":"optional repeatB sequence","title":"See Also"},{"location":"parsers/repeatb/","text":"repeatB(p, n) Applies a parser a certain number of times, collecting the results into an array to return. The parser p must succeed the full n times for repeatB to succeed. Any fewer successes results in failure. Any input that is consumed in the process will be backtracked. Example const parser = repeatB ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab3 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter Parameters p The parser to apply. Its results are returned in an array. n The number of times that p is applied. Success Succeeds if p succeeds n times. The results are collected into an array and returned. Failure Fails if p fails before it has succeeded n times. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failre Fails fatally if p fails fatally before it has succeeded n times. See Also repeat sequenceB","title":"repeatB"},{"location":"parsers/repeatb/#example","text":"const parser = repeatB ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab3 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter","title":"Example"},{"location":"parsers/repeatb/#parameters","text":"p The parser to apply. Its results are returned in an array. n The number of times that p is applied.","title":"Parameters"},{"location":"parsers/repeatb/#success","text":"Succeeds if p succeeds n times. The results are collected into an array and returned.","title":"Success"},{"location":"parsers/repeatb/#failure","text":"Fails if p fails before it has succeeded n times. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/repeatb/#fatal-failre","text":"Fails fatally if p fails fatally before it has succeeded n times.","title":"Fatal Failre"},{"location":"parsers/repeatb/#see-also","text":"repeat sequenceB","title":"See Also"},{"location":"parsers/right/","text":"right(p, q) Applies two parsers in order, returning the result of the second one. The result of the first parser is discarded. If either parser fails, then the entire right parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p or q failed fatally). There is another version of this parser ( rightB ) that will backtrack and fail non-fatally if p succeeds and q fails non-fatally. right(p, q) is an optimized implementation of chain(p, () => q) . Example const parser = right ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. Parameters p The first parser to apply. This parser's result will be discarded. q The second parser to apply. If both parsers succeed, this parser's result will be right 's result. Success Succeeds if both p and q succeed. Returns the result of q . Failure Fails if p fails. Fails if q fails after p succeeds but does not consume any input. Fatal Failure Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeeds and consumes some input. Throws Throws an error if either p or q are not parsers. See Also andThen left rightB sequence","title":"right"},{"location":"parsers/right/#example","text":"const parser = right ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally.","title":"Example"},{"location":"parsers/right/#parameters","text":"p The first parser to apply. This parser's result will be discarded. q The second parser to apply. If both parsers succeed, this parser's result will be right 's result.","title":"Parameters"},{"location":"parsers/right/#success","text":"Succeeds if both p and q succeed. Returns the result of q .","title":"Success"},{"location":"parsers/right/#failure","text":"Fails if p fails. Fails if q fails after p succeeds but does not consume any input.","title":"Failure"},{"location":"parsers/right/#fatal-failure","text":"Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/right/#throws","text":"Throws an error if either p or q are not parsers.","title":"Throws"},{"location":"parsers/right/#see-also","text":"andThen left rightB sequence","title":"See Also"},{"location":"parsers/rightb/","text":"rightB(p, q) Applies two parsers in order, returning the result of the second one. The result of the first parser is discarded. If either parser fails, then the entire rightB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p was applied. Example const parser = rightB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p The first parser to apply. This parser's result will be discarded. q The second parser to apply. If both parsers succeed, this parser's result will be rightB 's result. Success Succeeds if both p and q succeed. Returns the result of q . Failure Fails if either p or q fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or q fail fatally. Throws Throws an error if either p or q are not parsers. See Also andThenB leftB right sequenceB","title":"rightB"},{"location":"parsers/rightb/#example","text":"const parser = rightB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/rightb/#parameters","text":"p The first parser to apply. This parser's result will be discarded. q The second parser to apply. If both parsers succeed, this parser's result will be rightB 's result.","title":"Parameters"},{"location":"parsers/rightb/#success","text":"Succeeds if both p and q succeed. Returns the result of q .","title":"Success"},{"location":"parsers/rightb/#failure","text":"Fails if either p or q fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/rightb/#fatal-failure","text":"Fails fatally if either p or q fail fatally.","title":"Fatal Failure"},{"location":"parsers/rightb/#throws","text":"Throws an error if either p or q are not parsers.","title":"Throws"},{"location":"parsers/rightb/#see-also","text":"andThenB leftB right sequenceB","title":"See Also"},{"location":"parsers/satisfy/","text":"satisfy(fn) Parses a character for which the predicate fn returns true when passed that character. Since the parser cannot reasonably figure out what conditions cause fn to pass, it does not generate an error message on failure. To provide an error message, either wrap the parser with label or use satisfyM . Example const parser = satisfy ( x => x === x . toUpperCase ()) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Unknown error(s) Parameters fn The predicate function that the next character must pass in order for the parser to succeed. Success Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character. Failure Fails if fn returns false when the next character is passed into it. Throws Throws an error if fn is not a non-parser function. See Also label range regex satisfyM","title":"satisfy"},{"location":"parsers/satisfy/#example","text":"const parser = satisfy ( x => x === x . toUpperCase ()) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Unknown error(s)","title":"Example"},{"location":"parsers/satisfy/#parameters","text":"fn The predicate function that the next character must pass in order for the parser to succeed.","title":"Parameters"},{"location":"parsers/satisfy/#success","text":"Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character.","title":"Success"},{"location":"parsers/satisfy/#failure","text":"Fails if fn returns false when the next character is passed into it.","title":"Failure"},{"location":"parsers/satisfy/#throws","text":"Throws an error if fn is not a non-parser function.","title":"Throws"},{"location":"parsers/satisfy/#see-also","text":"label range regex satisfyM","title":"See Also"},{"location":"parsers/satisfym/","text":"satisfyM(fn, msg) Parses a character for which predicate fn returns true when passed that character. If the parser fails, msg is used as the expected error message. Example const parser = satisfyM ( x => x === x . toUpperCase (), 'an uppercase letter' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter Parameters fn The predicate function that the next character must pass in order for the parser to succeed. msg The text of the error message generated if the parser fails. Success Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character. Failure Fails if fn returns false when the next character is passed into it. If this happens, expected(msg) is used as the error message. Throws Throws an error if fn is not a non-parser function. Throws an error if str is not a string. See Also label satisfy","title":"satisfyM"},{"location":"parsers/satisfym/#example","text":"const parser = satisfyM ( x => x === x . toUpperCase (), 'an uppercase letter' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter","title":"Example"},{"location":"parsers/satisfym/#parameters","text":"fn The predicate function that the next character must pass in order for the parser to succeed. msg The text of the error message generated if the parser fails.","title":"Parameters"},{"location":"parsers/satisfym/#success","text":"Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character.","title":"Success"},{"location":"parsers/satisfym/#failure","text":"Fails if fn returns false when the next character is passed into it. If this happens, expected(msg) is used as the error message.","title":"Failure"},{"location":"parsers/satisfym/#throws","text":"Throws an error if fn is not a non-parser function. Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/satisfym/#see-also","text":"label satisfy","title":"See Also"},{"location":"parsers/second/","text":"second(p) Applies a parser and returns the second element of the resulting array. This parser works only if p returns an array, and it returns the second element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. second(p) is an optimized implementation of chain(p, x => always(x[1])) . Example const parser = second ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"2\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the second element of the array that p returns. If there are not at least two elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth first fourth nth third","title":"second"},{"location":"parsers/second/#example","text":"const parser = second ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"2\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/second/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/second/#success","text":"Succeeds if p succeeds. Returns the second element of the array that p returns. If there are not at least two elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/second/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/second/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/second/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/second/#see-also","text":"fifth first fourth nth third","title":"See Also"},{"location":"parsers/sepby/","text":"sepBy(p, sep) Parses zero or more occurrences of a content parser, separated by a separator parser. sepBy applies the content parser p zero or more times as long as both it and the preceding separator parser sep match. The operation of the parser in EBNF is (p (sep p)*)? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser must be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the content parser (i.e., at the beginning of the text matched by the separator parser). Example const parser = sepBy ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded. Success Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or sep are not parsers. See Also sepBy1 sepEndBy","title":"sepBy"},{"location":"parsers/sepby/#example","text":"const parser = sepBy ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sepby/#parameters","text":"p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sepby/#success","text":"Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result.","title":"Success"},{"location":"parsers/sepby/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sepby/#throws","text":"Throws an error if either p or sep are not parsers.","title":"Throws"},{"location":"parsers/sepby/#see-also","text":"sepBy1 sepEndBy","title":"See Also"},{"location":"parsers/sepby1/","text":"sepBy1(p, sep) Parses one or more occurrences of a content parser, separated by a separator parser. sepBy1 applies the content parser p one or more times as long as both it and the preceding separator parser sep match. The operation of the parser in EBNF is p (sep p)* . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser must be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the content parser (i.e., at the beginning of the text matched by the separator parser). Example const parser = sepBy1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded. Success Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or sep are not parsers. See Also sepBy sepEndBy1","title":"sepBy1"},{"location":"parsers/sepby1/#example","text":"const parser = sepBy1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sepby1/#parameters","text":"p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sepby1/#success","text":"Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned.","title":"Success"},{"location":"parsers/sepby1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/sepby1/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sepby1/#throws","text":"Throws an error if either p or sep are not parsers.","title":"Throws"},{"location":"parsers/sepby1/#see-also","text":"sepBy sepEndBy1","title":"See Also"},{"location":"parsers/sependby/","text":"sepEndBy(p, sep) Parses zero or more occurrences of a content parser, separated and optionally ended by a separator parser. sepEndBy applies the content parser p zero or more times as long as both it and the preceding separator parser sep match. The operation of the parser in EBNF is (p (sep p)* sep?)? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser need not be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the separator parser. Example const parser = sepEndBy ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded. Success Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or sep are not parsers. See Also sepBy sepEndBy1","title":"sepEndBy"},{"location":"parsers/sependby/#example","text":"const parser = sepEndBy ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sependby/#parameters","text":"p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sependby/#success","text":"Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result.","title":"Success"},{"location":"parsers/sependby/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sependby/#throws","text":"Throws an error if either p or sep are not parsers.","title":"Throws"},{"location":"parsers/sependby/#see-also","text":"sepBy sepEndBy1","title":"See Also"},{"location":"parsers/sependby1/","text":"sepEndBy1(p, sep) Parses one or more occurrences of a content parser, separated and optionally ended by a separator parser. sepEndBy1 applies the content parser p one or more times as long as both it and the preceding separator parser sep match. The operation of the parser in EBNF is p (sep p)* sep? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser need not be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the separator parser. Example const parser = sepEndBy1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111,' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded. Success Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or sep are not parsers. See Also sepBy1 sepEndBy","title":"sepEndBy1"},{"location":"parsers/sependby1/#example","text":"const parser = sepEndBy1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111,' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sependby1/#parameters","text":"p The content parser. The results of this parser are returned in an array. sep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sependby1/#success","text":"Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned.","title":"Success"},{"location":"parsers/sependby1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/sependby1/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sependby1/#throws","text":"Throws an error if either p or sep are not parsers.","title":"Throws"},{"location":"parsers/sependby1/#see-also","text":"sepBy1 sepEndBy","title":"See Also"},{"location":"parsers/sequence/","text":"sequence(...ps) Applies a series of parsers in order, returning an array that contains each parser's result. sequence will only succeed if all of its parsers succeed. If one of them fails, sequence will fail fatally if it had consumed any input up to that point, even if the parser that failed did so non-fatally. There is another version of this parser ( sequenceB ) that fails non-fatally and backtracks if the parser that fails does so non-fatally. All of the results are gathered into an array, but null results are skipped. A two-parser sequence is the same as andThen . Example const parser = sequence ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter Parameters ...ps A series of parsers to apply to the input, one at a time, in order. Success Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array. Failure Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the prior parsers succeed but do not consume any input. Fatal Failure Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after any prior parser succeeds and consumes some input. Throws Throws an error if any member of ps is not a parser. See Also andThen block left right sequenceB","title":"sequence"},{"location":"parsers/sequence/#example","text":"const parser = sequence ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sequence/#parameters","text":"...ps A series of parsers to apply to the input, one at a time, in order.","title":"Parameters"},{"location":"parsers/sequence/#success","text":"Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array.","title":"Success"},{"location":"parsers/sequence/#failure","text":"Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the prior parsers succeed but do not consume any input.","title":"Failure"},{"location":"parsers/sequence/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after any prior parser succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/sequence/#throws","text":"Throws an error if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/sequence/#see-also","text":"andThen block left right sequenceB","title":"See Also"},{"location":"parsers/sequenceb/","text":"sequenceB(...ps) Applies a series of parsers in order, returning an array that contains each parser's result. sequenceB will only succeed if all of its parsers succeed. If one of them fails, sequenceB will also fail. If input was consumed before the failure occurred, sequenceB will backtrack to the location where its first parser was applied. All of the results are gathered into an array, but null results are skipped. A two-parser sequenceB is the same as andThenB . Example const parser = sequenceB ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a11 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter Parameters ...ps A series of parsers to apply to the input, one at a time, in order. Success Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array. Failure Fails if any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws an error if any member of ps is not a parser. See Also andThenB blockB leftB rightB sequence","title":"sequenceB"},{"location":"parsers/sequenceb/#example","text":"const parser = sequenceB ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // Symbol(fail) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a11 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sequenceb/#parameters","text":"...ps A series of parsers to apply to the input, one at a time, in order.","title":"Parameters"},{"location":"parsers/sequenceb/#success","text":"Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array.","title":"Success"},{"location":"parsers/sequenceb/#failure","text":"Fails if any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/sequenceb/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/sequenceb/#throws","text":"Throws an error if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/sequenceb/#see-also","text":"andThenB blockB leftB rightB sequence","title":"See Also"},{"location":"parsers/skip/","text":"skip(p) Applies a parser and discards its result on success. A good use for this parser is to null results in a sequence or many parser, as those exclude results that are null from their final results. skip(p) is an optimized implementation of chain(p, () => always(null)) . Example const parser = skip ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Parameters p The parser to apply to the input. Success Succeeds if p succeeds. Discards the result and returns null . Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also optional skipMany skipMany1","title":"skip"},{"location":"parsers/skip/#example","text":"const parser = skip ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter","title":"Example"},{"location":"parsers/skip/#parameters","text":"p The parser to apply to the input.","title":"Parameters"},{"location":"parsers/skip/#success","text":"Succeeds if p succeeds. Discards the result and returns null .","title":"Success"},{"location":"parsers/skip/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/skip/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/skip/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/skip/#see-also","text":"optional skipMany skipMany1","title":"See Also"},{"location":"parsers/skipmany/","text":"skipMany(p) Applies a parser as many times as possible until it fails, discarding all of the parser's results. skipMany executes a parser zero or more times, as long as it continues to succeed. When the parser fails, that does not mean that skipMany fails; that signals that skipMany is through executing. Example const parser = skipMany ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter The failure case in this example shows the only way that skipMany can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes skipMany to fail. skipMany does not fail from non-fatal failures of its parser. Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p does not fail fatally. Discards all results. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many skipMany1","title":"skipMany"},{"location":"parsers/skipmany/#example","text":"const parser = skipMany ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter The failure case in this example shows the only way that skipMany can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes skipMany to fail. skipMany does not fail from non-fatal failures of its parser.","title":"Example"},{"location":"parsers/skipmany/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/skipmany/#success","text":"Succeeds if p does not fail fatally. Discards all results.","title":"Success"},{"location":"parsers/skipmany/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/skipmany/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/skipmany/#see-also","text":"many skipMany1","title":"See Also"},{"location":"parsers/skipmany1/","text":"skipMany1(p) Applies a parser as many times as possible until it fails, discarding the parser's results. skipMany1 executes a parser one or more times, as long as it continues to succeed. When the parser fails, that does not mean that skipMany1 fails (as long as the parser succeeded at least once); that signals that skipMany1 is through executing. As long as p succeeds at least once, the only way skipMany1 can fail is if p fails fatally. Example const parser = skipMany1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p succeeds at least once and does not fail fatally. Discards all results. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many1 skipMany","title":"skipMany1"},{"location":"parsers/skipmany1/#example","text":"const parser = skipMany1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter","title":"Example"},{"location":"parsers/skipmany1/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/skipmany1/#success","text":"Succeeds if p succeeds at least once and does not fail fatally. Discards all results.","title":"Success"},{"location":"parsers/skipmany1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/skipmany1/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/skipmany1/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/skipmany1/#see-also","text":"many1 skipMany","title":"See Also"},{"location":"parsers/space/","text":"space Parses an ASCII whitespace character. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Example const parser = space const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a whitespace character Success Succeeds if the next character is an ASCII whitespace character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also newline spaces spaces1 spaceU","title":"space"},{"location":"parsers/space/#example","text":"const parser = space const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a whitespace character","title":"Example"},{"location":"parsers/space/#success","text":"Succeeds if the next character is an ASCII whitespace character. Consumes and returns that character.","title":"Success"},{"location":"parsers/space/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/space/#see-also","text":"newline spaces spaces1 spaceU","title":"See Also"},{"location":"parsers/spaces/","text":"spaces Parses zero or more ASCII whitespace characters and discards them. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Example const parser = spaces const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null Success Always succeeds. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded. See Also newline space spaces1 spacesU","title":"spaces"},{"location":"parsers/spaces/#example","text":"const parser = spaces const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null","title":"Example"},{"location":"parsers/spaces/#success","text":"Always succeeds. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces/#see-also","text":"newline space spaces1 spacesU","title":"See Also"},{"location":"parsers/spaces1/","text":"spaces1 Parses one or more ASCII whitespace characters and discards them. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Example const parser = spaces1 const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more whitespace characters Success Succeeds if at least one ASCII whitespace character is read. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded. Failure Fails if the next character is not an ASCII whitespace character. See Also newline space spaces spaces1U","title":"spaces1"},{"location":"parsers/spaces1/#example","text":"const parser = spaces1 const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more whitespace characters","title":"Example"},{"location":"parsers/spaces1/#success","text":"Succeeds if at least one ASCII whitespace character is read. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces1/#failure","text":"Fails if the next character is not an ASCII whitespace character.","title":"Failure"},{"location":"parsers/spaces1/#see-also","text":"newline space spaces spaces1U","title":"See Also"},{"location":"parsers/spaces1u/","text":"spaces1U Parses one or more Unicode whitespace characters and discards them. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Example const parser = spaces1U const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more Unicode whitespace characters Success Succeeds if at least one Unicode whitespace character is read. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded. Failure Fails if the next character is not a Unicode whitespace character. See Also newlineU spaces1 spacesU spaceU","title":"spaces1U"},{"location":"parsers/spaces1u/#example","text":"const parser = spaces1U const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more Unicode whitespace characters","title":"Example"},{"location":"parsers/spaces1u/#success","text":"Succeeds if at least one Unicode whitespace character is read. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces1u/#failure","text":"Fails if the next character is not a Unicode whitespace character.","title":"Failure"},{"location":"parsers/spaces1u/#see-also","text":"newlineU spaces1 spacesU spaceU","title":"See Also"},{"location":"parsers/spacesu/","text":"spacesU Parses zero or more Unicode whitespace characters and discards them. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Example const parser = spacesU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null Success Always succeeds. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded. See Also newlineU spaces spaces1U spaceU","title":"spacesU"},{"location":"parsers/spacesu/#example","text":"const parser = spacesU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null","title":"Example"},{"location":"parsers/spacesu/#success","text":"Always succeeds. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spacesu/#see-also","text":"newlineU spaces spaces1U spaceU","title":"See Also"},{"location":"parsers/spaceu/","text":"spaceU Parse a Unicode whitespace character. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Example const parser = spaceU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode whitespace character Success Succeeds if the next character is a Unicode whitespace character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also newlineU space spaces1U spacesU","title":"spaceU"},{"location":"parsers/spaceu/#example","text":"const parser = spaceU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode whitespace character","title":"Example"},{"location":"parsers/spaceu/#success","text":"Succeeds if the next character is a Unicode whitespace character. Consumes and returns that character.","title":"Success"},{"location":"parsers/spaceu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/spaceu/#see-also","text":"newlineU space spaces1U spacesU","title":"See Also"},{"location":"parsers/string/","text":"string(str) Parses the string str . The number of characters read equals the number of characters in str . If there are not that many characters remaining in the input, the parser will automatically fail. If str is the empty string, the parser will automatically succeed and consume no input. Example const parser = string ( 'Test' ) const s = parse ( parser , 'Testing' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"Test\" const f = parse ( parser , 'test' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test // ^ // Expected 'Test' Parameters str The string to match against the input at its current location. Success Succeeds if the first n characters of the input at its current location is the same as str , where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input. Failure Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str . Throws Throws an error if str is not a string. See Also char regex stringI","title":"string"},{"location":"parsers/string/#example","text":"const parser = string ( 'Test' ) const s = parse ( parser , 'Testing' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"Test\" const f = parse ( parser , 'test' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test // ^ // Expected 'Test'","title":"Example"},{"location":"parsers/string/#parameters","text":"str The string to match against the input at its current location.","title":"Parameters"},{"location":"parsers/string/#success","text":"Succeeds if the first n characters of the input at its current location is the same as str , where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input.","title":"Success"},{"location":"parsers/string/#failure","text":"Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str .","title":"Failure"},{"location":"parsers/string/#throws","text":"Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/string/#see-also","text":"char regex stringI","title":"See Also"},{"location":"parsers/stringi/","text":"stringI(str) Parses the string str case-insensitively. The number of characters read equals the number of characters in str . If there are not that many characters remaining in the input, the parser will automatically fail. If str is the empty string, the parser will automatically succeed and consume no input. Example const parser = stringI ( 'Test' ) const s = parse ( parser , 'testing' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'oops' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // oops // ^ // Expected 'Test' Parameters str The string to case-insensitively match against the input at its current location. Success Succeeds if the first n characters of the input at its current location is the same as str (case-insensitive), where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input. Failure Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str case-insensitively. Throws Throws an error if str is not a string. See Also charI regex string","title":"stringI"},{"location":"parsers/stringi/#example","text":"const parser = stringI ( 'Test' ) const s = parse ( parser , 'testing' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'oops' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // oops // ^ // Expected 'Test'","title":"Example"},{"location":"parsers/stringi/#parameters","text":"str The string to case-insensitively match against the input at its current location.","title":"Parameters"},{"location":"parsers/stringi/#success","text":"Succeeds if the first n characters of the input at its current location is the same as str (case-insensitive), where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input.","title":"Success"},{"location":"parsers/stringi/#failure","text":"Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str case-insensitively.","title":"Failure"},{"location":"parsers/stringi/#throws","text":"Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/stringi/#see-also","text":"charI regex string","title":"See Also"},{"location":"parsers/third/","text":"third(p) Applies a parser and returns the third element of the resulting array. This parser works only if p returns an array, and it returns the third element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. third(p) is an optimized implementation of chain(p, x => always(x[2])) . Example const parser = third ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"3\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the third element of the array that p returns. If there are not at least three elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth first fourth nth second","title":"third"},{"location":"parsers/third/#example","text":"const parser = third ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"3\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/third/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/third/#success","text":"Succeeds if p succeeds. Returns the third element of the array that p returns. If there are not at least three elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/third/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/third/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/third/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/third/#see-also","text":"fifth first fourth nth second","title":"See Also"},{"location":"parsers/upper/","text":"upper Parses an ASCII uppercase letter ( A-Z ). This does not parse UTF-8 uppercase letters in general. Use upperU for that. Example const parser = upper const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter Success Succeeds if the next character is an ASCII uppercase letter ( A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letter lower upperU","title":"upper"},{"location":"parsers/upper/#example","text":"const parser = upper const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter","title":"Example"},{"location":"parsers/upper/#success","text":"Succeeds if the next character is an ASCII uppercase letter ( A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/upper/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/upper/#see-also","text":"alpha letter lower upperU","title":"See Also"},{"location":"parsers/upperu/","text":"upperU Parses either a Unicode uppercase letter or a Unicode titlecase character. A character is a Unicode uppercase character if it has the Unicode Uppercase binary property. This is approximately equal to characters that match the regular expression /\\p{Lu}/u except with a few additional characters. A character is a Unicode titlecase character if it has the Unicode Letter, Titlecase property, which is the same as characters that match the regular expression /\\p{Lt}/u . Titlecase characters are typically ligatures of an uppercase character with a lowercase character, such as \u01c8 . (The double-lowercase counterparts such as \u01c9 are considered lowercase letters and would be parsed by lowerU .) Example const parser = upperU const s = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0430\u0431\u0432 // ^ // Expected a Unicode uppercase letter Success Succeeds if the next character is a Unicode uppercase or titlecase letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letterU lowerU upper","title":"upperU"},{"location":"parsers/upperu/#example","text":"const parser = upperU const s = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0430\u0431\u0432 // ^ // Expected a Unicode uppercase letter","title":"Example"},{"location":"parsers/upperu/#success","text":"Succeeds if the next character is a Unicode uppercase or titlecase letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/upperu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/upperu/#see-also","text":"alphaU letterU lowerU upper","title":"See Also"},{"location":"parsers/value/","text":"value(p, x) Applies a parser and, if it succeeds, returns another value. In the example, if the parser string('\"\"') succeeds, then value returns a single character ( \" ). This parser could be used for detecting a quote inside a quoted string in CSV, for instance, where quotation marks are escaped by doubling them. x can be anything, so value is one of the few combinators that can return something other than a string. value(p, x) is an optimized implementation of chain(p, () => always(x)) . Example const parser = value ( string ( '\"\"' ), '\"' ) const s = parse ( parser , '\"\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) / \"\\\"\" const f = parse ( parser , '\"' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \" // ^ // Expected '\"\"' Parameters p The parser that gets applied to the input. x The value for value to return if p succeeds. Success Succeeds if p succeeds. In this case, the result of p is discarded and x is returned instead. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also always","title":"value"},{"location":"parsers/value/#example","text":"const parser = value ( string ( '\"\"' ), '\"' ) const s = parse ( parser , '\"\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) / \"\\\"\" const f = parse ( parser , '\"' ) console . log ( status ( f )) // Symbol(fail) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \" // ^ // Expected '\"\"'","title":"Example"},{"location":"parsers/value/#parameters","text":"p The parser that gets applied to the input. x The value for value to return if p succeeds.","title":"Parameters"},{"location":"parsers/value/#success","text":"Succeeds if p succeeds. In this case, the result of p is discarded and x is returned instead.","title":"Success"},{"location":"parsers/value/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/value/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/value/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/value/#see-also","text":"always","title":"See Also"}]}