{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kessel Kessel is a full-featured parser combinator library written in JavaScript. Its aim is to make it easy to produce robust, arbitrarily complex parsers for any conceivable use. Status Kessel is currently alpha-quality software. The author had no more than a vague notion of parser combinators before embarking upon this project, and while he has learned much about the deep workings of such a library, it's likely that there's more to learn that will result in API changes. The test suite is considerable (over 600 tests at the time of writing) and code coverage is very nearly or at 100%, but that doesn't guarantee that the software is bug free. If you find a bug or want to request a feature, please use the GitHub issue tracker for the project. Changelog Version 0.1.0-alpha, 2020-12-03 Initial release. License Kessel is released under the MIT License. MIT License Copyright \u00a9 2020 Thomas Otterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contact Kessel is written and presently maintained by Thomas Otterson, who can be reached at tjotterson [at] gmail.com.","title":"Home"},{"location":"#kessel","text":"Kessel is a full-featured parser combinator library written in JavaScript. Its aim is to make it easy to produce robust, arbitrarily complex parsers for any conceivable use.","title":"Kessel"},{"location":"#status","text":"Kessel is currently alpha-quality software. The author had no more than a vague notion of parser combinators before embarking upon this project, and while he has learned much about the deep workings of such a library, it's likely that there's more to learn that will result in API changes. The test suite is considerable (over 600 tests at the time of writing) and code coverage is very nearly or at 100%, but that doesn't guarantee that the software is bug free. If you find a bug or want to request a feature, please use the GitHub issue tracker for the project.","title":"Status"},{"location":"#changelog","text":"","title":"Changelog"},{"location":"#version-010-alpha-2020-12-03","text":"Initial release.","title":"Version 0.1.0-alpha, 2020-12-03"},{"location":"#license","text":"Kessel is released under the MIT License. MIT License Copyright \u00a9 2020 Thomas Otterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"#contact","text":"Kessel is written and presently maintained by Thomas Otterson, who can be reached at tjotterson [at] gmail.com.","title":"Contact"},{"location":"api/","text":"Summary Terminology A couple notes on terms you'll find in this API documentation. Parser Everything in the Parser API Reference is referred to as a parser . This is not exactly accurate; in Kessel, a parser is a function that takes a context as an argument and returns a tuple of an updated context and a result. By that definition, the only parsers in here are things like any and letter that don't take any additional parameters. A number of items in the reference are functions that produce parsers. Examples are char and string . These require extra information to know what to parse - char needs to know which character it's looking for, for example - so they have parameters to let them accept that information. But these functions return parsers. In other words, char is not a parser, but char('a') is. Because of that, it's safe enough to refer to these functions as parsers as well. The final class of object in the Parser API Reference is the combinator . A combinator is a function that takes one or more parsers as parameters, maybe with other parameters as well, and return another parser. ( block and blockB take generator functions instead of parsers, but since those generator functions can call parsers in their bodies, they can also be considered combinators.) Combinators are a little different because they don't actually read text. Every parser or parser-producing function, at the core, is a function that reads one or more characters of text and either succeeds or fails depending on whether it read the character(s) it was expecting. Combinators don't do that; they modify or compose other parsers. For example, many doesn't read any text at all, but it tells the parser passed into it to read text zero or more times. But in the end it's all the same. many may not parse text directly, but it has a value passed to it which may be a parser itself. If it's not, then it must be a combinator that has a value passed to it . Eventually, there's going to be a parser, and it will read text. So many may not be a parser, and the same with choice and pipe and join , but pipe(choice(char('_'), letter), join(many(choice(char('_'), letter, digit))), (first, rest) => first + rest) is definitely a parser. (One which does a pretty reasonable job of parsing a programming language identifier..md) In summary, every entry in the Parser API Reference either is a function that takes a context and returns a tuple of a context and a result, or it produces one. And directly or indirectly, every entry reads text. So unless there needs to be some distinction between these three different kinds of objects, it's safe to just call them all parsers . Return As has already been stated way more times than is necessary, a parser returns a tuple of a context and a result. But as is also very clear, that's way too many words to use too many times. In this documentation, we will talk about parsers returning values. In this case, \"this parser returns a string\" means \"this parser returns a tuple of a context and a result, and upon success, the value of that result is a string.\" I think we can all agree that one is more fun to read (and write) than the other. Parsers Table 1: Single character parsers Parser Description char Parses a single character. charI Parses a single character, but without case sensitivity. satisfy Parses a single character for which a predicate returns true . satisfyM Parses a single character for which a predicate returns true . Fails with a message string if the predicate returns false . range Parses a single character whose code point is between two other characters. any Parses any one character. anyOf Parses a single character which is included in a string or an array. noneOf Parses a single character which is not in included in a string or an array. digit Parses a single decimal digit ( 0-9 ). hex Parses a single hexadecmial digit ( 0-9 , a-f , or A-F ). octal Parses a single octal digit ( 0-7 ). letter Parses a single ASCII letter ( a-z or A-Z ). alpha Parses a single ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). lower Parses a single ASCII lowercase letter ( a-z ). upper Parses a single ASCII uppercase letter ( A-Z ). letterU Parses a single UTF-8 letter. alphaU Parses a single UTF-8 alphanumeric character. lowerU Parses a single UTF-8 lowercase letter. upperU Parses a single UTF-8 uppercase letter. Table 2: String (multiple-character) parsers Parser Description string Parses a string. stringI Parses a string, but without case sensitivity. regex Parses a string matching a regular expression pattern. all Parses the remainder of the input as a string. anyString Parses a string of a certain number of characters. Table 3: Whitespace parsers Parser Description newline Parses a single ASCII newline character ( \\r , \\n , or \\r\\n ). space Parses a single ASCII whitespace character ( , \\t , or a newline). spaces Skips zero or more ASCII whitespace characters. spaces1 Skips one or more ASCII whitespace characters. newlineU Parses a single UTF-8 newline character. spaceU Parses a single UTF-8 whitespace character (including newlines.md). spacesU Skips zero or more UTF-8 whitespace characters. spaces1U Skips one or more UTF-8 whitespace characters. eof Succeeds only at the end of the input. Table 4: Miscellaneous parsers Parser Description always Always succeeds and returns a value. fail Fails with an expected message. failUnexpected Fails with an unexpected message. failFatally Fails fatally with an expected message. Table 5: Chaining combinators Parser Description chain Applies a parser, then applies a function to the result, then applies the parser returned by the function. value Applies a parser and returns a value. skip Applies a parser and discards the result. map Applies a parser, then applies a function to the result, then returns the result of that function. left Applies two parsers in order and returns the result of the first one. right Applies two parsers in order and returns the result of the second one. both Applies two parsers in order and returns their results in a tuple. pipe Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. between Applies a content parser between two other parsers, returning only the content parser's result. nth Applies a parser and returns the nth element of the resulting array. first Applies a parser and returns the first element of the resulting array. second Applies a parser and returns the second element of the resulting array. third Applies a parser and returns the third element of the resulting array. fourth Applies a parser and returns the fourth element of the resulting array. fifth Applies a parser and returns the fifth element of the resulting array. join Applies a parser and returns its resulting array elements joined together into a string. Table 6: Sequence combinators Parser Description sequence Applies a series of parsers in order, returning their results in an array. block Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. many Applies a parser zero or more times until it fails, returning all of the results in an array. many1 Applies a parser one or more times until it fails, returning all of the results in an array. skipMany Applies a parser zero or more times until it fails, discarding the results. skipMany1 Applies a parser one or more times until it fails, discarding the results. sepBy Applies a content parser zero or more times with an application of a separator parser between each. Returns the content parser results. sepBy1 Applies a content parser one or more times with an application of a separator parser between each. Returns the content parser results. sepEndBy Applies a content parser zero or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. sepEndBy1 Applies a content parser one or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. repeat Applies a parser a certain number of times, returning the results in an array. manyTill Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. assocL Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1L Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assocR Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1R Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. Table 7: Alternative and backtracking combinators Parser Description choice Applies a series of parsers one at a time until one succeeds. optional Applies a parser and returns its result on success. On failure, succeeds but returns nothing. orValue Applies a parser and returns either its result upon success or another value upon failure. attempt Applies a parser, backtracking to its original position if the parser fails and consumes input. sequenceB Applies a series of parsers in order, returning their results in an array. Backtracks to where the first parser was applied if any other of its parsers fails. blockB Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. Backtracks to where the first yielded parser was applied if any later parser fails. chainB Applies a parser, then applies a function to the result, then applies the parser returned by the function. Backtracks to where the first parser was applied if the parser returned by the function fails. leftB Applies two parsers in order and returns the result of the first one. Backtracks to the location where the first parser was applied if the second one fails. rightB Applies two parsers in order and returns the result of the second one. Backtracks to the location where the first parser was applied if the second one fails. bothB Applies two parsers in order and returns the results of both in a tuple. Backtracks to the location where the first parser was applied if the second one fails. pipeB Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. Backtracks to where the first parser was applied if any other parser fails. repeatB Applies a parser a certain number of times, returning the results in an array. Backtracks to where the first parser was applied if any other parser fails. manyTillB Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. Backtracks to where the content parser was first applied if it fails before the end parser succeeds. betweenB Applies a content parser between two other parsers, returning only the content parser's result. Backtracks to where the first parser was applied if either other parser fails. Table 8: Conditional and lookahead combinators Parser Description lookAhead Applies a parser and returns its result without consuming input. notEmpty Applies a parser and fails if the parser succeeds without consuming input. followedBy Applies a parser and succeeds without consuming input if that parser succeeds. notFollowedBy Applies a parser and succeeds without consuming input if that parser fails. Table 9: Error message combinators Parser Description label Applies a parser and replaces its errors with an expected error if that parser fails. backLabel Applies a parser and replaces its errors with an expected error if that parser fails. Backtracks to where the parser was applied and adds additional information to the error message if that parser consumes input. notEmptyM Applies a parser and fails if the parser succeeds without consuming input. Overwrites the error message with a custom one on failure. followedByM Applies a parser and succeeds without consuming input if that parser succeeds. Overwrites the error message with a custom one on failure. notFollowedByM Applies a parser and succeeds without consuming input if that parser fails. Overwrites the error message with a custom one on failure.","title":"Summary"},{"location":"api/#summary","text":"","title":"Summary"},{"location":"api/#terminology","text":"A couple notes on terms you'll find in this API documentation.","title":"Terminology"},{"location":"api/#parser","text":"Everything in the Parser API Reference is referred to as a parser . This is not exactly accurate; in Kessel, a parser is a function that takes a context as an argument and returns a tuple of an updated context and a result. By that definition, the only parsers in here are things like any and letter that don't take any additional parameters. A number of items in the reference are functions that produce parsers. Examples are char and string . These require extra information to know what to parse - char needs to know which character it's looking for, for example - so they have parameters to let them accept that information. But these functions return parsers. In other words, char is not a parser, but char('a') is. Because of that, it's safe enough to refer to these functions as parsers as well. The final class of object in the Parser API Reference is the combinator . A combinator is a function that takes one or more parsers as parameters, maybe with other parameters as well, and return another parser. ( block and blockB take generator functions instead of parsers, but since those generator functions can call parsers in their bodies, they can also be considered combinators.) Combinators are a little different because they don't actually read text. Every parser or parser-producing function, at the core, is a function that reads one or more characters of text and either succeeds or fails depending on whether it read the character(s) it was expecting. Combinators don't do that; they modify or compose other parsers. For example, many doesn't read any text at all, but it tells the parser passed into it to read text zero or more times. But in the end it's all the same. many may not parse text directly, but it has a value passed to it which may be a parser itself. If it's not, then it must be a combinator that has a value passed to it . Eventually, there's going to be a parser, and it will read text. So many may not be a parser, and the same with choice and pipe and join , but pipe(choice(char('_'), letter), join(many(choice(char('_'), letter, digit))), (first, rest) => first + rest) is definitely a parser. (One which does a pretty reasonable job of parsing a programming language identifier..md) In summary, every entry in the Parser API Reference either is a function that takes a context and returns a tuple of a context and a result, or it produces one. And directly or indirectly, every entry reads text. So unless there needs to be some distinction between these three different kinds of objects, it's safe to just call them all parsers .","title":"Parser"},{"location":"api/#return","text":"As has already been stated way more times than is necessary, a parser returns a tuple of a context and a result. But as is also very clear, that's way too many words to use too many times. In this documentation, we will talk about parsers returning values. In this case, \"this parser returns a string\" means \"this parser returns a tuple of a context and a result, and upon success, the value of that result is a string.\" I think we can all agree that one is more fun to read (and write) than the other.","title":"Return"},{"location":"api/#parsers","text":"","title":"Parsers"},{"location":"api/#table-1-single-character-parsers","text":"Parser Description char Parses a single character. charI Parses a single character, but without case sensitivity. satisfy Parses a single character for which a predicate returns true . satisfyM Parses a single character for which a predicate returns true . Fails with a message string if the predicate returns false . range Parses a single character whose code point is between two other characters. any Parses any one character. anyOf Parses a single character which is included in a string or an array. noneOf Parses a single character which is not in included in a string or an array. digit Parses a single decimal digit ( 0-9 ). hex Parses a single hexadecmial digit ( 0-9 , a-f , or A-F ). octal Parses a single octal digit ( 0-7 ). letter Parses a single ASCII letter ( a-z or A-Z ). alpha Parses a single ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). lower Parses a single ASCII lowercase letter ( a-z ). upper Parses a single ASCII uppercase letter ( A-Z ). letterU Parses a single UTF-8 letter. alphaU Parses a single UTF-8 alphanumeric character. lowerU Parses a single UTF-8 lowercase letter. upperU Parses a single UTF-8 uppercase letter.","title":"Table 1: Single character parsers"},{"location":"api/#table-2-string-multiple-character-parsers","text":"Parser Description string Parses a string. stringI Parses a string, but without case sensitivity. regex Parses a string matching a regular expression pattern. all Parses the remainder of the input as a string. anyString Parses a string of a certain number of characters.","title":"Table 2: String (multiple-character) parsers"},{"location":"api/#table-3-whitespace-parsers","text":"Parser Description newline Parses a single ASCII newline character ( \\r , \\n , or \\r\\n ). space Parses a single ASCII whitespace character ( , \\t , or a newline). spaces Skips zero or more ASCII whitespace characters. spaces1 Skips one or more ASCII whitespace characters. newlineU Parses a single UTF-8 newline character. spaceU Parses a single UTF-8 whitespace character (including newlines.md). spacesU Skips zero or more UTF-8 whitespace characters. spaces1U Skips one or more UTF-8 whitespace characters. eof Succeeds only at the end of the input.","title":"Table 3: Whitespace parsers"},{"location":"api/#table-4-miscellaneous-parsers","text":"Parser Description always Always succeeds and returns a value. fail Fails with an expected message. failUnexpected Fails with an unexpected message. failFatally Fails fatally with an expected message.","title":"Table 4: Miscellaneous parsers"},{"location":"api/#table-5-chaining-combinators","text":"Parser Description chain Applies a parser, then applies a function to the result, then applies the parser returned by the function. value Applies a parser and returns a value. skip Applies a parser and discards the result. map Applies a parser, then applies a function to the result, then returns the result of that function. left Applies two parsers in order and returns the result of the first one. right Applies two parsers in order and returns the result of the second one. both Applies two parsers in order and returns their results in a tuple. pipe Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. between Applies a content parser between two other parsers, returning only the content parser's result. nth Applies a parser and returns the nth element of the resulting array. first Applies a parser and returns the first element of the resulting array. second Applies a parser and returns the second element of the resulting array. third Applies a parser and returns the third element of the resulting array. fourth Applies a parser and returns the fourth element of the resulting array. fifth Applies a parser and returns the fifth element of the resulting array. join Applies a parser and returns its resulting array elements joined together into a string.","title":"Table 5: Chaining combinators"},{"location":"api/#table-6-sequence-combinators","text":"Parser Description sequence Applies a series of parsers in order, returning their results in an array. block Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. many Applies a parser zero or more times until it fails, returning all of the results in an array. many1 Applies a parser one or more times until it fails, returning all of the results in an array. skipMany Applies a parser zero or more times until it fails, discarding the results. skipMany1 Applies a parser one or more times until it fails, discarding the results. sepBy Applies a content parser zero or more times with an application of a separator parser between each. Returns the content parser results. sepBy1 Applies a content parser one or more times with an application of a separator parser between each. Returns the content parser results. sepEndBy Applies a content parser zero or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. sepEndBy1 Applies a content parser one or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. repeat Applies a parser a certain number of times, returning the results in an array. manyTill Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. assocL Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1L Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assocR Applies a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1R Applies a content parser one or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser.","title":"Table 6: Sequence combinators"},{"location":"api/#table-7-alternative-and-backtracking-combinators","text":"Parser Description choice Applies a series of parsers one at a time until one succeeds. optional Applies a parser and returns its result on success. On failure, succeeds but returns nothing. orValue Applies a parser and returns either its result upon success or another value upon failure. attempt Applies a parser, backtracking to its original position if the parser fails and consumes input. sequenceB Applies a series of parsers in order, returning their results in an array. Backtracks to where the first parser was applied if any other of its parsers fails. blockB Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. Backtracks to where the first yielded parser was applied if any later parser fails. chainB Applies a parser, then applies a function to the result, then applies the parser returned by the function. Backtracks to where the first parser was applied if the parser returned by the function fails. leftB Applies two parsers in order and returns the result of the first one. Backtracks to the location where the first parser was applied if the second one fails. rightB Applies two parsers in order and returns the result of the second one. Backtracks to the location where the first parser was applied if the second one fails. bothB Applies two parsers in order and returns the results of both in a tuple. Backtracks to the location where the first parser was applied if the second one fails. pipeB Applies a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. Backtracks to where the first parser was applied if any other parser fails. repeatB Applies a parser a certain number of times, returning the results in an array. Backtracks to where the first parser was applied if any other parser fails. manyTillB Applies a content parser zero or more times until an end parser succeeds. Returns the content parser's results. Backtracks to where the content parser was first applied if it fails before the end parser succeeds. betweenB Applies a content parser between two other parsers, returning only the content parser's result. Backtracks to where the first parser was applied if either other parser fails.","title":"Table 7: Alternative and backtracking combinators"},{"location":"api/#table-8-conditional-and-lookahead-combinators","text":"Parser Description lookAhead Applies a parser and returns its result without consuming input. notEmpty Applies a parser and fails if the parser succeeds without consuming input. followedBy Applies a parser and succeeds without consuming input if that parser succeeds. notFollowedBy Applies a parser and succeeds without consuming input if that parser fails.","title":"Table 8: Conditional and lookahead combinators"},{"location":"api/#table-9-error-message-combinators","text":"Parser Description label Applies a parser and replaces its errors with an expected error if that parser fails. backLabel Applies a parser and replaces its errors with an expected error if that parser fails. Backtracks to where the parser was applied and adds additional information to the error message if that parser consumes input. notEmptyM Applies a parser and fails if the parser succeeds without consuming input. Overwrites the error message with a custom one on failure. followedByM Applies a parser and succeeds without consuming input if that parser succeeds. Overwrites the error message with a custom one on failure. notFollowedByM Applies a parser and succeeds without consuming input if that parser fails. Overwrites the error message with a custom one on failure.","title":"Table 9: Error message combinators"},{"location":"installation/","text":"Installation npm install @barandis/kessel This won't actually be available on NPM until I finish basic documentation, which should happen around the beginning of December. There are also self-contained files ( kessel.js and the minified kessel.min.js ) in the lib directory of the distribution. These will work in the browser (where a global kessel object is provided) or with CommonJS or AMD. Assertions The default Kessel library uses assertions to ensure that input to parsers is what it's supposed to be. This is more than type-checking like in TypeScript - runtime failures will result if the wrong kind of input is given to a parser. Defensive programming is not normally a philosophy that I take to, but understanding the source of errors is so important in parsing that it seems appropriate here. The assertions slow down parsing, though I suspect that the amount of time added is negligible (this has not yet been benchmarked, though that is on the list of things to do). Every input that has a definitive type is checked, so if you have a choice that takes a thousand parsers, maybe that will be a bit slower. The distribution does contain versions without assertions, named kessel.noassert.js and kessel.noassert.min.js . If you are seriously concerned about performance you can choose to use these instead.","title":"Installation"},{"location":"installation/#installation","text":"npm install @barandis/kessel This won't actually be available on NPM until I finish basic documentation, which should happen around the beginning of December. There are also self-contained files ( kessel.js and the minified kessel.min.js ) in the lib directory of the distribution. These will work in the browser (where a global kessel object is provided) or with CommonJS or AMD.","title":"Installation"},{"location":"installation/#assertions","text":"The default Kessel library uses assertions to ensure that input to parsers is what it's supposed to be. This is more than type-checking like in TypeScript - runtime failures will result if the wrong kind of input is given to a parser. Defensive programming is not normally a philosophy that I take to, but understanding the source of errors is so important in parsing that it seems appropriate here. The assertions slow down parsing, though I suspect that the amount of time added is negligible (this has not yet been benchmarked, though that is on the list of things to do). Every input that has a definitive type is checked, so if you have a choice that takes a thousand parsers, maybe that will be a bit slower. The distribution does contain versions without assertions, named kessel.noassert.js and kessel.noassert.min.js . If you are seriously concerned about performance you can choose to use these instead.","title":"Assertions"},{"location":"overview/","text":"Overview Kessel is a parser combinator library inspired heavily by the Parsec library written in Haskell and its F# counterpart FParsec . It shares many of the features of these libraries, brought to JavaScript, and includes some others. Full UTF-8 support, including 3- and 4-byte characters that JavaScript doesn't regularly support Detailed error messages and facilities to customize error messages Optimized implementations of combinators to help make up for the relative slowness of parser combinators in general Written in a consistent functional style, which makes it natural to create new parsers that look and work just like the packaged ones Selectable backtracking Ability to write arbitrary functions that contain other parsers and can be used as parsers themselves To illustrate, here's a short parser definition for a CSV parser. This is a fully featured parser which can handle quoted commas, escaped quotes, and the like. This example is taken from a similar example in the online book Real World Haskell . It's shorter than the Haskell/Parsec version, but JavaScript's lack of custom operators means it's perhaps a bit more dense. Parser Code import { char , choice , join , label , many , newline , noneOf , run , second , sepBy , sepEndBy , sequenceB , string , value , } from '@barandis/kessel' const quotedChar = choice ( noneOf ( '\"' ), value ( string ( '\"\"' ), '\"' )) const quotedCell = second ( sequenceB ( char ( '\"' ), join ( many ( quotedChar )), label ( char ( '\"' ), 'quote at end of cell' ), )) const cell = choice ( quotedCell , join ( many ( noneOf ( ',\\n\\r' )))) const line = sepBy ( cell , char ( ',' )) const csv = sepEndBy ( line , newline ) const parseCsv = input => run ( csv , input ) Example Run // CSV input is from Wikipedia's article on comma-separated values // https://en.wikipedia.org/wiki/Comma-separated_values#Example const text = `Year,Make,Model,Description,Price 1997,Ford,E350,\"ac, abs, moon\",3000.00 1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00 1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",,5000.00 1996,Jeep,Grand Cherokee,\"MUST SELL! air, moon roof, loaded\",4799.00` const result = parseCsv ( text ) // `result` is equal to the following: // [ // ['Year', 'Make', 'Model', 'Description', 'Price'], // ['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition\"', '', '4900.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition, Very Large\"', '', '5000.00'], // ['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL! air, moon roof, loaded', '4799.00'] // ]","title":"Overview"},{"location":"overview/#overview","text":"Kessel is a parser combinator library inspired heavily by the Parsec library written in Haskell and its F# counterpart FParsec . It shares many of the features of these libraries, brought to JavaScript, and includes some others. Full UTF-8 support, including 3- and 4-byte characters that JavaScript doesn't regularly support Detailed error messages and facilities to customize error messages Optimized implementations of combinators to help make up for the relative slowness of parser combinators in general Written in a consistent functional style, which makes it natural to create new parsers that look and work just like the packaged ones Selectable backtracking Ability to write arbitrary functions that contain other parsers and can be used as parsers themselves To illustrate, here's a short parser definition for a CSV parser. This is a fully featured parser which can handle quoted commas, escaped quotes, and the like. This example is taken from a similar example in the online book Real World Haskell . It's shorter than the Haskell/Parsec version, but JavaScript's lack of custom operators means it's perhaps a bit more dense. Parser Code import { char , choice , join , label , many , newline , noneOf , run , second , sepBy , sepEndBy , sequenceB , string , value , } from '@barandis/kessel' const quotedChar = choice ( noneOf ( '\"' ), value ( string ( '\"\"' ), '\"' )) const quotedCell = second ( sequenceB ( char ( '\"' ), join ( many ( quotedChar )), label ( char ( '\"' ), 'quote at end of cell' ), )) const cell = choice ( quotedCell , join ( many ( noneOf ( ',\\n\\r' )))) const line = sepBy ( cell , char ( ',' )) const csv = sepEndBy ( line , newline ) const parseCsv = input => run ( csv , input ) Example Run // CSV input is from Wikipedia's article on comma-separated values // https://en.wikipedia.org/wiki/Comma-separated_values#Example const text = `Year,Make,Model,Description,Price 1997,Ford,E350,\"ac, abs, moon\",3000.00 1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00 1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",,5000.00 1996,Jeep,Grand Cherokee,\"MUST SELL! air, moon roof, loaded\",4799.00` const result = parseCsv ( text ) // `result` is equal to the following: // [ // ['Year', 'Make', 'Model', 'Description', 'Price'], // ['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition\"', '', '4900.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition, Very Large\"', '', '5000.00'], // ['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL! air, moon roof, loaded', '4799.00'] // ]","title":"Overview"},{"location":"parsers/all/","text":"all const parser = all const s = parse ( parser , 'content' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"content\" Reads and returns all remaining characters in the input. Success Always succeeds. Consumes all remaining characters and returns those characters as a single string. If the current parse location is already at the end of input, all will return the empty string and consume nothing. See Also anyString eof","title":"all"},{"location":"parsers/all/#success","text":"Always succeeds. Consumes all remaining characters and returns those characters as a single string. If the current parse location is already at the end of input, all will return the empty string and consume nothing.","title":"Success"},{"location":"parsers/all/#see-also","text":"anyString eof","title":"See Also"},{"location":"parsers/alpha/","text":"alpha const parser = alpha const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '---' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected an alphanumeric character Reads the next character and succeeds if that character is an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). This does not parse UTF-8 alphanumeric characters in general. Use alphaU for that. Success Succeeds if the next character is an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letter lower upper","title":"alpha"},{"location":"parsers/alpha/#success","text":"Succeeds if the next character is an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/alpha/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/alpha/#see-also","text":"alphaU letter lower upper","title":"See Also"},{"location":"parsers/alphau/","text":"alphaU const parser = alphaU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '---' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected a Unicode alphanumeric character Reads the next character and succeeds if that character is a Unicode alphanumeric character. A character is a Unicode alphanumeric character if it has either the Unicode Alphabetic binary property or the Unicode Number binary property. Success Succeeds if the next character is a Unicode alphanumeric character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letterU lowerU upperU","title":"alphaU"},{"location":"parsers/alphau/#success","text":"Succeeds if the next character is a Unicode alphanumeric character. Consumes and returns that character.","title":"Success"},{"location":"parsers/alphau/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/alphau/#see-also","text":"alpha letterU lowerU upperU","title":"See Also"},{"location":"parsers/always/","text":"always(x) const parser = always ( 3.14 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 3.14 Always succeeds and returns its passed value. This is the only parser that can return a value that is not a string. (Some combinators can also do this.) Parameters x An arbitrary value that this parser always returns. Success Always succeeds. Returns x and consumes no input. See Also value","title":"always"},{"location":"parsers/always/#parameters","text":"x An arbitrary value that this parser always returns.","title":"Parameters"},{"location":"parsers/always/#success","text":"Always succeeds. Returns x and consumes no input.","title":"Success"},{"location":"parsers/always/#see-also","text":"value","title":"See Also"},{"location":"parsers/any/","text":"any const parser = any const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Reads any single character. Success Succeeds as long as there is a character to be read. That character is consumed and returned. Failure Fails at the end of input. See Also anyString","title":"any"},{"location":"parsers/any/#success","text":"Succeeds as long as there is a character to be read. That character is consumed and returned.","title":"Success"},{"location":"parsers/any/#failure","text":"Fails at the end of input.","title":"Failure"},{"location":"parsers/any/#see-also","text":"anyString","title":"See Also"},{"location":"parsers/anyof/","text":"anyOf(cs) const parser = anyOf ( 'Test' ) const s = parse ( parser , 'Test' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"T\" const f = parse ( parser , 'Exit' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Exit // ^ // Expected any of 'T', 'e', 's', or 't' Reads a single character and succeeds if that character is included in cs . Parameters cs The set of characters that the next character is expected to be a part of. This can be either a string or an array of single-character strings. Success Succeeds if the next character is one of the characters in cs . Consumes and returns that character. Failure Fails if the next character is any other character. Throws Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length. See Also noneOf","title":"anyOf"},{"location":"parsers/anyof/#parameters","text":"cs The set of characters that the next character is expected to be a part of. This can be either a string or an array of single-character strings.","title":"Parameters"},{"location":"parsers/anyof/#success","text":"Succeeds if the next character is one of the characters in cs . Consumes and returns that character.","title":"Success"},{"location":"parsers/anyof/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/anyof/#throws","text":"Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length.","title":"Throws"},{"location":"parsers/anyof/#see-also","text":"noneOf","title":"See Also"},{"location":"parsers/anystring/","text":"anyString(n) const parser = anyString ( 3 ) const s = parse ( parser , 'abcdef' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"abc\" const f = parse ( parser , 'ab' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // Expected a string of 3 characters Reads n characters and returns them as a single string. Parameters n The number of characters to read. Success Succeeds if there are at least n characters remaining to read. Consumes that many characters and returns them as a single string. If n is less than 1, no characters will be consumed and the empty string will be returned. Failure Fails if there are not at least n characters remaining in the input. Throws Throws an error if n is not a number. See Also all any","title":"anyString"},{"location":"parsers/anystring/#parameters","text":"n The number of characters to read.","title":"Parameters"},{"location":"parsers/anystring/#success","text":"Succeeds if there are at least n characters remaining to read. Consumes that many characters and returns them as a single string. If n is less than 1, no characters will be consumed and the empty string will be returned.","title":"Success"},{"location":"parsers/anystring/#failure","text":"Fails if there are not at least n characters remaining in the input.","title":"Failure"},{"location":"parsers/anystring/#throws","text":"Throws an error if n is not a number.","title":"Throws"},{"location":"parsers/anystring/#see-also","text":"all any","title":"See Also"},{"location":"parsers/assoc1l/","text":"assoc1L(p, pop) const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = choice ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1L ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 34 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit Parses one or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content left-associatively. The operation parser pop must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so pop must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If pop succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first pop to the values returned by the first two p s, then applying the function returned by the second pop to that value and the value returned by the third p , and so on. assoc1L fails if p never succeeds, but it is not required that pop ever succeed. If pop never succeeds but p succeeds once, that result from p is returned. See assocL for an explanation of the success case of the example. That example works identically to this one. Parameters p The content parser. pop The operation parser. This parser must return a function. Success Succeeds if p succeeds at least once and neither p nor pop ever fail fatally. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned. Failure Fails if p fails on its first attempt. Fatal Failure Fails fatally if either p or pop fail fatally. Throws Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function. See Also assocL assoc1R","title":"assoc1L"},{"location":"parsers/assoc1l/#parameters","text":"p The content parser. pop The operation parser. This parser must return a function.","title":"Parameters"},{"location":"parsers/assoc1l/#success","text":"Succeeds if p succeeds at least once and neither p nor pop ever fail fatally. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned.","title":"Success"},{"location":"parsers/assoc1l/#failure","text":"Fails if p fails on its first attempt.","title":"Failure"},{"location":"parsers/assoc1l/#fatal-failure","text":"Fails fatally if either p or pop fail fatally.","title":"Fatal Failure"},{"location":"parsers/assoc1l/#throws","text":"Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function.","title":"Throws"},{"location":"parsers/assoc1l/#see-also","text":"assocL assoc1R","title":"See Also"},{"location":"parsers/assoc1r/","text":"assoc1R(p, pop) const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = choice ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1R ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -78 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit Parses one or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content right-associatively. The operation parser pop must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so pop must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If pop succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first pop to the values returned by the first two p s, then applying the function returned by the second pop to that value and the value returned by the third p , and so on. assoc1R fails if p never succeeds, but it is not required that pop ever succeed. If pop never succeeds but p succeeds once, that result from p is returned. See assocR for an explanation of the success case of the example. That example works identically to this one. Parameters p The content parser. pop The operation parser. This parser must return a function. Success Succeeds if p succeeds at least once and neither p nor pop ever fail fatally. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned. Failure Fails if p fails on its first attempt. Fatal Failure Fails fatally if either p or pop fail fatally. Throws Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function. See Also assoc1L assocR","title":"assoc1R"},{"location":"parsers/assoc1r/#parameters","text":"p The content parser. pop The operation parser. This parser must return a function.","title":"Parameters"},{"location":"parsers/assoc1r/#success","text":"Succeeds if p succeeds at least once and neither p nor pop ever fail fatally. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned.","title":"Success"},{"location":"parsers/assoc1r/#failure","text":"Fails if p fails on its first attempt.","title":"Failure"},{"location":"parsers/assoc1r/#fatal-failure","text":"Fails fatally if either p or pop fail fatally.","title":"Fatal Failure"},{"location":"parsers/assoc1r/#throws","text":"Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function.","title":"Throws"},{"location":"parsers/assoc1r/#see-also","text":"assoc1L assocR","title":"See Also"},{"location":"parsers/assocl/","text":"assocL(p, pop, x) const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = choice ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocL ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // 34 Parses zero or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content left-associatively. The operation parser pop must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so pop must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If pop succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first pop to the values returned by the first two p s, then applying the function returned by the second pop to that value and the value returned by the third p , and so on. If p never succeeds, assocL still succeeds, but it returns the value x directly. If pop never succeeds but p succeeds once, that result from p is returned. This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these left-associatively results in (12 - 34) + 56 , which evaluates to 34 . Parameters p The content parser. pop The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once. Success Succeeds if neither p nor pop fail fatally. If p never succeeds, x is returned. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned. Fatal Failure Fails fatally if either p or pop fail fatally. Throws Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function. See Also assoc1L assocR","title":"assocL"},{"location":"parsers/assocl/#parameters","text":"p The content parser. pop The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once.","title":"Parameters"},{"location":"parsers/assocl/#success","text":"Succeeds if neither p nor pop fail fatally. If p never succeeds, x is returned. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned.","title":"Success"},{"location":"parsers/assocl/#fatal-failure","text":"Fails fatally if either p or pop fail fatally.","title":"Fatal Failure"},{"location":"parsers/assocl/#throws","text":"Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function.","title":"Throws"},{"location":"parsers/assocl/#see-also","text":"assoc1L assocR","title":"See Also"},{"location":"parsers/assocr/","text":"assocR(p, pop, x) const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = choice ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocR ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -78 Parses zero or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content right-associatively. The operation parser pop must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so pop must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If pop succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first pop to the values returned by the first two p s, then applying the function returned by the second pop to that value and the value returned by the third p , and so on. If p never succeeds, assocR still succeeds, but it returns the value x directly. If pop never succeeds but p succeeds once, that result from p is returned. This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these right-associatively results in 12 - (34 + 56) , which evaluates to -78 . (This is not mathematically valid - subtraction is left-associative absent parentheses - but it serves to illustrate how right-associativity works.) Parameters p The content parser. pop The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once. Success Succeeds if neither p nor pop fail fatally. If p never succeeds, x is returned. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned. Fatal Failure Fails fatally if either p or pop fail fatally. Throws Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function. See Also assocL assoc1R","title":"assocR"},{"location":"parsers/assocr/#parameters","text":"p The content parser. pop The operation parser. This parser must return a function. x The default return value. This is used as a result if p doesn't succeed at least once.","title":"Parameters"},{"location":"parsers/assocr/#success","text":"Succeeds if neither p nor pop fail fatally. If p never succeeds, x is returned. If p succeeds once and pop does not, the result of p is returned. Otherwise, the left associative application of the results of pop to the results of p is returned.","title":"Success"},{"location":"parsers/assocr/#fatal-failure","text":"Fails fatally if either p or pop fail fatally.","title":"Fatal Failure"},{"location":"parsers/assocr/#throws","text":"Throws an error if either p or pop are not parsers. Throws an error if any result of pop is not a function.","title":"Throws"},{"location":"parsers/assocr/#see-also","text":"assocL assoc1R","title":"See Also"},{"location":"parsers/attempt/","text":"attempt(p) const parser = attempt ( left ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const b = parse ( parser , 'ab' ) console . log ( status ( b )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies a parser and, if it fails after consuming input, backtracks to the original location and fails non-fatally. attempt implements general backtracking. It is different from the backtracking B parsers ( sequenceB , leftB , etc.) in that it is meant to deal with all fatal failures (the B parsers only deal with fatal failures that result from non-fatal failures that come after successes). It's common to use this parser in conjunction with choice , optional , and other parsers which only fail if their parsers fail fatally. Take care when using this parser. It attempts to provide information about what caused the backtracking to occur, but it's not hard to get long and convoluted error messages that don't help a lot if it's used to much. Use backtracking as little as can be done and still serve your needs. Parameters p The parser that is applied and backtracked over if it fails fatally. Success Succeeds if p succeeds. Returns p 's result. Failure Fails if p fails. Fails if p fails fatally. In this case the fatal failure is turned into non-fatal failure and the state is backtracked to where it was before p was applied. Throws Throws an error if p is not a parser. See Also choice optional orValue","title":"attempt"},{"location":"parsers/attempt/#parameters","text":"p The parser that is applied and backtracked over if it fails fatally.","title":"Parameters"},{"location":"parsers/attempt/#success","text":"Succeeds if p succeeds. Returns p 's result.","title":"Success"},{"location":"parsers/attempt/#failure","text":"Fails if p fails. Fails if p fails fatally. In this case the fatal failure is turned into non-fatal failure and the state is backtracked to where it was before p was applied.","title":"Failure"},{"location":"parsers/attempt/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/attempt/#see-also","text":"choice optional orValue","title":"See Also"},{"location":"parsers/backlabel/","text":"backLabel(p, msg) const parser = backLabel ( left ( letter , digit ), 'a letter and then a digit' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter and then a digit const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // a letter and then a digit could not be parsed because: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies a parser and overwrites its error message on failure. If p succeeds, then backLabel does nothing other than return that parser's result. If p fails, what happens depends on whether input was consumed. If no input was consumed, backLabel acts like label and simply replaces the error message with msg . If some input was consumed, then backLabel backtracks to the location where p was originally applied and adds a more detailed backtracking message using msg as a header. Parameters p The parser to apply. If it fails, its error message will be changed. msg The error message for when p does not consume input or as a header for backtracking information if p does consume input.. Success Succeeds if p succeeds. Returns the result of p . Failure Fails if p fails. In this case, the error message generated by p will be replaced with msg . Fatal Failure Fails fatally if p fails fatally. Backtracking will occur and a new error message will be generated to detail the backtracking, but the failure will still be fatal. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also label","title":"backLabel"},{"location":"parsers/backlabel/#parameters","text":"p The parser to apply. If it fails, its error message will be changed. msg The error message for when p does not consume input or as a header for backtracking information if p does consume input..","title":"Parameters"},{"location":"parsers/backlabel/#success","text":"Succeeds if p succeeds. Returns the result of p .","title":"Success"},{"location":"parsers/backlabel/#failure","text":"Fails if p fails. In this case, the error message generated by p will be replaced with msg .","title":"Failure"},{"location":"parsers/backlabel/#fatal-failure","text":"Fails fatally if p fails fatally. Backtracking will occur and a new error message will be generated to detail the backtracking, but the failure will still be fatal.","title":"Fatal Failure"},{"location":"parsers/backlabel/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/backlabel/#see-also","text":"label","title":"See Also"},{"location":"parsers/between/","text":"between(pre, post, p) const parser = between ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input Applies a pre-parser, a content parser, and a post-parser in order, returning the value of the content parser. All three parsers must succeed for between to succeed. Take care to avoid parsing too far with p ; e.g., if the example used join(many(any)) as a content parser instead of what it does, it would also match the ending \" . This would mean that post would never succeed because p already consumed its \" , so between would never succeed. The first failure case in the example ( f ) is non-fatal failure, because no characters were consumed before the failure occurred. The second failure case ( t ) is fatal failure because, though post fails non-fatally, input was consumed before that failure happened. There is another version of this parser, betweenB , which backtracks and fails non-fatally if a non-fatal failure happens after input is consumed. between(pre, post, p) is an optimized implementation of chain(chain(pre, () => p), x => value(post, x)) . (Using higher-level parsers, this can also be written left(right(pre, p), post) .) Parameters pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself. Success Succeeds if all three parsers succeed. Returns the result of p . Failure Fails if any of its three parsers fails before any input is consumed. Fatal Failure Fails fatally if any of its three parsers fails fatally. Fails fatally if any of its three parsers fails after some input was consumed. Throws Throws an error if any of pre , post , and p are not parsers. See Also betweenB manyTill","title":"between"},{"location":"parsers/between/#parameters","text":"pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself.","title":"Parameters"},{"location":"parsers/between/#success","text":"Succeeds if all three parsers succeed. Returns the result of p .","title":"Success"},{"location":"parsers/between/#failure","text":"Fails if any of its three parsers fails before any input is consumed.","title":"Failure"},{"location":"parsers/between/#fatal-failure","text":"Fails fatally if any of its three parsers fails fatally. Fails fatally if any of its three parsers fails after some input was consumed.","title":"Fatal Failure"},{"location":"parsers/between/#throws","text":"Throws an error if any of pre , post , and p are not parsers.","title":"Throws"},{"location":"parsers/between/#see-also","text":"betweenB manyTill","title":"See Also"},{"location":"parsers/betweenb/","text":"betweenB(pre, post, p) const parser = betweenB ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // \"test // ^ // The parser backtracked after: // // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input Applies a pre-parser, a content parser, and a post-parser in order, returning the value of the content parser. All three parsers must succeed for between to succeed. Take care to avoid parsing too far with p ; e.g., if the example used join(many(any)) as a content parser instead of what it does, it would also match the ending \" . This would mean that post would never succeed because p already consumed its \" , so between would never succeed. If any of the parsers fails after some input was consumed, the state will be backtracked to where it was before pre was applied. Parameters pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself. Success Succeeds if all three parsers succeed. Returns the result of p . Failure Fails if any of its three parsers fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any of its three parsers fails fatally. Throws Throws an error if any of pre , post , and p are not parsers. See Also between manyTillB","title":"betweenB"},{"location":"parsers/betweenb/#parameters","text":"pre The parser that is applied first. Its result is discarded. post The parser that is applied last. Its result is discarded. p The parser that is applied after pre and before post . Its result is returned by between itself.","title":"Parameters"},{"location":"parsers/betweenb/#success","text":"Succeeds if all three parsers succeed. Returns the result of p .","title":"Success"},{"location":"parsers/betweenb/#failure","text":"Fails if any of its three parsers fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/betweenb/#fatal-failure","text":"Fails fatally if any of its three parsers fails fatally.","title":"Fatal Failure"},{"location":"parsers/betweenb/#throws","text":"Throws an error if any of pre , post , and p are not parsers.","title":"Throws"},{"location":"parsers/betweenb/#see-also","text":"between manyTillB","title":"See Also"},{"location":"parsers/block/","text":"block(genFn) const parser = block ( function * () { yield spaces const sign = yield choice ( char ( '+' ), char ( '-' )) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' -1729 ' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -1729 const f = parse ( parser , '1729' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1729 // ^ // Expected '+' or '-' const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit Executes a generator function. The generator can yield parsers whose results are returned to the generator when it's restarted. Returns the return value of the generator. block is the most flexible of all of the parsers in the library, able to do anything that can be coded into a function and able to return any value. In the example, a spaces parser is applied first, which skips any leading whitespace ( yield spaces is not assigned to a variable, so the result of the spaces parser is discarded). Next is a choice(char('+'), char('-')) parser, which will match either + or - and assign that character to the variable sign . The third parser to run is join(many1(digit)) , which reads one or more digits, joins them into a string, and assigns that string to the variable number . Finally, another spaces parser is applied and its result discarded. The result of the parser is then calculated by parsing the string number with parseInt to create an integer, which is then multiplied by -1 if the value of sign is - . This is then returned by the last line of the generator function. Note that in the success case, the value that's returned is the number -1729 , not the string '-1729' . The return statement in the generator function returns a number, so that's what the result of the block parser will be. This illustrates that block can do anything that a function can do. If any of these parsers fail, the block parser itself also fails. As shown in the two failure cases, if no input has yet been consumed (as in the f case), the failure is non-fatal. In the second ( t ) failure case, the - is consumed before the digit parser fails to parse the character a , and since something has been consumed, that failure will be fatal. There is another version of this parser, blockB , which will fail non-fatally and backtrack if a yielded parser fails non-fatally. Simpler block s can often be rewritten into sequence parsers. The full power of block is most appropriate when a) calculations need to be done to the results of yielded parsers, b) a non-string result needs to be returned, or c.md) some of the parsers may be working asynchronously. Parameters genFn A generator function that provides the body of the block parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the block parser. Success Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function. Failure Fails if any yielded parser fails before any input is consumed. Fatal Failure Fails fatally if any yielded parser fails fatally. Fails fatally if any yielded parser fails non-fatally after some input was consumed. Throws Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser. See Also blockB sequence","title":"block"},{"location":"parsers/block/#parameters","text":"genFn A generator function that provides the body of the block parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the block parser.","title":"Parameters"},{"location":"parsers/block/#success","text":"Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function.","title":"Success"},{"location":"parsers/block/#failure","text":"Fails if any yielded parser fails before any input is consumed.","title":"Failure"},{"location":"parsers/block/#fatal-failure","text":"Fails fatally if any yielded parser fails fatally. Fails fatally if any yielded parser fails non-fatally after some input was consumed.","title":"Fatal Failure"},{"location":"parsers/block/#throws","text":"Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser.","title":"Throws"},{"location":"parsers/block/#see-also","text":"blockB sequence","title":"See Also"},{"location":"parsers/blockb/","text":"blockB(genFn) const parser = blockB ( function * () { yield spaces const sign = yield choice ( char ( '+' ), char ( '-' )) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' -1729 ' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // -1729 const f = parse ( parser , '1729' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1729 // ^ // Expected '+' or '-' const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // -abcd // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit Executes a generator function. The generator can yield parsers whose results are returned to the generator when it's restarted. Returns the return value of the generator. If any of these parsers fail, the blockB parser itself also fails. This failure will be non-fatal, even if input had been consumed; in this case, the parser backtracks to its location when the first yielded parser was applied. See block for an explanation of the example. The two examples are identical except in that the t case in this example will backtrack and fail non-fatally, while the same case in block 's example will not backtrack and will fail fatally. Simpler blockB s can often be rewritten into sequenceB parsers. The full power of blockB is most appropriate when a) calculations need to be done to the results of yielded parsers, b) a non-string result needs to be returned, or c.md) some of the parsers may be working asynchronously. Parameters genFn A generator function that provides the body of the blockB parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the blockB parser. Success Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function. Failure Fails if any yielded parser fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any yielded parser fails fatally. Throws Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser. See Also block sequenceB","title":"blockB"},{"location":"parsers/blockb/#parameters","text":"genFn A generator function that provides the body of the blockB parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the blockB parser.","title":"Parameters"},{"location":"parsers/blockb/#success","text":"Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function.","title":"Success"},{"location":"parsers/blockb/#failure","text":"Fails if any yielded parser fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/blockb/#fatal-failure","text":"Fails fatally if any yielded parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/blockb/#throws","text":"Throws an error if genFn is not a generator function. Throws an error if any yield statement is executed and the value that is yielded is not a parser.","title":"Throws"},{"location":"parsers/blockb/#see-also","text":"block sequenceB","title":"See Also"},{"location":"parsers/both/","text":"both(p1, p2) const parser = both ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies two parsers in order, returning their results in a tuple. If either parser fails, then the entire both parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p1 or p2 failed fatally). In the examples, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. There is another version of this parser ( bothB ) that will backtrack and fail non-fatally if p1 succeeds and p2 fails non-fatally. both(p1, p2) is an optimized implementation of chain(p1, a => chain(p2, b => always([a, b]))) . Parameters p1 The first parser to apply. If both parsers succeed, this parser's result will be the first element of both 's result. p2 The second parser to apply. If both parsers succeed, this parser's result will be the second element of both 's result. Success Succeeds if both p1 and p2 succeed. Returns the result of p1 . Failure Fails if p1 fails. Fails if p2 fails after p1 succeeds but does not consume input. Fatal Failure Fails fatally if either p1 or p2 fails fatally. Fails fatally if p2 fails after p1 succeeds and consumes some input. Throws Throws an error if either p1 or p2 are not parsers. See Also bothB left right sequence","title":"both"},{"location":"parsers/both/#parameters","text":"p1 The first parser to apply. If both parsers succeed, this parser's result will be the first element of both 's result. p2 The second parser to apply. If both parsers succeed, this parser's result will be the second element of both 's result.","title":"Parameters"},{"location":"parsers/both/#success","text":"Succeeds if both p1 and p2 succeed. Returns the result of p1 .","title":"Success"},{"location":"parsers/both/#failure","text":"Fails if p1 fails. Fails if p2 fails after p1 succeeds but does not consume input.","title":"Failure"},{"location":"parsers/both/#fatal-failure","text":"Fails fatally if either p1 or p2 fails fatally. Fails fatally if p2 fails after p1 succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/both/#throws","text":"Throws an error if either p1 or p2 are not parsers.","title":"Throws"},{"location":"parsers/both/#see-also","text":"bothB left right sequence","title":"See Also"},{"location":"parsers/bothb/","text":"bothB(p1, p2) const parser = bothB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies two parsers in order, returning their results in a tuple. If either parser fails, then the entire bothB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p1 was applied. Parameters p1 The first parser to apply. If both parsers succeed, this parser's result will be the first element of both 's result. p2 The second parser to apply. If both parsers succeed, this parser's result will be the second element of both 's result. Success Succeeds if both p1 and p2 succeed. Returns the result of p1 . Failure Fails if either p1 or p2 fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p1 or p2 fails fatally. Throws Throws an error if either p1 or p2 are not parsers. See Also both leftB rightB sequenceB","title":"bothB"},{"location":"parsers/bothb/#parameters","text":"p1 The first parser to apply. If both parsers succeed, this parser's result will be the first element of both 's result. p2 The second parser to apply. If both parsers succeed, this parser's result will be the second element of both 's result.","title":"Parameters"},{"location":"parsers/bothb/#success","text":"Succeeds if both p1 and p2 succeed. Returns the result of p1 .","title":"Success"},{"location":"parsers/bothb/#failure","text":"Fails if either p1 or p2 fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/bothb/#fatal-failure","text":"Fails fatally if either p1 or p2 fails fatally.","title":"Fatal Failure"},{"location":"parsers/bothb/#throws","text":"Throws an error if either p1 or p2 are not parsers.","title":"Throws"},{"location":"parsers/bothb/#see-also","text":"both leftB rightB sequenceB","title":"See Also"},{"location":"parsers/chain/","text":"chain(p, fn) const parser = chain ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Applies a parser to the input, passes its result to a function, and then applies the parser that function returns to the input. In the example, chain first applies any , which returns the next character of the input. fn then returns char(c) , where c is the result of the any application, and this parser is applied. The upshot is that this example of chain succeeds if the next two characters are the same. In the case of f , chain fails fatally. This is because a character was consumed in p 's success, and if a character is consumed before failure, fatal failure is the result. There is another version of this parser ( chainB ) that will backtrack and fail non-fatally if the parser returned by fn fails non-fatally. chain is not used that often itself, but it provides the basis for numerous other parsers (parsers/including all of those in the \"Chaining combinators\" section of the API summary ). Parameters p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input. Success Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn . Failure Fails if p fails. Fsils if the parser returned by fn fails after p succeeds but consumes no input. Fatal Failure Fails fatally if either p or the parser returned by fn fail fatally. Fails fatally if the parser returned by fn fails after p succeeds and consumes some input. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser. See Also chainB map","title":"chain"},{"location":"parsers/chain/#parameters","text":"p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input.","title":"Parameters"},{"location":"parsers/chain/#success","text":"Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn .","title":"Success"},{"location":"parsers/chain/#failure","text":"Fails if p fails. Fsils if the parser returned by fn fails after p succeeds but consumes no input.","title":"Failure"},{"location":"parsers/chain/#fatal-failure","text":"Fails fatally if either p or the parser returned by fn fail fatally. Fails fatally if the parser returned by fn fails after p succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/chain/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser.","title":"Throws"},{"location":"parsers/chain/#see-also","text":"chainB map","title":"See Also"},{"location":"parsers/chainb/","text":"chainB(p, fn) const parser = chainB ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Applies a parser to the input, passes its result to a function, and then applies the parser that function returns to the input. If p succeeds but the parser that is returned by fn fails, the state will backtrack to the location where p was originally applied and chainB will fail non-fatally. Parameters p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input. Success Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn . Failure Fails if either p or the parser returned by fn fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or the parser returned by fn fail fatally. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser. See Also chain","title":"chainB"},{"location":"parsers/chainb/#parameters","text":"p The parser which is applied first and whose result is passed into fn . fn A function which, when passed the result of p , should return a second parser to be applied to the input.","title":"Parameters"},{"location":"parsers/chainb/#success","text":"Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn .","title":"Success"},{"location":"parsers/chainb/#failure","text":"Fails if either p or the parser returned by fn fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/chainb/#fatal-failure","text":"Fails fatally if either p or the parser returned by fn fail fatally.","title":"Fatal Failure"},{"location":"parsers/chainb/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if p succeeds and the value returned by fn is not a parser.","title":"Throws"},{"location":"parsers/chainb/#see-also","text":"chain","title":"See Also"},{"location":"parsers/char/","text":"char(c) const parser = char ( 'a' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected 'a' Reads a single character from input and succeeds if it is c . There is no character type in JavaScript, as a \"character\" is just a string with a length of 1. However, using char is a bit more efficient than using string and should be used as long as only one character is needed. Parameters c The character that the next input character must be in order to succeed. Success Succeeds if the next input character is c . Consumes and returns that character. Failure Fails if the next input character is any other character, including the opposite case version of c . Throws Throws an error if c is not a string or if it isn't exactly one character in length. See Also any charI range string","title":"char"},{"location":"parsers/char/#parameters","text":"c The character that the next input character must be in order to succeed.","title":"Parameters"},{"location":"parsers/char/#success","text":"Succeeds if the next input character is c . Consumes and returns that character.","title":"Success"},{"location":"parsers/char/#failure","text":"Fails if the next input character is any other character, including the opposite case version of c .","title":"Failure"},{"location":"parsers/char/#throws","text":"Throws an error if c is not a string or if it isn't exactly one character in length.","title":"Throws"},{"location":"parsers/char/#see-also","text":"any charI range string","title":"See Also"},{"location":"parsers/chari/","text":"charI(c) const parser = charI ( 'a' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'BCD' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // BCD // ^ // Expected 'a' Reads a single character, succeeding if that character is either c or its opposite case counterpart. Parameters c The character that the next input character must be (of any case) in order to succeed. Success Succeeds if the next input character is either c or its opposite case counterpart. Consumes and returns that character. Failure Fails if the next input character is any other character. Throws Throws an error if c is not a string or if it isn't exactly one character in length. See Also any char stringI","title":"charI"},{"location":"parsers/chari/#parameters","text":"c The character that the next input character must be (of any case) in order to succeed.","title":"Parameters"},{"location":"parsers/chari/#success","text":"Succeeds if the next input character is either c or its opposite case counterpart. Consumes and returns that character.","title":"Success"},{"location":"parsers/chari/#failure","text":"Fails if the next input character is any other character.","title":"Failure"},{"location":"parsers/chari/#throws","text":"Throws an error if c is not a string or if it isn't exactly one character in length.","title":"Throws"},{"location":"parsers/chari/#see-also","text":"any char stringI","title":"See Also"},{"location":"parsers/choice/","text":"choice(...ps) const parser = choice ( left ( letter , digit ), right ( digit , letter )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const r = parse ( parser , '1a' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"a\" const f = parse ( parser , ' a' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Expected a letter or a digit const t = parse ( parser , 'a ' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit or a letter Applies each of its parsers, one at a time, until the first one succeeds, the first one fails fatally, or they all fail. If a parser in ps succeeds, no further parsers will be applied and the result of the successful parser will be returned. If a parser in ps fails fatally, no further parsers will be applied and choice will fail fatally. This rule is necessary to ensure that each branch of the choice is starting from the same state (a fatal failure generally means input is consumed and the state has therefore changed). If all parsers in ps fail, then choice fails as well. The example shows two success cases. In the first one, the application of the first parser ( left(letter, digit) ) succeeds and its result is returned. In the second one, the application of the first parser fails, but the application of the second one ( right(digit, letter) ) succeeds and its result is returned. In the first failure case, both parsers fail but neither consumes any input, so choice fails non-fatally. In the second case, the first parser fails fatally (it consumes a before it fails on the space), so the second parser is never applied and choice fails fatally. Because choice fails immediately if any of its parsers fails fatally, it is quite common to wrap its parsers in attempt to turn their fatal failures into non-fatal failures. Take care in doing this, as backtracking can erase useful error information. Parameters ...ps The parsers to apply one at a time until one succeeds. Success Succeeds if any parser in ps succeeds. Its result is returned. Failure Fails if every parser in ps fails. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws if any member of ps is not a parser. See Also attempt sequence","title":"choice"},{"location":"parsers/choice/#parameters","text":"...ps The parsers to apply one at a time until one succeeds.","title":"Parameters"},{"location":"parsers/choice/#success","text":"Succeeds if any parser in ps succeeds. Its result is returned.","title":"Success"},{"location":"parsers/choice/#failure","text":"Fails if every parser in ps fails.","title":"Failure"},{"location":"parsers/choice/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/choice/#throws","text":"Throws if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/choice/#see-also","text":"attempt sequence","title":"See Also"},{"location":"parsers/digit/","text":"digit const parser = digit const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a digit Reads a character and succeeds if it is a decimal digit ( 0-9 ). Note that this parses ASCII digits, not UTF-8 digits in general. For that, use regex(/^\\p{Nd}/u) . Success Succeeds if the next character is a decimal digit ( 0-9 ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also hex octal","title":"digit"},{"location":"parsers/digit/#success","text":"Succeeds if the next character is a decimal digit ( 0-9 ). Consumes and returns that character.","title":"Success"},{"location":"parsers/digit/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/digit/#see-also","text":"hex octal","title":"See Also"},{"location":"parsers/eof/","text":"eof const parser = eof const s = parse ( parser , '' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected end of input Attempts to read a character and succeeds if there is no character to read. The only time that there is no character to read is at the end of input, so this parser checks specifically for that condition. Success Succeeds if the current parse location is at the end of input. Returns nothing and consumes no input. Failure Fails if there is any character left to read. See Also all","title":"eof"},{"location":"parsers/eof/#success","text":"Succeeds if the current parse location is at the end of input. Returns nothing and consumes no input.","title":"Success"},{"location":"parsers/eof/#failure","text":"Fails if there is any character left to read.","title":"Failure"},{"location":"parsers/eof/#see-also","text":"all","title":"See Also"},{"location":"parsers/fail/","text":"fail(msg) const parser = fail ( 'a letter' ) const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Fails automatically, applying a custom expected error message. Parameters msg The expected error message to apply. Failure Always fails. The failure message will be expected(msg) . Throws Throws an error if msg is not a string. See Also failFatally failUnexpected","title":"fail"},{"location":"parsers/fail/#parameters","text":"msg The expected error message to apply.","title":"Parameters"},{"location":"parsers/fail/#failure","text":"Always fails. The failure message will be expected(msg) .","title":"Failure"},{"location":"parsers/fail/#throws","text":"Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/fail/#see-also","text":"failFatally failUnexpected","title":"See Also"},{"location":"parsers/failfatally/","text":"failFatally(msg) const parser = failFatally ( 'a letter' ) const t = parse ( parser , '123' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Fails automatically, applying a custom expected error message. Parameters msg The expected error message to apply. Fatal Failure Always fails fatally. The failure message will be expected(msg) . No input is consumed. Throws Throws an error if msg is not a string. See Also fail failUnexpected","title":"failFatally"},{"location":"parsers/failfatally/#parameters","text":"msg The expected error message to apply.","title":"Parameters"},{"location":"parsers/failfatally/#fatal-failure","text":"Always fails fatally. The failure message will be expected(msg) . No input is consumed.","title":"Fatal Failure"},{"location":"parsers/failfatally/#throws","text":"Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/failfatally/#see-also","text":"fail failUnexpected","title":"See Also"},{"location":"parsers/failunexpected/","text":"failUnexpected(msg) const parser = failUnexpected ( 'digit' ) const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Unexpected digit Fails automatically, applying a custom unexpected error message. Parameters msg The unexpected error message to apply. Failure Always fails. The failure message will be unexpected(msg) . Throws Throws an error if msg is not a string. See Also fail failFatally","title":"failUnexpected"},{"location":"parsers/failunexpected/#parameters","text":"msg The unexpected error message to apply.","title":"Parameters"},{"location":"parsers/failunexpected/#failure","text":"Always fails. The failure message will be unexpected(msg) .","title":"Failure"},{"location":"parsers/failunexpected/#throws","text":"Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/failunexpected/#see-also","text":"fail failFatally","title":"See Also"},{"location":"parsers/fifth/","text":"fifth(p) const parser = fifth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"5\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Applies a parser and returns the fifth element of the resulting array. This parser works only if p returns an array, and it returns the fifth element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. fifth(p) is an optimized implementation of chain(p, x => always(x[4])) . Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the fifth element of the array that p returns. If there are not at least five elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also first fourth nth second third","title":"fifth"},{"location":"parsers/fifth/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/fifth/#success","text":"Succeeds if p succeeds. Returns the fifth element of the array that p returns. If there are not at least five elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/fifth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/fifth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/fifth/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/fifth/#see-also","text":"first fourth nth second third","title":"See Also"},{"location":"parsers/first/","text":"first(p) const parser = first ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Applies a parser and returns the first element of the resulting array. This parser works only if p returns an array, and it returns the first element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. first(p) is an optimized implementation of chain(p, x => always(x[0])) . Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the first element of the array that p returns. If there is not at least one element in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth fourth nth second third","title":"first"},{"location":"parsers/first/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/first/#success","text":"Succeeds if p succeeds. Returns the first element of the array that p returns. If there is not at least one element in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/first/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/first/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/first/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/first/#see-also","text":"fifth fourth nth second third","title":"See Also"},{"location":"parsers/followedby/","text":"followedBy(p) const parser = followedBy ( digit ) const s = parse ( parser , '1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'a' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Unknown message(s) Applies a parser and succeeds without consuming input if that parser succeeds. This parser is similar to lookAhead except that it does not produce a result. followedBy does not produce an error message on failure. It could, but other related parsers like notEmpty and notFollowedBy cannot, so the choice was made to make followedBy consistent with those parsers. To add an error message, either wrap this parser in label or use followedByM instead. Parameters p The parser to apply. If it succeeds, followedBy succeeds. Success Succeeds if p succeeds. Does not consume input or return a result. Failure Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case. Throws Throws an error if p is not a parser. See Also followedByM label lookAhead notEmpty notFollowedBy","title":"followedBy"},{"location":"parsers/followedby/#parameters","text":"p The parser to apply. If it succeeds, followedBy succeeds.","title":"Parameters"},{"location":"parsers/followedby/#success","text":"Succeeds if p succeeds. Does not consume input or return a result.","title":"Success"},{"location":"parsers/followedby/#failure","text":"Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case.","title":"Failure"},{"location":"parsers/followedby/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/followedby/#see-also","text":"followedByM label lookAhead notEmpty notFollowedBy","title":"See Also"},{"location":"parsers/followedbym/","text":"followedByM(p, msg) const parser = followedByM ( digit , 'a digit' ) const s = parse ( parser , '1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'a' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit Applies a parser and succeeds without consuming input if that parser succeeds. This parser is similar to lookAhead except that it does not produce a result. If followedByM fails, it will add a expected(msg) as an error message. Parameters p The parser to apply. If it succeeds, followedBy succeeds. msg The expected error message to use on failure. Success Succeeds if p succeeds. Does not consume input or return a result. Failure Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also followedBy lookAhead notEmptyM notFollowedByM","title":"followedByM"},{"location":"parsers/followedbym/#parameters","text":"p The parser to apply. If it succeeds, followedBy succeeds. msg The expected error message to use on failure.","title":"Parameters"},{"location":"parsers/followedbym/#success","text":"Succeeds if p succeeds. Does not consume input or return a result.","title":"Success"},{"location":"parsers/followedbym/#failure","text":"Fails if p fails or fails fatally. No input is consumed and the state is not changed in either case.","title":"Failure"},{"location":"parsers/followedbym/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/followedbym/#see-also","text":"followedBy lookAhead notEmptyM notFollowedByM","title":"See Also"},{"location":"parsers/fourth/","text":"fourth(p) const parser = fourth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Applies a parser and returns the fourth element of the resulting array. This parser works only if p returns an array, and it returns the fourth element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. fourth(p) is an optimized implementation of chain(p, x => always(x[3])) . Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the fourth element of the array that p returns. If there are not at least four elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth first nth second third","title":"fourth"},{"location":"parsers/fourth/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/fourth/#success","text":"Succeeds if p succeeds. Returns the fourth element of the array that p returns. If there are not at least four elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/fourth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/fourth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/fourth/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/fourth/#see-also","text":"fifth first nth second third","title":"See Also"},{"location":"parsers/hex/","text":"hex const parser = hex const s = parse ( parser , 'cafe' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"c\" const f = parse ( parser , 'xyz' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // xyz // ^ // Expected a hexadecimal digit Reads a character and succeeds if that character is a hexadecimal digit ( 0-9 , a-f , or A-F ). Success Succeeds if the next character is a hexadecimal digit ( 0-9 , a-f , or A-F ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also digit octal","title":"hex"},{"location":"parsers/hex/#success","text":"Succeeds if the next character is a hexadecimal digit ( 0-9 , a-f , or A-F ). Consumes and returns that character.","title":"Success"},{"location":"parsers/hex/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/hex/#see-also","text":"digit octal","title":"See Also"},{"location":"parsers/join/","text":"join(p) const parser = join ( many1 ( any )) const s = parse ( parser , 'abcde' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"abcde\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character Applies a parser and returns the elements of the resulting array into a string. This combinator solves the problem in JavaScript that there is no separate character type, and therefore a string is not just a list/array of characters. (parsers/Parsec parsers, for example, can return arrays of characters which Haskell regards also as strings in their own right.) Parsers like sequence and many return arrays, and often they are arrays of single-character strings. join will turn these results into simple strings. join(p) is an optimized implementation of chain(p, x => x.join('')) . Parameters p The parser that is applied, which must return an array. Success Succeeds if p succeeds. Returns the resulting array's elements joined into a string. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also map","title":"join"},{"location":"parsers/join/#parameters","text":"p The parser that is applied, which must return an array.","title":"Parameters"},{"location":"parsers/join/#success","text":"Succeeds if p succeeds. Returns the resulting array's elements joined into a string.","title":"Success"},{"location":"parsers/join/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/join/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/join/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/join/#see-also","text":"map","title":"See Also"},{"location":"parsers/label/","text":"label(p, msg) const parser = label ( choice ( upper , lower , digit ), 'an alphanumeric character' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , ' abc ' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an alphanumeric character Applies a parser and overwrites its error message on failure. label does nothing except pass the result along if its parser consumes any input (parsers/typically, but not always, if it succeeds or fails fatally). If it does not consume input, it replaces whatever error message was generated with expected(msg) . This is typically used to clarify error messages, especially in parsers like choice that might have many branches with their own error messages. For instance, if choice(upper, lower, digit.md) in the example was not wrapped with label , its expected error message would be \"Expected an uppercase letter, a lowercase letter, or a digit\" . label is used to consolidate that message into \"Expected an alphanumeric character\" . Parameters p The parser to apply. If it does not consume any input, its error message will be changed. msg The error message for when p does not consume input. Success Succeeds if p succeeds. Returns the result of p . Failure Fails if p fails. In this case, the error message generated by p will be replaced with msg . Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also backLabel choice followedBy notEmpty notFollowedBy satisfy","title":"label"},{"location":"parsers/label/#parameters","text":"p The parser to apply. If it does not consume any input, its error message will be changed. msg The error message for when p does not consume input.","title":"Parameters"},{"location":"parsers/label/#success","text":"Succeeds if p succeeds. Returns the result of p .","title":"Success"},{"location":"parsers/label/#failure","text":"Fails if p fails. In this case, the error message generated by p will be replaced with msg .","title":"Failure"},{"location":"parsers/label/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/label/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/label/#see-also","text":"backLabel choice followedBy notEmpty notFollowedBy satisfy","title":"See Also"},{"location":"parsers/left/","text":"left(p1, p2) const parser = left ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies two parsers in order, returning the result of the first one. The result of the second parser is discarded. If either parser fails, then the entire left parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p1 or p2 failed fatally). In the examples, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. There is another version of this parser ( leftB ) that will backtrack and fail non-fatally if p1 succeeds and p2 fails non-fatally. left(p1, p2) is an optimized implementation of chain(p1, x => value(p2, x)) . Parameters p1 The first parser to apply. If both parsers succeed, this parser's result will be left 's result. p2 The second parser to apply. This parser's result will be discarded. Success Succeeds if both p1 and p2 succeed. Returns the result of p1 . Failure Fails if p1 fails. Fails if p2 fails after p1 succeeds but does not consume input. Fatal Failure Fails fatally if either p1 or p2 fail fatally. Fails fatally if p2 fails after p1 succeds and consumes some input. Throws Throws an error if either p1 or p2 are not parsers. See Also both leftB right sequence","title":"left"},{"location":"parsers/left/#parameters","text":"p1 The first parser to apply. If both parsers succeed, this parser's result will be left 's result. p2 The second parser to apply. This parser's result will be discarded.","title":"Parameters"},{"location":"parsers/left/#success","text":"Succeeds if both p1 and p2 succeed. Returns the result of p1 .","title":"Success"},{"location":"parsers/left/#failure","text":"Fails if p1 fails. Fails if p2 fails after p1 succeeds but does not consume input.","title":"Failure"},{"location":"parsers/left/#fatal-failure","text":"Fails fatally if either p1 or p2 fail fatally. Fails fatally if p2 fails after p1 succeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/left/#throws","text":"Throws an error if either p1 or p2 are not parsers.","title":"Throws"},{"location":"parsers/left/#see-also","text":"both leftB right sequence","title":"See Also"},{"location":"parsers/leftb/","text":"leftB(p1, p2) const parser = leftB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies two parsers in order, returning the result of the first one. The result of the second parser is discarded. If either parser fails, then the entire leftB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p1 was applied. Parameters p1 The first parser to apply. If both parsers succeed, this parser's result will be leftB 's result. p2 The second parser to apply. This parser's result will be discarded. Success Succeeds if both p1 and p2 succeed. Returns the result of p1 . Failure Fails if either p1 or p2 fail. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p1 or p2 fail fatally. Throws Throws an error if either p1 or p2 are not parsers. See Also bothB left rightB sequenceB","title":"leftB"},{"location":"parsers/leftb/#parameters","text":"p1 The first parser to apply. If both parsers succeed, this parser's result will be leftB 's result. p2 The second parser to apply. This parser's result will be discarded.","title":"Parameters"},{"location":"parsers/leftb/#success","text":"Succeeds if both p1 and p2 succeed. Returns the result of p1 .","title":"Success"},{"location":"parsers/leftb/#failure","text":"Fails if either p1 or p2 fail. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/leftb/#fatal-failure","text":"Fails fatally if either p1 or p2 fail fatally.","title":"Fatal Failure"},{"location":"parsers/leftb/#throws","text":"Throws an error if either p1 or p2 are not parsers.","title":"Throws"},{"location":"parsers/leftb/#see-also","text":"bothB left rightB sequenceB","title":"See Also"},{"location":"parsers/letter/","text":"letter const parser = letter const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Reads the next character and succeeds if that character is an ASCII letter ( a-z or A-Z ). This does not parse UTF-8 letters in general. Use letterU for that. Success Succeeds if the next character is an ASCII letter ( a-z or A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letterU lower upper","title":"letter"},{"location":"parsers/letter/#success","text":"Succeeds if the next character is an ASCII letter ( a-z or A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/letter/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/letter/#see-also","text":"alpha letterU lower upper","title":"See Also"},{"location":"parsers/letteru/","text":"letterU const parser = letterU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a Unicode letter Reads the next character and succeeds if that character is a Unicode letter. A character is a Unicode letter if it has the Unicode Alphabetic binary property. Success Succeeds if the next character is a Unicode letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letter lowerU upperU","title":"letterU"},{"location":"parsers/letteru/#success","text":"Succeeds if the next character is a Unicode letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/letteru/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/letteru/#see-also","text":"alphaU letter lowerU upperU","title":"See Also"},{"location":"parsers/lookahead/","text":"lookAhead(p) const parser = lookAhead ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(ok) console . log ( success ( f )) // null Applies a parser and returns its result on success, but does not consume input. This parser allows for peeking ahead to see what characters are coming up without actually consuming those characters. It's common to see it in block parsers to drive logic that determines which parser gets applied based on the next character. lookAhead is very similar to optional . The difference is that optional consumes input on success where lookAhead does not. Parameters p The parser to apply without consuming input. If p succeeds, its result will be returned. Success Succeeds as long as p does not fail fatally. If p succeeds, its result is returned. If p fails, nothing is returned. In either case, no input is consumed. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also block optional","title":"lookAhead"},{"location":"parsers/lookahead/#parameters","text":"p The parser to apply without consuming input. If p succeeds, its result will be returned.","title":"Parameters"},{"location":"parsers/lookahead/#success","text":"Succeeds as long as p does not fail fatally. If p succeeds, its result is returned. If p fails, nothing is returned. In either case, no input is consumed.","title":"Success"},{"location":"parsers/lookahead/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/lookahead/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/lookahead/#see-also","text":"block optional","title":"See Also"},{"location":"parsers/lower/","text":"lower const parser = lower const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter Reads the next character and succeeds if that character is an ASCII lowercase letter ( a-z ). This does not parse UTF-8 lowercase letters in general. Use lowerU for that. Success Succeeds if the next character is an ASCII lowercase letter ( a-z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letter lowerU upper","title":"lower"},{"location":"parsers/lower/#success","text":"Succeeds if the next character is an ASCII lowercase letter ( a-z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/lower/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/lower/#see-also","text":"alpha letter lowerU upper","title":"See Also"},{"location":"parsers/loweru/","text":"lowerU const parser = lowerU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0410\u0411\u0412 // ^ // Expected a Unicode lowercase letter Reads the next character and succeeds if that character is a Unicode lowercase letter. A character is a Unicode lowercase letter if it has the Unicode Lowercase . This is approximately equal to characters that match the regular expression /\\p{Ll}/u but includes a few other characters as well. Success Succeeds if the next character is a Unicode lowercase letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letterU lower upperU","title":"lowerU"},{"location":"parsers/loweru/#success","text":"Succeeds if the next character is a Unicode lowercase letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/loweru/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/loweru/#see-also","text":"alphaU letterU lower upperU","title":"See Also"},{"location":"parsers/many/","text":"many(p) const parser = many ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\"] const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter Applies a parser as many times as possible until it fails, collecting the results into a resulting array. many executes a parser zero or more times, as long as it continues to succeed. The operation of the parser in EBNF is p* . When the parser fails, that does not mean that many fails; that signals that many is through executing and the successful results up to that point are returned. The failure case in the example shows the only way that many can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes many to fail. many does not fail from non-fatal failures of its parser. Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p does not fail fatally. Returns the results that p had before failing in an array. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many1 skipMany","title":"many"},{"location":"parsers/many/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/many/#success","text":"Succeeds if p does not fail fatally. Returns the results that p had before failing in an array.","title":"Success"},{"location":"parsers/many/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/many/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/many/#see-also","text":"many1 skipMany","title":"See Also"},{"location":"parsers/many1/","text":"many1(p) const parser = many1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\"] const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter Applies a parser as many times as possible until it fails, collecting the results into a resulting array. many1 executes a parser one or more times, as long as it continues to succeed. The operation of the parser in EBNF is p+ . When the parser fails, that does not mean that many1 fails (as long as the parser succeeded at least once); that signals that many1 is through executing and the successful results up to that point are returned. As long as p succeeds at least once, the only way many1 can fail is if p fails fatally. Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p succeeds at least once and does not fail fatally. Returns the results that p had before failing in an array. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many skipMany1","title":"many1"},{"location":"parsers/many1/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/many1/#success","text":"Succeeds if p succeeds at least once and does not fail fatally. Returns the results that p had before failing in an array.","title":"Success"},{"location":"parsers/many1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/many1/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/many1/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/many1/#see-also","text":"many skipMany1","title":"See Also"},{"location":"parsers/manytill/","text":"manyTill(p, pend) const parser = manyTill ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter Applies a content parser zero or more times as long as an end parser continues to fail. Once the end parser succeeds, the content parser's successes are collected into an array and returned. This parser differs from between in that the pend parser is applied first ; because of this, there is no possibility of content parser p consuming whatever pend is supposed to match and thereby causing the combinator to fail. The operation of this parser in EBNF is (!pend p)* pend . Parameters p The content parser. After pend succeeds, the prior results of this parser are returned as an array. pend The end parser. p will continue to be applied until pend succeeds. Its result is discarded. Success Succeeds as long as pend succeeds before p fails. Returns the results of p as an array. If pend succeeds on the first attempt, p is never applied and the returned array is empty. Failure Fails if p and pend both fail initially. Fails if p fails before pend succeeds and prior successes from p did not consume any input. Fatal Failure Fails fatally if either p or pend fail fatally. Fails fatally if p fails before pend succeeds and prior successes from p consumed some input. Throws Throws an error if either p or pend are not parsers. See Also between `manyTillB sequence","title":"manyTill"},{"location":"parsers/manytill/#parameters","text":"p The content parser. After pend succeeds, the prior results of this parser are returned as an array. pend The end parser. p will continue to be applied until pend succeeds. Its result is discarded.","title":"Parameters"},{"location":"parsers/manytill/#success","text":"Succeeds as long as pend succeeds before p fails. Returns the results of p as an array. If pend succeeds on the first attempt, p is never applied and the returned array is empty.","title":"Success"},{"location":"parsers/manytill/#failure","text":"Fails if p and pend both fail initially. Fails if p fails before pend succeeds and prior successes from p did not consume any input.","title":"Failure"},{"location":"parsers/manytill/#fatal-failure","text":"Fails fatally if either p or pend fail fatally. Fails fatally if p fails before pend succeeds and prior successes from p consumed some input.","title":"Fatal Failure"},{"location":"parsers/manytill/#throws","text":"Throws an error if either p or pend are not parsers.","title":"Throws"},{"location":"parsers/manytill/#see-also","text":"between `manyTillB sequence","title":"See Also"},{"location":"parsers/manytillb/","text":"manyTillB(p, pend) const parser = manyTillB ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab12> // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter Applies a content parser zero or more times as long as an end parser continues to fail. Once the end parser succeeds, the content parser's successes are collected into an array and returned. This parser differs from betweenB in that the pend parser is applied first ; because of this, there is no possibility of content parser p consuming whatever pend is supposed to match and thereby causing the combinator to fail. If p fails before pend succeeds and input was consumed, the state will backtrack to where it was before p was applied the first time. Parameters p The content parser. After pend succeeds, the prior results of this parser are returned as an array. pend The end parser. p will continue to be applied until pend succeeds. Its result is discarded. Success Succeeds as long as pend succeeds before p fails. Returns the results of p as an array. If pend succeeds on the first attempt, p is never applied and the returned array is empty. Failure Fails if p fails before pend succeeds. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or pend fail fatally. Throws Throws an error if either p or pend are not parsers. See Also betweenB manyTillB sequenceB","title":"manyTillB"},{"location":"parsers/manytillb/#parameters","text":"p The content parser. After pend succeeds, the prior results of this parser are returned as an array. pend The end parser. p will continue to be applied until pend succeeds. Its result is discarded.","title":"Parameters"},{"location":"parsers/manytillb/#success","text":"Succeeds as long as pend succeeds before p fails. Returns the results of p as an array. If pend succeeds on the first attempt, p is never applied and the returned array is empty.","title":"Success"},{"location":"parsers/manytillb/#failure","text":"Fails if p fails before pend succeeds. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/manytillb/#fatal-failure","text":"Fails fatally if either p or pend fail fatally.","title":"Fatal Failure"},{"location":"parsers/manytillb/#throws","text":"Throws an error if either p or pend are not parsers.","title":"Throws"},{"location":"parsers/manytillb/#see-also","text":"betweenB manyTillB sequenceB","title":"See Also"},{"location":"parsers/map/","text":"map(p, fn) const parser = map ( lower , c => c . toUpperCase ()) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter Applies a parser and returns the value that a function returns when passed the parser's result. In the example, a lower parser is used to read a lowercase letter. That character is passed into a function that uppercases it, then that uppercase letter is returned. fn can return anything, so map is one of the few combinators that can return something other than a string. map(p, fn) is an optimized implementation of chain(p, x => always(fn(x))) . Parameters p A parser to apply to the input. fn A function of one argument which gets passed the result of p . Its return value becomes map 's result. Success Succeeds if p succeeds. Returns the value that fn returns when passed the result of p . Failure Fails if p fails. In this case fn is never invoked. Fatal Failure Fails fatally if p fails fatally. In this case fn is never invoked. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. See Also chain join pipe","title":"map"},{"location":"parsers/map/#parameters","text":"p A parser to apply to the input. fn A function of one argument which gets passed the result of p . Its return value becomes map 's result.","title":"Parameters"},{"location":"parsers/map/#success","text":"Succeeds if p succeeds. Returns the value that fn returns when passed the result of p .","title":"Success"},{"location":"parsers/map/#failure","text":"Fails if p fails. In this case fn is never invoked.","title":"Failure"},{"location":"parsers/map/#fatal-failure","text":"Fails fatally if p fails fatally. In this case fn is never invoked.","title":"Fatal Failure"},{"location":"parsers/map/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function.","title":"Throws"},{"location":"parsers/map/#see-also","text":"chain join pipe","title":"See Also"},{"location":"parsers/newline/","text":"newline const parser = newline const s = parse ( parser , '\\r\\nNext line' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\\r\\n\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a newline Reads a character (or two, if the first character is \\r ) and succeeds if it is an ASCII newline. ASCII newlines include \\r , \\n , and \\r\\n . Success Succeeds if the next character is either \\r or \\n , or if the next two characters are \\r\\n . This character (or these characters) are consumed and returned as a single string. Failure Fails if the next character is any other character. See Also newlineU space spaces spaces1","title":"newline"},{"location":"parsers/newline/#success","text":"Succeeds if the next character is either \\r or \\n , or if the next two characters are \\r\\n . This character (or these characters) are consumed and returned as a single string.","title":"Success"},{"location":"parsers/newline/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/newline/#see-also","text":"newlineU space spaces spaces1","title":"See Also"},{"location":"parsers/newlineu/","text":"newlineU const parser = newlineU const s = parse ( parser , '\\u2028Next line' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"\\u2028\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode newline Reads a character (or two, if the first character is \\r ) and succeeds if it is a Unicode newline. Unicode newlines include the ASCII newlines \\r , \\n , and \\r\\n , as well as the characters \"next line\" ( \\u0085 ), \"line separator\" ( \\u2028 ), and \"paragraph separator\" ( \\u2029 ). Success Succeeds if the next character (or two characters, for \\r\\n ) is a Unicode newline. This character (or these characters) are consumed and returned as a single string. Failure Fails if the next character is any other character. See Also newline spacesU spaces1U spaceU","title":"newlineU"},{"location":"parsers/newlineu/#success","text":"Succeeds if the next character (or two characters, for \\r\\n ) is a Unicode newline. This character (or these characters) are consumed and returned as a single string.","title":"Success"},{"location":"parsers/newlineu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/newlineu/#see-also","text":"newline spacesU spaces1U spaceU","title":"See Also"},{"location":"parsers/noneof/","text":"noneOf(cs) const parser = noneOf ( 'Test' ) const s = parse ( parser , 'Exit' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"E\" const f = parse ( parser , 'Test' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Test // ^ // Expected none of 'T', 'e', 's', or 't' Reads a single character and succeeds if that character is not included in cs . Parameters cs The set of characters that the next character is excluded from being a part of. This can be either a string or an array of single-character strings. Success Succeeds if the next character is not one of the characters in cs . Consumes and returns that character. Failure Fails if the next character is any character in cs . Throws Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length. See Also anyOf","title":"noneOf"},{"location":"parsers/noneof/#parameters","text":"cs The set of characters that the next character is excluded from being a part of. This can be either a string or an array of single-character strings.","title":"Parameters"},{"location":"parsers/noneof/#success","text":"Succeeds if the next character is not one of the characters in cs . Consumes and returns that character.","title":"Success"},{"location":"parsers/noneof/#failure","text":"Fails if the next character is any character in cs .","title":"Failure"},{"location":"parsers/noneof/#throws","text":"Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length.","title":"Throws"},{"location":"parsers/noneof/#see-also","text":"anyOf","title":"See Also"},{"location":"parsers/notempty/","text":"notEmpty(p) const parser = notEmpty ( optional ( char ( '+' ))) const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Unknown error(s) Applies a parser and succeeds if that parser succeeds and returns a result. If the parser does not return a result, notEmpty will fail. This parser cannot produce a useful error message. To provide a custom message, either wrap the parser with label or use notEmptyM . notEmpty can be used to require at least one match from a parser. For example, many1(p) could be naively implemented as notEmpty(many(p)). , though it would not have a good error message. Parameters p The parser to be applied. notEmpty fails if this p succeeds but produces no result. Success Succeeds if p succeeds and returns a result. That result is returned. Failure Fails if p fails. Fails if p succeeds but does not return a result. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also followedBy label notEmptyM notFollowedBy","title":"notEmpty"},{"location":"parsers/notempty/#parameters","text":"p The parser to be applied. notEmpty fails if this p succeeds but produces no result.","title":"Parameters"},{"location":"parsers/notempty/#success","text":"Succeeds if p succeeds and returns a result. That result is returned.","title":"Success"},{"location":"parsers/notempty/#failure","text":"Fails if p fails. Fails if p succeeds but does not return a result.","title":"Failure"},{"location":"parsers/notempty/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/notempty/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/notempty/#see-also","text":"followedBy label notEmptyM notFollowedBy","title":"See Also"},{"location":"parsers/notemptym/","text":"notEmptyM(p, msg) const parser = notEmpty ( optional ( char ( '+' )), 'something other than +' ) const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Expected something other than + Applies a parser and succeeds if that parser succeeds and returns a result. If the parser does not return a result, notEmpty will fail. If this parser fails, it will use expected(msg) as an error message. Parameters p The parser to be applied. notEmpty fails if this p succeeds but produces no result. msg The expected error message to use on failure. Success Succeeds if p succeeds and returns a result. That result is returned. Failure Fails if p fails. Fails if p succeeds but does not return a result. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also followedByM notEmpty notFollowedByM","title":"notEmptyM"},{"location":"parsers/notemptym/#parameters","text":"p The parser to be applied. notEmpty fails if this p succeeds but produces no result. msg The expected error message to use on failure.","title":"Parameters"},{"location":"parsers/notemptym/#success","text":"Succeeds if p succeeds and returns a result. That result is returned.","title":"Success"},{"location":"parsers/notemptym/#failure","text":"Fails if p fails. Fails if p succeeds but does not return a result.","title":"Failure"},{"location":"parsers/notemptym/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/notemptym/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/notemptym/#see-also","text":"followedByM notEmpty notFollowedByM","title":"See Also"},{"location":"parsers/notfollowedby/","text":"notFollowedBy(p) const parser = notFollowedBy ( digit ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Unknown message(s) Applies a parser and succeeds without consuming input if that parser fails. notFollowedBy cannot feasibly produce an error message on failure. To add an error message, either wrap this parser in label or use notFollowedByM instead. Parameters p The parser to apply. If it fails, notFollowedBy succeeds. Success Succeeds if p fails or fails fatally. Does not consume input or return a result. Failure Fails if p succeeds. No input is consumed and the state is not changed. Throws Throws an error if p is not a parser. See Also followedBy label notEmpty notFollowedByM","title":"notFollowedBy"},{"location":"parsers/notfollowedby/#parameters","text":"p The parser to apply. If it fails, notFollowedBy succeeds.","title":"Parameters"},{"location":"parsers/notfollowedby/#success","text":"Succeeds if p fails or fails fatally. Does not consume input or return a result.","title":"Success"},{"location":"parsers/notfollowedby/#failure","text":"Fails if p succeeds. No input is consumed and the state is not changed.","title":"Failure"},{"location":"parsers/notfollowedby/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/notfollowedby/#see-also","text":"followedBy label notEmpty notFollowedByM","title":"See Also"},{"location":"parsers/notfollowedbym/","text":"notFollowedByM(p, msg) const parser = notFollowedByM ( digit , 'something other than a digit' ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Expected something other than a digit Applies a parser and succeeds without consuming input if that parser fails. If this parser fails, it will add expected(msg) as an error message. Parameters p The parser to apply. If it fails, notFollowedBy succeeds. msg The expected error message to use on failure. Success Succeeds if p fails or fails fatally. Does not consume input or return a result. Failure Fails if p succeeds. No input is consumed and the state is not changed. Throws Throws an error if p is not a parser. Throws an error if msg is not a string. See Also followedByM notEmptyM notFollowedBy","title":"notFollowedByM"},{"location":"parsers/notfollowedbym/#parameters","text":"p The parser to apply. If it fails, notFollowedBy succeeds. msg The expected error message to use on failure.","title":"Parameters"},{"location":"parsers/notfollowedbym/#success","text":"Succeeds if p fails or fails fatally. Does not consume input or return a result.","title":"Success"},{"location":"parsers/notfollowedbym/#failure","text":"Fails if p succeeds. No input is consumed and the state is not changed.","title":"Failure"},{"location":"parsers/notfollowedbym/#throws","text":"Throws an error if p is not a parser. Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/notfollowedbym/#see-also","text":"followedByM notEmptyM notFollowedBy","title":"See Also"},{"location":"parsers/nth/","text":"nth(p, n) const parser = nth ( many1 ( any ), 3 ) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Applies a parser and returns a given element of the resulting array. This parser works only if p returns an array, and it returns the n th (parsers/0-based) element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. nth(p, n) is an optimized implementation of chain(p, x => always(x[n])) . Parameters p The parser to apply. This parser should return an array. n The 0-based index of the element from p 's result that should be returned. Success Succeeds if p succeeds. Returns the element of the array that p returns with the index n . If there are not n + 1 elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if p succeeds but does not return an array. See Also fifth first fourth second third","title":"nth"},{"location":"parsers/nth/#parameters","text":"p The parser to apply. This parser should return an array. n The 0-based index of the element from p 's result that should be returned.","title":"Parameters"},{"location":"parsers/nth/#success","text":"Succeeds if p succeeds. Returns the element of the array that p returns with the index n . If there are not n + 1 elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/nth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/nth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/nth/#throws","text":"Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/nth/#see-also","text":"fifth first fourth second third","title":"See Also"},{"location":"parsers/octal/","text":"octal const parser = octal const s = parse ( parser , '123' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '890' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 890 // ^ // Expected an octal digit Reads the next character and succeeds if that character is an octal digit ( 0-7 ). Success Succeeds if the next character is an octal digit ( 0-7 ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also digit hex","title":"octal"},{"location":"parsers/octal/#success","text":"Succeeds if the next character is an octal digit ( 0-7 ). Consumes and returns that character.","title":"Success"},{"location":"parsers/octal/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/octal/#see-also","text":"digit hex","title":"See Also"},{"location":"parsers/optional/","text":"optional(p) const parser = optional ( sequence ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\"] const r = parse ( parser , '1' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // null const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Optionally matches a parser. If this parser succeeds, its result is returned. If it fails, null is returned. optional will only fail (fatally) if its parser fails fatally. A common use case is to skip some optional input; in this case, optional can be wrapped in skip , it can be placed in a position in another combinator where its output is ignored (such as left 's second parser.md), or its output can simply not be used. Parameters p The parser that gets applied. Success Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, optional still succeeds, but it returns nothing ( null ). Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also lookAhead orValue skip","title":"optional"},{"location":"parsers/optional/#parameters","text":"p The parser that gets applied.","title":"Parameters"},{"location":"parsers/optional/#success","text":"Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, optional still succeeds, but it returns nothing ( null ).","title":"Success"},{"location":"parsers/optional/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/optional/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/optional/#see-also","text":"lookAhead orValue skip","title":"See Also"},{"location":"parsers/orvalue/","text":"orValue(p, x) const parser = orValue ( join ( sequence ( letter , digit )), 'Z0' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"a1\" const r = parse ( parser , '12' ) console . log ( status ( r )) // Symbol(ok) console . log ( success ( r )) // \"Z0\" const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies a parser and returns its result on success or an arbitrary value on failure. The only way orValue can fail is if its parser fails fatally. For this reason, a common use case is to wrap the parser in attempt to ensure that the default value is always returned on any kind of failure. Take care when doing this, as backtracking can erase important error information. x can be a value of any type, so this becomes one of the small number of combinators that can return results that are not strings or arrays of strings. Parameters p The parser that gets applied. If it succeeds, its result is returned. x An arbitrary value that is returned if p fails. Success Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, x is returned. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also attempt optional","title":"orValue"},{"location":"parsers/orvalue/#parameters","text":"p The parser that gets applied. If it succeeds, its result is returned. x An arbitrary value that is returned if p fails.","title":"Parameters"},{"location":"parsers/orvalue/#success","text":"Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, x is returned.","title":"Success"},{"location":"parsers/orvalue/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/orvalue/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/orvalue/#see-also","text":"attempt optional","title":"See Also"},{"location":"parsers/pipe/","text":"pipe(...ps, fn) const parser = pipe ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter Applies some parsers in order, then returns the result of a function to which all of the parser results have been passed. fn will be passed one argument for every member of ps . JavaScript does not enforce that there has to be a parameter for each passed argument, but likely you will want to provide an fn that has an arity equal to the number of parsers in ps . In the example, the upper and lower parsers are applied, and the results of each are passed to an arity-2 function which lowercases the first argument and uppercases the second. The first failure example ( f ) shows non-fatal failure caused by the first parser failing non-fatally, but the second ( t ) shows a fatal failure caused by a parser ( upper in this case) consuming a character before a later parser fails. Unlike sequence , null parser results are not discarded. This ensures that the same number of arguments will be passed to fn no matter the results of the parsers. There is another version of this parser ( pipeB ) that fails non-fatally and backtracks if the parser that fails does so non-fatally. fn can return anything, so this is one of the few combinators that can return something other than a string. pipe(p1, p2, fn) is an optimized implementation of chain(p1, a => chain(p2, b => always(fn(a, b)))) , pipe(p1, p2, p3, fn) is an optimized implementation of chain(p1, a => chain(p2, b => chain(p3, c => always(fn(a, b, c))))) , and so on. Parameters ...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe . Success Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it. Failure Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the ones before it succeed but do not consume input. Fatal Failure Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after a prior parser succeeds and consumes some input. Throws Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser. See Also map pipeB","title":"pipe"},{"location":"parsers/pipe/#parameters","text":"...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe .","title":"Parameters"},{"location":"parsers/pipe/#success","text":"Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it.","title":"Success"},{"location":"parsers/pipe/#failure","text":"Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the ones before it succeed but do not consume input.","title":"Failure"},{"location":"parsers/pipe/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after a prior parser succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/pipe/#throws","text":"Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser.","title":"Throws"},{"location":"parsers/pipe/#see-also","text":"map pipeB","title":"See Also"},{"location":"parsers/pipeb/","text":"pipeB(...ps, fn) const parser = pipeB ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ABC // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter Applies some parsers in order, then returns the result of a function to which all of the parser results have been passed. fn will be passed one argument for every member of ps . JavaScript does not enforce that there has to be a parameter for each passed argument, but likely you will want to provide an fn that has an arity equal to the number of parsers in ps . If any of the parsers fail, then backtracking will return the state to where it was before the first parser was applied. fn can return anything, so this is one of the few combinators that can return something other than a string. Parameters ...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe . Success Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it. Failure Fails if the any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser. See Also pipe","title":"pipeB"},{"location":"parsers/pipeb/#parameters","text":"...ps Zero or more parsers, each of which is applied to the input in order. fn A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe .","title":"Parameters"},{"location":"parsers/pipeb/#success","text":"Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it.","title":"Success"},{"location":"parsers/pipeb/#failure","text":"Fails if the any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/pipeb/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/pipeb/#throws","text":"Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser.","title":"Throws"},{"location":"parsers/pipeb/#see-also","text":"pipe","title":"See Also"},{"location":"parsers/range/","text":"range(s, e) const parser = range ( '0' , '3' ) const s = parse ( parser , '246' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"2\" const f = parse ( parser , '468' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 468 // ^ // Expected a character between '0' and '3' Reads a single character, succeeding if that character is between s and e inclusive. \"Between\" is defined according to code points. This is fine in most cases, but it can get weird with higher code points. For example, there is no \"h\" in the set of mathematical lowercase italic symbols. The \"h\" that would be used in that set of symbols would instead be the Planck's Constant character, which is in a completely different part of the UTF-8 spectrum and therefore is not \"between\" mathematical lowercase italic symbols a and z . Take care with non-ASCII characters. Parameters s The character representing the lower bound of the range. The next character's code point must be greater than or equal to s 's code point for the parser to succeed. e The character representing the upper bound of the range. The next character's code point must be less than or equal to e 's code point for the parser to succeed. Success Succeeds if the code point of the next character is between the code points of s and e , inclusive. Consumes and returns that character. Failure Fails if the code point of the next character is less than s 's code point or greater than e 's code point. Throws Throws an error if either s or e are not strings or if either is not exactly one character in length. See Also any char regex satisfy","title":"range"},{"location":"parsers/range/#parameters","text":"s The character representing the lower bound of the range. The next character's code point must be greater than or equal to s 's code point for the parser to succeed. e The character representing the upper bound of the range. The next character's code point must be less than or equal to e 's code point for the parser to succeed.","title":"Parameters"},{"location":"parsers/range/#success","text":"Succeeds if the code point of the next character is between the code points of s and e , inclusive. Consumes and returns that character.","title":"Success"},{"location":"parsers/range/#failure","text":"Fails if the code point of the next character is less than s 's code point or greater than e 's code point.","title":"Failure"},{"location":"parsers/range/#throws","text":"Throws an error if either s or e are not strings or if either is not exactly one character in length.","title":"Throws"},{"location":"parsers/range/#see-also","text":"any char regex satisfy","title":"See Also"},{"location":"parsers/regex/","text":"regex(pattern) const parser = regex ( /^\\d+/ ) const s = parse ( parser , '123abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"123\" const f = parse ( parser , 'abc123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc123 // ^ // Expected a string matching /^\\d+/ Matches the current input location against a regular expression pattern. Parameters pattern The regular expression pattern to match against the current input location. This pattern can be either a RegExp object or a string (which is automatically converted into a RegExp object without flags). It will have an ^ anchor added to it if it doesn't already have one; all regex matches are done against the beginning of the input (based on its current state). No flags are removed, but the g flag is ignored because there can be only one match because of the ^ anchor. Success Succeeds if a match occurs at the current location of the input. The full match is returned as a single string, and that many characters are consumed. It is possible for this match to be zero characters long in the case where a * quantifier is used in the pattern. Failure Fails if there is no match at the current location of the input. Note that some patterns cannot fail; a pattern with a * quantifier, for example, can successfully match on zero characters. Throws Throws an error if pattern is neither a RegExp object or a string. Throws an error if pattern is a string and cannot be converted into a RegExp object because it is not a valid regular expression pattern. See Also satisfy string","title":"regex"},{"location":"parsers/regex/#parameters","text":"pattern The regular expression pattern to match against the current input location. This pattern can be either a RegExp object or a string (which is automatically converted into a RegExp object without flags). It will have an ^ anchor added to it if it doesn't already have one; all regex matches are done against the beginning of the input (based on its current state). No flags are removed, but the g flag is ignored because there can be only one match because of the ^ anchor.","title":"Parameters"},{"location":"parsers/regex/#success","text":"Succeeds if a match occurs at the current location of the input. The full match is returned as a single string, and that many characters are consumed. It is possible for this match to be zero characters long in the case where a * quantifier is used in the pattern.","title":"Success"},{"location":"parsers/regex/#failure","text":"Fails if there is no match at the current location of the input. Note that some patterns cannot fail; a pattern with a * quantifier, for example, can successfully match on zero characters.","title":"Failure"},{"location":"parsers/regex/#throws","text":"Throws an error if pattern is neither a RegExp object or a string. Throws an error if pattern is a string and cannot be converted into a RegExp object because it is not a valid regular expression pattern.","title":"Throws"},{"location":"parsers/regex/#see-also","text":"satisfy string","title":"See Also"},{"location":"parsers/repeat/","text":"repeat(p, n) const parser = repeat ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter Applies a parser a certain number of times, collecting the results into an array to return. The parser p must succeed the full n times for repeat to succeed. Any fewer successes results in failure. As with other combinators that run multiple parsers, it's possible for repeat to fail fatally even if the parser that failed did not fail fatally (because, for example, an earlier success consumed some input). There is another version of this parser, repeatB , that will backtrack and fail non-fatally when this happens. Parameters p The parser to apply. Its results are returned in an array. n The number of times that p is applied. Success Succeeds if p succeeds n times. The results are collected into an array and returned. Failure Fails if p does not succeed at least once. Fails if p succeeds at least once but not n times and if the prior successes of do not consume any input. Fatal Failre Fails fatally if p fails fatally. Fails fatally if p does not succeed n times and if prior successes consume some input. See Also optional repeatB sequence","title":"repeat"},{"location":"parsers/repeat/#parameters","text":"p The parser to apply. Its results are returned in an array. n The number of times that p is applied.","title":"Parameters"},{"location":"parsers/repeat/#success","text":"Succeeds if p succeeds n times. The results are collected into an array and returned.","title":"Success"},{"location":"parsers/repeat/#failure","text":"Fails if p does not succeed at least once. Fails if p succeeds at least once but not n times and if the prior successes of do not consume any input.","title":"Failure"},{"location":"parsers/repeat/#fatal-failre","text":"Fails fatally if p fails fatally. Fails fatally if p does not succeed n times and if prior successes consume some input.","title":"Fatal Failre"},{"location":"parsers/repeat/#see-also","text":"optional repeatB sequence","title":"See Also"},{"location":"parsers/repeatb/","text":"repeatB(p, n) const parser = repeatB ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab3 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter Applies a parser a certain number of times, collecting the results into an array to return. The parser p must succeed the full n times for repeatB to succeed. Any fewer successes results in failure. Any input that is consumed in the process will be backtracked. Parameters p The parser to apply. Its results are returned in an array. n The number of times that p is applied. Success Succeeds if p succeeds n times. The results are collected into an array and returned. Failure Fails if p fails before it has succeeded n times. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failre Fails fatally if p fails fatally before it has succeeded n times. See Also repeat sequenceB","title":"repeatB"},{"location":"parsers/repeatb/#parameters","text":"p The parser to apply. Its results are returned in an array. n The number of times that p is applied.","title":"Parameters"},{"location":"parsers/repeatb/#success","text":"Succeeds if p succeeds n times. The results are collected into an array and returned.","title":"Success"},{"location":"parsers/repeatb/#failure","text":"Fails if p fails before it has succeeded n times. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/repeatb/#fatal-failre","text":"Fails fatally if p fails fatally before it has succeeded n times.","title":"Fatal Failre"},{"location":"parsers/repeatb/#see-also","text":"repeat sequenceB","title":"See Also"},{"location":"parsers/right/","text":"right(p1, p2) const parser = right ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies two parsers in order, returning the result of the second one. The result of the first parser is discarded. If either parser fails, then the entire right parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p1 or p2 failed fatally). In the examples, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. There is another version of this parser ( rightB ) that will backtrack and fail non-fatally if p1 succeeds and p2 fails non-fatally. right(p1, p2) is an optimized implementation of chain(p1, () => p2) . Parameters p1 The first parser to apply. This parser's result will be discarded. p2 The second parser to apply. If both parsers succeed, this parser's result will be right 's result. Success Succeeds if both p1 and p2 succeed. Returns the result of p2 . Failure Fails if p1 fails. Fails if p2 fails after p1 succeeds but does not consume any input. Fatal Failure Fails fatally if either p1 or p2 fail fatally. Fails fatally if p2 fails after p1 succeeds and consumes some input. Throws Throws an error if either p1 or p2 are not parsers. See Also both left rightB sequence","title":"right"},{"location":"parsers/right/#parameters","text":"p1 The first parser to apply. This parser's result will be discarded. p2 The second parser to apply. If both parsers succeed, this parser's result will be right 's result.","title":"Parameters"},{"location":"parsers/right/#success","text":"Succeeds if both p1 and p2 succeed. Returns the result of p2 .","title":"Success"},{"location":"parsers/right/#failure","text":"Fails if p1 fails. Fails if p2 fails after p1 succeeds but does not consume any input.","title":"Failure"},{"location":"parsers/right/#fatal-failure","text":"Fails fatally if either p1 or p2 fail fatally. Fails fatally if p2 fails after p1 succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/right/#throws","text":"Throws an error if either p1 or p2 are not parsers.","title":"Throws"},{"location":"parsers/right/#see-also","text":"both left rightB sequence","title":"See Also"},{"location":"parsers/rightb/","text":"rightB(p1, p2) const parser = rightB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Applies two parsers in order, returning the result of the second one. The result of the first parser is discarded. If either parser fails, then the entire rightB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p1 was applied. Parameters p1 The first parser to apply. This parser's result will be discarded. p2 The second parser to apply. If both parsers succeed, this parser's result will be rightB 's result. Success Succeeds if both p1 and p2 succeed. Returns the result of p2 . Failure Fails if either p1 or p2 fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p1 or p2 fail fatally. Throws Throws an error if either p1 or p2 are not parsers. See Also bothB leftB right sequenceB","title":"rightB"},{"location":"parsers/rightb/#parameters","text":"p1 The first parser to apply. This parser's result will be discarded. p2 The second parser to apply. If both parsers succeed, this parser's result will be rightB 's result.","title":"Parameters"},{"location":"parsers/rightb/#success","text":"Succeeds if both p1 and p2 succeed. Returns the result of p2 .","title":"Success"},{"location":"parsers/rightb/#failure","text":"Fails if either p1 or p2 fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/rightb/#fatal-failure","text":"Fails fatally if either p1 or p2 fail fatally.","title":"Fatal Failure"},{"location":"parsers/rightb/#throws","text":"Throws an error if either p1 or p2 are not parsers.","title":"Throws"},{"location":"parsers/rightb/#see-also","text":"bothB leftB right sequenceB","title":"See Also"},{"location":"parsers/satisfy/","text":"satisfy(fn) const parser = satisfy ( x => x === x . toUpperCase ()) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Unknown error(s) Reads a single character, succeeding if predicate fn returns true when passed that character. Parameters fn The predicate function that the next character must pass in order for the parser to succeed. Success Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character. Failure Fails if fn returns false when the next character is passed into it. If this happens, the parser does not generate an error message because it cannot have enough information to know what fn was going to pass. To provide an error message, either wrap the parser with label or use satisfyL . Throws Throws an error if fn is not a non-parser function. See Also label range regex satisfyM","title":"satisfy"},{"location":"parsers/satisfy/#parameters","text":"fn The predicate function that the next character must pass in order for the parser to succeed.","title":"Parameters"},{"location":"parsers/satisfy/#success","text":"Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character.","title":"Success"},{"location":"parsers/satisfy/#failure","text":"Fails if fn returns false when the next character is passed into it. If this happens, the parser does not generate an error message because it cannot have enough information to know what fn was going to pass. To provide an error message, either wrap the parser with label or use satisfyL .","title":"Failure"},{"location":"parsers/satisfy/#throws","text":"Throws an error if fn is not a non-parser function.","title":"Throws"},{"location":"parsers/satisfy/#see-also","text":"label range regex satisfyM","title":"See Also"},{"location":"parsers/satisfym/","text":"satisfyM(fn, msg) const parser = satisfyM ( x => x === x . toUpperCase (), 'an uppercase letter' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter Reads a single character, succeeding if predicate fn returns true when passed that character. Parameters fn The predicate function that the next character must pass in order for the parser to succeed. msg The text of the error message generated if the parser fails. Success Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character. Failure Fails if fn returns false when the next character is passed into it. If this happens, expected(msg) is used as the error message. Throws Throws an error if fn is not a non-parser function. Throws an error if str is not a string. See Also label satisfy","title":"satisfyM"},{"location":"parsers/satisfym/#parameters","text":"fn The predicate function that the next character must pass in order for the parser to succeed. msg The text of the error message generated if the parser fails.","title":"Parameters"},{"location":"parsers/satisfym/#success","text":"Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character.","title":"Success"},{"location":"parsers/satisfym/#failure","text":"Fails if fn returns false when the next character is passed into it. If this happens, expected(msg) is used as the error message.","title":"Failure"},{"location":"parsers/satisfym/#throws","text":"Throws an error if fn is not a non-parser function. Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/satisfym/#see-also","text":"label satisfy","title":"See Also"},{"location":"parsers/second/","text":"second(p) const parser = second ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"2\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Applies a parser and returns the second element of the resulting array. This parser works only if p returns an array, and it returns the second element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. second(p) is an optimized implementation of chain(p, x => always(x[1])) . Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the second element of the array that p returns. If there are not at least two elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth first fourth nth third","title":"second"},{"location":"parsers/second/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/second/#success","text":"Succeeds if p succeeds. Returns the second element of the array that p returns. If there are not at least two elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/second/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/second/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/second/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/second/#see-also","text":"fifth first fourth nth third","title":"See Also"},{"location":"parsers/sepby/","text":"sepBy(p, psep) const parser = sepBy ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parses zero or more occurrences of a content parser, separated by a separator parser. sepBy applies the content parser p zero or more times as long as both it and the preceding separator parser psep match. The operation of the parser in EBNF is (p (psep p)*)? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser must be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the content parser (i.e., at the beginning of the text matched by the separator parser). Parameters p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded. Success Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or psep are not parsers. See Also sepBy1 sepEndBy","title":"sepBy"},{"location":"parsers/sepby/#parameters","text":"p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sepby/#success","text":"Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result.","title":"Success"},{"location":"parsers/sepby/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sepby/#throws","text":"Throws an error if either p or psep are not parsers.","title":"Throws"},{"location":"parsers/sepby/#see-also","text":"sepBy1 sepEndBy","title":"See Also"},{"location":"parsers/sepby1/","text":"sepBy1(p, psep) const parser = sepBy1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parses one or more occurrences of a content parser, separated by a separator parser. sepBy1 applies the content parser p one or more times as long as both it and the preceding separator parser psep match. The operation of the parser in EBNF is p (psep p)* . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser must be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the content parser (i.e., at the beginning of the text matched by the separator parser). Parameters p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded. Success Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or psep are not parsers. See Also sepBy sepEndBy1","title":"sepBy1"},{"location":"parsers/sepby1/#parameters","text":"p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sepby1/#success","text":"Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned.","title":"Success"},{"location":"parsers/sepby1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/sepby1/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sepby1/#throws","text":"Throws an error if either p or psep are not parsers.","title":"Throws"},{"location":"parsers/sepby1/#see-also","text":"sepBy sepEndBy1","title":"See Also"},{"location":"parsers/sependby/","text":"sepEndBy(p, psep) const parser = sepEndBy ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parses zero or more occurrences of a content parser, separated and optionally ended by a separator parser. sepEndBy applies the content parser p zero or more times as long as both it and the preceding separator parser psep match. The operation of the parser in EBNF is (p (psep p)* psep?)? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser need not be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the separator parser. Parameters p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded. Success Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or psep are not parsers. See Also sepBy sepEndBy1","title":"sepEndBy"},{"location":"parsers/sependby/#parameters","text":"p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sependby/#success","text":"Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result.","title":"Success"},{"location":"parsers/sependby/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sependby/#throws","text":"Throws an error if either p or psep are not parsers.","title":"Throws"},{"location":"parsers/sependby/#see-also","text":"sepBy sepEndBy1","title":"See Also"},{"location":"parsers/sependby1/","text":"sepEndBy1(p, psep) const parser = sepEndBy1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111,' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parses one or more occurrences of a content parser, separated and optionally ended by a separator parser. sepEndBy1 applies the content parser p one or more times as long as both it and the preceding separator parser psep match. The operation of the parser in EBNF is p (psep p)* psep? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser need not be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the separator parser. Parameters p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded. Success Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or psep are not parsers. See Also sepBy1 sepEndBy","title":"sepEndBy1"},{"location":"parsers/sependby1/#parameters","text":"p The content parser. The results of this parser are returned in an array. psep The separator parser. The results of this parser are discarded.","title":"Parameters"},{"location":"parsers/sependby1/#success","text":"Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned.","title":"Success"},{"location":"parsers/sependby1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/sependby1/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sependby1/#throws","text":"Throws an error if either p or psep are not parsers.","title":"Throws"},{"location":"parsers/sependby1/#see-also","text":"sepBy1 sepEndBy","title":"See Also"},{"location":"parsers/sequence/","text":"sequence(...ps) const parser = sequence ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter Applies a series of parsers in order, returning an array that contains each parser's result. sequence will only succeed if all of its parsers succeed. If one of them fails, sequence will fail fatally if it had consumed any input up to that point, even if the parser that failed did so non-fatally. There is another version of this parser ( sequenceB ) that fails non-fatally and backtracks if the parser that fails does so non-fatally. All of the results are gathered into an array, but null results are skipped. Parameters ...ps A series of parsers to apply to the input, one at a time, in order. Success Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array. Failure Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the prior parsers succeed but do not consume any input. Fatal Failure Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after any prior parser succeeds and consumes some input. Throws Throws an error if any member of ps is not a parser. See Also block both left right sequenceB","title":"sequence"},{"location":"parsers/sequence/#parameters","text":"...ps A series of parsers to apply to the input, one at a time, in order.","title":"Parameters"},{"location":"parsers/sequence/#success","text":"Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array.","title":"Success"},{"location":"parsers/sequence/#failure","text":"Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the prior parsers succeed but do not consume any input.","title":"Failure"},{"location":"parsers/sequence/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after any prior parser succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/sequence/#throws","text":"Throws an error if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/sequence/#see-also","text":"block both left right sequenceB","title":"See Also"},{"location":"parsers/sequenceb/","text":"sequenceB(...ps) const parser = sequenceB ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // Symbol(error) console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a11 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter Applies a series of parsers in order, returning an array that contains each parser's result. sequenceB will only succeed if all of its parsers succeed. If one of them fails, sequenceB will also fail. If input was consumed before the failure occurred, sequenceB will backtrack to the location where its first parser was applied. All of the results are gathered into an array, but null results are skipped. Parameters ...ps A series of parsers to apply to the input, one at a time, in order. Success Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array. Failure Fails if any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws an error if any member of ps is not a parser. See Also blockB bothB leftB rightB sequence","title":"sequenceB"},{"location":"parsers/sequenceb/#parameters","text":"...ps A series of parsers to apply to the input, one at a time, in order.","title":"Parameters"},{"location":"parsers/sequenceb/#success","text":"Succeeds if every parser in ps succeeds. Returns all of the non- null results of the parsers in ps gathered into an array.","title":"Success"},{"location":"parsers/sequenceb/#failure","text":"Fails if any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/sequenceb/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/sequenceb/#throws","text":"Throws an error if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/sequenceb/#see-also","text":"blockB bothB leftB rightB sequence","title":"See Also"},{"location":"parsers/skip/","text":"skip(p) const parser = skip ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , '123' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Applies a parser and discards its result on success. skip(p) is an optimized implementation of chain(p, () => always(null)) . Parameters p The parser to apply to the input. Success Succeeds if p succeeds. Discards the result and returns null . Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also optional skipMany skipMany1","title":"skip"},{"location":"parsers/skip/#parameters","text":"p The parser to apply to the input.","title":"Parameters"},{"location":"parsers/skip/#success","text":"Succeeds if p succeeds. Discards the result and returns null .","title":"Success"},{"location":"parsers/skip/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/skip/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/skip/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/skip/#see-also","text":"optional skipMany skipMany1","title":"See Also"},{"location":"parsers/skipmany/","text":"skipMany(p) const parser = skipMany ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter Applies a parser as many times as possible until it fails, discarding all of the parser's results. skipMany executes a parser zero or more times, as long as it continues to succeed. When the parser fails, that does not mean that skipMany fails; that signals that skipMany is through executing. The failure case in the example shows the only way that skipMany can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes skipMany to fail. skipMany does not fail from non-fatal failures of its parser. Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p does not fail fatally. Discards all results. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many skipMany1","title":"skipMany"},{"location":"parsers/skipmany/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/skipmany/#success","text":"Succeeds if p does not fail fatally. Discards all results.","title":"Success"},{"location":"parsers/skipmany/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/skipmany/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/skipmany/#see-also","text":"many skipMany1","title":"See Also"},{"location":"parsers/skipmany1/","text":"skipMany1(p) const parser = skipMany1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // Symbol(fatal) console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter Applies a parser as many times as possible until it fails, discarding the parser's results. skipMany1 executes a parser one or more times, as long as it continues to succeed. When the parser fails, that does not mean that skipMany1 fails (as long as the parser succeeded at least once); that signals that skipMany1 is through executing. As long as p succeeds at least once, the only way skipMany1 can fail is if p fails fatally. Parameters p The parser to apply repeatedly until it fails. Success Succeeds if p succeeds at least once and does not fail fatally. Discards all results. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also many1 skipMany","title":"skipMany1"},{"location":"parsers/skipmany1/#parameters","text":"p The parser to apply repeatedly until it fails.","title":"Parameters"},{"location":"parsers/skipmany1/#success","text":"Succeeds if p succeeds at least once and does not fail fatally. Discards all results.","title":"Success"},{"location":"parsers/skipmany1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/skipmany1/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/skipmany1/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/skipmany1/#see-also","text":"many1 skipMany","title":"See Also"},{"location":"parsers/space/","text":"space const parser = space const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a whitespace character Reads a character and succeeds if that character is an ASCII whitespace character. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Success Succeeds if the next character is an ASCII whitespace character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also newline spaces spaces1 spaceU","title":"space"},{"location":"parsers/space/#success","text":"Succeeds if the next character is an ASCII whitespace character. Consumes and returns that character.","title":"Success"},{"location":"parsers/space/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/space/#see-also","text":"newline spaces spaces1 spaceU","title":"See Also"},{"location":"parsers/spaces/","text":"spaces const parser = spaces const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null Reads zero or more ASCII whitespace characters and discards them. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Success Always succeeds. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded. See Also newline space spaces1 spacesU","title":"spaces"},{"location":"parsers/spaces/#success","text":"Always succeeds. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces/#see-also","text":"newline space spaces1 spacesU","title":"See Also"},{"location":"parsers/spaces1/","text":"spaces1 const parser = spaces1 const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more whitespace characters Reads one or more ASCII whitespace characters and discards them. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Success Succeeds if at least one ASCII whitespace character is read. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded. Failure Fails if the next character is not an ASCII whitespace character. See Also newline space spaces spaces1U","title":"spaces1"},{"location":"parsers/spaces1/#success","text":"Succeeds if at least one ASCII whitespace character is read. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces1/#failure","text":"Fails if the next character is not an ASCII whitespace character.","title":"Failure"},{"location":"parsers/spaces1/#see-also","text":"newline space spaces spaces1U","title":"See Also"},{"location":"parsers/spaces1u/","text":"spaces1U const parser = spaces1U const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more Unicode whitespace characters Reads one or more Unicode whitespace characters and discards them. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Success Succeeds if at least one Unicode whitespace character is read. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded. Failure Fails if the next character is not a Unicode whitespace character. See Also newlineU spaces1 spacesU spaceU","title":"spaces1U"},{"location":"parsers/spaces1u/#success","text":"Succeeds if at least one Unicode whitespace character is read. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces1u/#failure","text":"Fails if the next character is not a Unicode whitespace character.","title":"Failure"},{"location":"parsers/spaces1u/#see-also","text":"newlineU spaces1 spacesU spaceU","title":"See Also"},{"location":"parsers/spacesu/","text":"spacesU const parser = spacesU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // null Reads zero or more Unicode whitespace characters and discards them. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Success Always succeeds. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded. See Also newlineU spaces spaces1U spaceU","title":"spacesU"},{"location":"parsers/spacesu/#success","text":"Always succeeds. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spacesu/#see-also","text":"newlineU spaces spaces1U spaceU","title":"See Also"},{"location":"parsers/spaceu/","text":"spaceU const parser = spaceU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode whitespace character Reads a character and succeeds if that character is a Unicode whitespace character. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Success Succeeds if the next character is a Unicode whitespace character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also newlineU space spaces1U spacesU","title":"spaceU"},{"location":"parsers/spaceu/#success","text":"Succeeds if the next character is a Unicode whitespace character. Consumes and returns that character.","title":"Success"},{"location":"parsers/spaceu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/spaceu/#see-also","text":"newlineU space spaces1U spacesU","title":"See Also"},{"location":"parsers/string/","text":"string(str) const parser = string ( 'Test' ) const s = parse ( parser , 'Testing' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"Test\" const f = parse ( parser , 'test' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test // ^ // Expected 'Test' Reads a number of characters and succeeds if those characters equal str . The number of characters read equals the number of characters in str . If there are not that many characters remaining in the input, the parser will automatically fail. If str is the empty string, the parser will automatically succeed and consume no input. Parameters str The string to match against the input at its current location. Success Succeeds if the first n characters of the input at its current location is the same as str , where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input. Failure Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str . Throws Throws an error if str is not a string. See Also char regex stringI","title":"string"},{"location":"parsers/string/#parameters","text":"str The string to match against the input at its current location.","title":"Parameters"},{"location":"parsers/string/#success","text":"Succeeds if the first n characters of the input at its current location is the same as str , where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input.","title":"Success"},{"location":"parsers/string/#failure","text":"Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str .","title":"Failure"},{"location":"parsers/string/#throws","text":"Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/string/#see-also","text":"char regex stringI","title":"See Also"},{"location":"parsers/stringi/","text":"stringI(str) const parser = stringI ( 'Test' ) const s = parse ( parser , 'testing' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"test\" const f = parse ( parser , 'oops' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // oops // ^ // Expected 'Test' Reads a number of characters and succeeds if those characters equal str . This equality check is case-insensitive. The number of characters read equals the number of characters in str . If there are not that many characters remaining in the input, the parser will automatically fail. If str is the empty string, the parser will automatically succeed and consume no input. Parameters str The string to case-insensitively match against the input at its current location. Success Succeeds if the first n characters of the input at its current location is the same as str (case-insensitive), where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input. Failure Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str case-insensitively. Throws Throws an error if str is not a string. See Also charI regex string","title":"stringI"},{"location":"parsers/stringi/#parameters","text":"str The string to case-insensitively match against the input at its current location.","title":"Parameters"},{"location":"parsers/stringi/#success","text":"Succeeds if the first n characters of the input at its current location is the same as str (case-insensitive), where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input.","title":"Success"},{"location":"parsers/stringi/#failure","text":"Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str case-insensitively.","title":"Failure"},{"location":"parsers/stringi/#throws","text":"Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/stringi/#see-also","text":"charI regex string","title":"See Also"},{"location":"parsers/third/","text":"third(p) const parser = third ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"3\" const f = parse ( parser , '' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Applies a parser and returns the third element of the resulting array. This parser works only if p returns an array, and it returns the third element of that array. It's most useful with parsers like sequence and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. third(p) is an optimized implementation of chain(p, x => always(x[2])) . Parameters p The parser to apply. This parser should return an array. Success Succeeds if p succeeds. Returns the third element of the array that p returns. If there are not at least three elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. See Also fifth first fourth nth second","title":"third"},{"location":"parsers/third/#parameters","text":"p The parser to apply. This parser should return an array.","title":"Parameters"},{"location":"parsers/third/#success","text":"Succeeds if p succeeds. Returns the third element of the array that p returns. If there are not at least three elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/third/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/third/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/third/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/third/#see-also","text":"fifth first fourth nth second","title":"See Also"},{"location":"parsers/upper/","text":"upper const parser = upper const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter Reads the next character and succeeds if that character is an ASCII uppercase letter ( A-Z ). This does not parse UTF-8 uppercase letters in general. Use upperU for that. Success Succeeds if the next character is an ASCII uppercase letter ( A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also alpha letter lower upperU","title":"upper"},{"location":"parsers/upper/#success","text":"Succeeds if the next character is an ASCII uppercase letter ( A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/upper/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/upper/#see-also","text":"alpha letter lower upperU","title":"See Also"},{"location":"parsers/upperu/","text":"upperU const parser = upperU const s = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) // \"A\" const f = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0430\u0431\u0432 // ^ // Expected a Unicode uppercase letter Reads the next character and succeeds if that character is either a Unicode uppercase letter or a Unicode titlecase character. A character is a Unicode uppercase character if it has the Unicode Uppercase binary property. This is approximately equal to characters that match the regular expression /\\p{Lu}/u except with a few additional characters. A character is a Unicode titlecase character if it has the Unicode Letter, Titlecase property, which is the same as characters that match the regular expression /\\p{Lt}/u . Titlecase characters are typically ligatures of an uppercase character with a lowercase character, such as \u01c8 . (The double-lowercase counterparts such as \u01c9 are considered lowercase letters and would be parsed by lowerU .) Success Succeeds if the next character is a Unicode uppercase or titlecase letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also alphaU letterU lowerU upper","title":"upperU"},{"location":"parsers/upperu/#success","text":"Succeeds if the next character is a Unicode uppercase or titlecase letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/upperu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/upperu/#see-also","text":"alphaU letterU lowerU upper","title":"See Also"},{"location":"parsers/value/","text":"value(p, x) const parser = value ( string ( '\"\"' ), '\"' ) const s = parse ( parser , '\"\"' ) console . log ( status ( s )) // Symbol(ok) console . log ( success ( s )) / \"\\\"\" const f = parse ( parser , '\"' ) console . log ( status ( f )) // Symbol(error) console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \" // ^ // Expected '\"\"' Applies a parser and, if it succeeds, returns another value. In the example, if the parser string('\"\"') succeeds, then value returns a single character ( \" ). This parser could be used for detecting a quote inside a quoted string in CSV, for instance, where quotation marks are escaped by doubling them. x can be anything, so value is one of the few combinators that can return something other than a string. value(p, x) is an optimized implementation of chain(p, () => always(x)) . Parameters p The parser that gets applied to the input. x The value for value to return if p succeeds. Success Succeeds if p succeeds. In this case, the result of p is discarded and x is returned instead. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. See Also always","title":"value"},{"location":"parsers/value/#parameters","text":"p The parser that gets applied to the input. x The value for value to return if p succeeds.","title":"Parameters"},{"location":"parsers/value/#success","text":"Succeeds if p succeeds. In this case, the result of p is discarded and x is returned instead.","title":"Success"},{"location":"parsers/value/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/value/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/value/#throws","text":"Throws an error if p is not a parser.","title":"Throws"},{"location":"parsers/value/#see-also","text":"always","title":"See Also"}]}