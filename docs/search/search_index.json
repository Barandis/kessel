{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kessel Kessel is a full-featured parser combinator library written in JavaScript. Its aim is to make it easy to produce robust, arbitrarily complex parsers for any conceivable use. Status Kessel is currently alpha-quality software. The author had no more than a vague notion of parser combinators before embarking upon this project, and while he has learned much about the deep workings of such a library, it's likely that there's more to learn that will result in API changes. The test suite is considerable (over 600 tests at the time of writing) and code coverage is very nearly or at 100%, but that doesn't guarantee that the software is bug free. If you find a bug or want to request a feature, please use the GitHub issue tracker for the project. Changelog Version 0.1.0-alpha, 2020-12-03 Initial release. License Kessel is released under the MIT License. !!! note \"MIT License\" Copyright \u00a9 2020 Thomas Otterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contact Kessel is written and presently maintained by Thomas Otterson, who can be reached at tjotterson [at] gmail.com.","title":"Home"},{"location":"#kessel","text":"Kessel is a full-featured parser combinator library written in JavaScript. Its aim is to make it easy to produce robust, arbitrarily complex parsers for any conceivable use.","title":"Kessel"},{"location":"#status","text":"Kessel is currently alpha-quality software. The author had no more than a vague notion of parser combinators before embarking upon this project, and while he has learned much about the deep workings of such a library, it's likely that there's more to learn that will result in API changes. The test suite is considerable (over 600 tests at the time of writing) and code coverage is very nearly or at 100%, but that doesn't guarantee that the software is bug free. If you find a bug or want to request a feature, please use the GitHub issue tracker for the project.","title":"Status"},{"location":"#changelog","text":"","title":"Changelog"},{"location":"#version-010-alpha-2020-12-03","text":"Initial release.","title":"Version 0.1.0-alpha, 2020-12-03"},{"location":"#license","text":"Kessel is released under the MIT License. !!! note \"MIT License\" Copyright \u00a9 2020 Thomas Otterson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"#contact","text":"Kessel is written and presently maintained by Thomas Otterson, who can be reached at tjotterson [at] gmail.com.","title":"Contact"},{"location":"api/","text":"Summary A Note about Types Types are given in the descriptions for each of the parsers and functions listed below. These are contained in TypeScript definition files in the project that can be used either for writing TypeScript programs that use Kessel or just in providing signature information for your IDE. It should however be noted that some of the type information is incomplete because TypeScript leaves no way to express complete information in the case where there are variable numbers of arguments that can have different generic parameter types. There are notes to that effect in alt , pipe , pipeB , seq , and seqB . However, there are shortcomings in other parsers that are not explicity marked. For example, TypeScript has no way to say that a string should be one character long, or that an array of strings should have elements that are all one character long. This affects the parameters in anyOf , char , charI , noneOf , and range . A best effort is given to give useful types for documentation, but there's no way to make them perfect. Assertions in the library do take care of most of the problem. If a 3-character string gets passed to char , for example, an error will be thrown whether or not the type system can express that. Parsers There are three kinds of entries in these tables: parsers, functions that produce parsers, and combinators. Since each of these either is or produces a parser, they are all referred to as parsers unless there is reason to differentiate. Additionally, parsers are often said to return a value or to have a value as a result . Parsers all return Reply objects, but when return or result is used, it's meant to refer to the value held by the Result object inside that Reply object. It should be unambiguous. Table 1: Single character parsers Parser Description char Parses a single character. charI Parses a single character, but without case sensitivity. satisfy Parses a single character for which a predicate returns true . satisfyM Parses a single character for which a predicate returns true . Fails with a message string if the predicate returns false . range Parses a single character whose code point is between two other characters. any Parses any one character. anyOf Parses a single character which is included in a string or an array. noneOf Parses a single character which is not in included in a string or an array. digit Parses a single decimal digit ( 0-9 ). hex Parses a single hexadecmial digit ( 0-9 , a-f , or A-F ). octal Parses a single octal digit ( 0-7 ). letter Parses a single ASCII letter ( a-z or A-Z ). alpha Parses a single ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). lower Parses a single ASCII lowercase letter ( a-z ). upper Parses a single ASCII uppercase letter ( A-Z ). letterU Parses a single UTF-8 letter. alphaU Parses a single UTF-8 alphanumeric character. lowerU Parses a single UTF-8 lowercase letter. upperU Parses a single UTF-8 uppercase letter. Table 2: String (multiple-character) parsers Parser Description string Parses a string. stringI Parses a string, but without case sensitivity. regex Parses a string matching a regular expression pattern. all Parses the remainder of the input as a string. anyString Parses a string of a certain number of characters. Table 3: Whitespace parsers Parser Description newline Parses a single ASCII newline character ( \\r , \\n , or \\r\\n ). space Parses a single ASCII whitespace character ( , \\t , or a newline). spaces Skips zero or more ASCII whitespace characters. spaces1 Skips one or more ASCII whitespace characters. newlineU Parses a single UTF-8 newline character. spaceU Parses a single UTF-8 whitespace character (including newlines.md). spacesU Skips zero or more UTF-8 whitespace characters. spaces1U Skips one or more UTF-8 whitespace characters. eof Succeeds only at the end of the input. Table 4: Miscellaneous parsers Parser Description always Always succeeds and returns a value. failNormally Fails with a generic message. failFatally Fails fatally with a generic message. Table 5: Sequence combinators Parser Description seq Executes a series of parsers in order, returning their results in an array. left Executes two parsers in order and returns the result of the first one. right Executes two parsers in order and returns the result of the second one. block Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. many Executes a parser zero or more times until it fails, returning all of the results in an array. many1 Executes a parser one or more times until it fails, returning all of the results in an array. skip Executes a parser and discards the result. sep Executes a content parser zero or more times with an application of a separator parser between each. Returns the content parser results. sep1 Executes a content parser one or more times with an application of a separator parser between each. Returns the content parser results. end Executes a content parser zero or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. end1 Executes a content parser one or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. repeat Executes a parser a certain number of times, returning the results in an array. pipe Executes a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. between Executes a content parser between two other parsers, returning only the content parser's result. until Executes a content parser zero or more times until an end parser succeeds. Returns the content parser's results. assocL Executes a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1L Executes a content parser one or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assocR Executes a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1R Executes a content parser one or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. Table 6: Alternative and conditional combinators Parser Description alt Executes a series of parsers one at a time until one succeeds. opt Executes a parser and returns its result on success. On failure, succeeds but returns nothing. def Executes a parser and returns either its result upon success or a default value upon failure. peek Executes a parser and returns its result without consuming input. empty Executes a parser and fails if the parser succeeds but consumes input. not Executes a parser and succeeds without consuming input if that parser fails. Table 7: Backtracking combinators Parser Description attempt Executes a parser, backtracking to its original position if the parser fails and consumes input. seqB Executes a series of parsers in order, returning their results in an array. Backtracks to where the first parser was applied if any other of its parsers fails. blockB Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. Backtracks to where the first yielded parser was applied if any later parser fails. chainB Executes a parser, then applies a function to the result, then applies the parser returned by the function. Backtracks to where the first parser was applied if the parser returned by the function fails. applyB Parses content and a function, returning the result of the function when passed the content. Backtracks to where the first parser was applied if the second parser fails. leftB Executes two parsers in order and returns the result of the first one. Backtracks to the location where the first parser was applied if the second one fails. rightB Executes two parsers in order and returns the result of the second one. Backtracks to the location where the first parser was applied if the second one fails. pipeB Executes a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. Backtracks to where the first parser was applied if any other parser fails. repeatB Executes a parser a certain number of times, returning the results in an array. Backtracks to where the first parser was applied if any other parser fails. untilB Executes a content parser zero or more times until an end parser succeeds. Returns the content parser's results. Backtracks to where the content parser was first applied if it fails before the end parser succeeds. betweenB Executes a content parser between two other parsers, returning only the content parser's result. Backtracks to where the first parser was applied if either other parser fails. Table 8: Chaining combinators Parser Description chain Applies a parser, then applies a function to the result, then applies the parser returned by the function. map Applies a parser, then applies a function to the result, then returns the result of that function. apply Parses content and a function, returning the result of the function when passed the content. value Executes a parser and returns a value. nth Executes a parser and returns the nth element of the resulting array. first Executes a parser and returns the first element of the resulting array. second Executes a parser and returns the second element of the resulting array. third Executes a parser and returns the third element of the resulting array. fourth Executes a parser and returns the fourth element of the resulting array. fifth Executes a parser and returns the fifth element of the resulting array. join Executes a parser and returns its resulting array elements joined together into a string. compact Executes a parser and returns its resulting array minus any null or undefined elements. Tools Tools provide ways to run parsers and ways to write new parsers (if block isn't good enough). Regular users will use the functions in Table 10, but those in Tables 11 and 12 are going to be of interest only to parser authors. Table 9: Running parsers Function Description parse Executes a parser. succeeded Determines whether a parser result was successful. status Returns the status of a parser result. success Returns the value from a parser result if it was successful. failure Returns the error message from a parser result if it failed. run Executes a parser and either returns a successful result or throws an error. Table 10: Error generation Function Description expected Creates an error list containing a single expected error message. unexpected Creates an error list containing a single unexpected error message. generic Creates an error list containing a single generic error message. nested Adds a nested error to an error list. compound Adds a compound error to an error list. other Creates an error list containing a single other error message. merge Merges two error lists. formatErrors Generates an error message out of a parser context and result. getPosition Determines the line/column position of a given context. Table 11: Authoring parsers Function Description parser Creates a new parser. okReply Generates a reply representing a success. failReply Generates a reply representing a failure. fatalReply Generates a reply representing a fatal failure. Types Kessel is written in JavaScript, which is a dynamically typed language, and so none of these types actually exist within the code. However, there is a lot of consistency around what functions expect from parameters and what they provide as return values, and we are able to document that here. For TypeScript users, there will be a declaration file provided which will codify all of these types. Table 13: Types Type Description CompoundError A nested error that happened at a different location than the current context and has its own error message. Context The parsing context, which changes as more of the input is parsed. ErrorList A list of parsing errors. ErrorType The type of a parsing error, used to determine how it should be displayed in an error message. Formatter A function that formats error information into a string. Input Parser input text, which can be in one of several different forms. LocalError A simple parsing error. NestedError An error that happened at a different location than the current context. Parser A function which actually performs parsing. Reply The state of a parser after it has performed its parsing, consisting of an updated context and a result. Result The output of a parser, consisting of either a parsed value or a parsing error. Status The condition of a parser result, including whether the parse succeeded or not.","title":"Summary"},{"location":"api/#summary","text":"","title":"Summary"},{"location":"api/#a-note-about-types","text":"Types are given in the descriptions for each of the parsers and functions listed below. These are contained in TypeScript definition files in the project that can be used either for writing TypeScript programs that use Kessel or just in providing signature information for your IDE. It should however be noted that some of the type information is incomplete because TypeScript leaves no way to express complete information in the case where there are variable numbers of arguments that can have different generic parameter types. There are notes to that effect in alt , pipe , pipeB , seq , and seqB . However, there are shortcomings in other parsers that are not explicity marked. For example, TypeScript has no way to say that a string should be one character long, or that an array of strings should have elements that are all one character long. This affects the parameters in anyOf , char , charI , noneOf , and range . A best effort is given to give useful types for documentation, but there's no way to make them perfect. Assertions in the library do take care of most of the problem. If a 3-character string gets passed to char , for example, an error will be thrown whether or not the type system can express that.","title":"A Note about Types"},{"location":"api/#parsers","text":"There are three kinds of entries in these tables: parsers, functions that produce parsers, and combinators. Since each of these either is or produces a parser, they are all referred to as parsers unless there is reason to differentiate. Additionally, parsers are often said to return a value or to have a value as a result . Parsers all return Reply objects, but when return or result is used, it's meant to refer to the value held by the Result object inside that Reply object. It should be unambiguous.","title":"Parsers"},{"location":"api/#table-1-single-character-parsers","text":"Parser Description char Parses a single character. charI Parses a single character, but without case sensitivity. satisfy Parses a single character for which a predicate returns true . satisfyM Parses a single character for which a predicate returns true . Fails with a message string if the predicate returns false . range Parses a single character whose code point is between two other characters. any Parses any one character. anyOf Parses a single character which is included in a string or an array. noneOf Parses a single character which is not in included in a string or an array. digit Parses a single decimal digit ( 0-9 ). hex Parses a single hexadecmial digit ( 0-9 , a-f , or A-F ). octal Parses a single octal digit ( 0-7 ). letter Parses a single ASCII letter ( a-z or A-Z ). alpha Parses a single ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). lower Parses a single ASCII lowercase letter ( a-z ). upper Parses a single ASCII uppercase letter ( A-Z ). letterU Parses a single UTF-8 letter. alphaU Parses a single UTF-8 alphanumeric character. lowerU Parses a single UTF-8 lowercase letter. upperU Parses a single UTF-8 uppercase letter.","title":"Table 1: Single character parsers"},{"location":"api/#table-2-string-multiple-character-parsers","text":"Parser Description string Parses a string. stringI Parses a string, but without case sensitivity. regex Parses a string matching a regular expression pattern. all Parses the remainder of the input as a string. anyString Parses a string of a certain number of characters.","title":"Table 2: String (multiple-character) parsers"},{"location":"api/#table-3-whitespace-parsers","text":"Parser Description newline Parses a single ASCII newline character ( \\r , \\n , or \\r\\n ). space Parses a single ASCII whitespace character ( , \\t , or a newline). spaces Skips zero or more ASCII whitespace characters. spaces1 Skips one or more ASCII whitespace characters. newlineU Parses a single UTF-8 newline character. spaceU Parses a single UTF-8 whitespace character (including newlines.md). spacesU Skips zero or more UTF-8 whitespace characters. spaces1U Skips one or more UTF-8 whitespace characters. eof Succeeds only at the end of the input.","title":"Table 3: Whitespace parsers"},{"location":"api/#table-4-miscellaneous-parsers","text":"Parser Description always Always succeeds and returns a value. failNormally Fails with a generic message. failFatally Fails fatally with a generic message.","title":"Table 4: Miscellaneous parsers"},{"location":"api/#table-5-sequence-combinators","text":"Parser Description seq Executes a series of parsers in order, returning their results in an array. left Executes two parsers in order and returns the result of the first one. right Executes two parsers in order and returns the result of the second one. block Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. many Executes a parser zero or more times until it fails, returning all of the results in an array. many1 Executes a parser one or more times until it fails, returning all of the results in an array. skip Executes a parser and discards the result. sep Executes a content parser zero or more times with an application of a separator parser between each. Returns the content parser results. sep1 Executes a content parser one or more times with an application of a separator parser between each. Returns the content parser results. end Executes a content parser zero or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. end1 Executes a content parser one or more times with an application of a separator parser between each and optionally at the end. Returns the content parser results. repeat Executes a parser a certain number of times, returning the results in an array. pipe Executes a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. between Executes a content parser between two other parsers, returning only the content parser's result. until Executes a content parser zero or more times until an end parser succeeds. Returns the content parser's results. assocL Executes a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1L Executes a content parser one or more times with an application of an operator parser between each. Returns the value obtained by left associative application of all functions returned by the operator parser to the results returned by the content parser. assocR Executes a content parser zero or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser. assoc1R Executes a content parser one or more times with an application of an operator parser between each. Returns the value obtained by right associative application of all functions returned by the operator parser to the results returned by the content parser.","title":"Table 5: Sequence combinators"},{"location":"api/#table-6-alternative-and-conditional-combinators","text":"Parser Description alt Executes a series of parsers one at a time until one succeeds. opt Executes a parser and returns its result on success. On failure, succeeds but returns nothing. def Executes a parser and returns either its result upon success or a default value upon failure. peek Executes a parser and returns its result without consuming input. empty Executes a parser and fails if the parser succeeds but consumes input. not Executes a parser and succeeds without consuming input if that parser fails.","title":"Table 6: Alternative and conditional combinators"},{"location":"api/#table-7-backtracking-combinators","text":"Parser Description attempt Executes a parser, backtracking to its original position if the parser fails and consumes input. seqB Executes a series of parsers in order, returning their results in an array. Backtracks to where the first parser was applied if any other of its parsers fails. blockB Runs a generator function. The generator can yield parsers, whose results will be returned as the result of the yield expressions. Returns the result of the generator. Backtracks to where the first yielded parser was applied if any later parser fails. chainB Executes a parser, then applies a function to the result, then applies the parser returned by the function. Backtracks to where the first parser was applied if the parser returned by the function fails. applyB Parses content and a function, returning the result of the function when passed the content. Backtracks to where the first parser was applied if the second parser fails. leftB Executes two parsers in order and returns the result of the first one. Backtracks to the location where the first parser was applied if the second one fails. rightB Executes two parsers in order and returns the result of the second one. Backtracks to the location where the first parser was applied if the second one fails. pipeB Executes a series of parsers in order, then passes the results as arguments to a function, then returns the result of that function. Backtracks to where the first parser was applied if any other parser fails. repeatB Executes a parser a certain number of times, returning the results in an array. Backtracks to where the first parser was applied if any other parser fails. untilB Executes a content parser zero or more times until an end parser succeeds. Returns the content parser's results. Backtracks to where the content parser was first applied if it fails before the end parser succeeds. betweenB Executes a content parser between two other parsers, returning only the content parser's result. Backtracks to where the first parser was applied if either other parser fails.","title":"Table 7: Backtracking combinators"},{"location":"api/#table-8-chaining-combinators","text":"Parser Description chain Applies a parser, then applies a function to the result, then applies the parser returned by the function. map Applies a parser, then applies a function to the result, then returns the result of that function. apply Parses content and a function, returning the result of the function when passed the content. value Executes a parser and returns a value. nth Executes a parser and returns the nth element of the resulting array. first Executes a parser and returns the first element of the resulting array. second Executes a parser and returns the second element of the resulting array. third Executes a parser and returns the third element of the resulting array. fourth Executes a parser and returns the fourth element of the resulting array. fifth Executes a parser and returns the fifth element of the resulting array. join Executes a parser and returns its resulting array elements joined together into a string. compact Executes a parser and returns its resulting array minus any null or undefined elements.","title":"Table 8: Chaining combinators"},{"location":"api/#tools","text":"Tools provide ways to run parsers and ways to write new parsers (if block isn't good enough). Regular users will use the functions in Table 10, but those in Tables 11 and 12 are going to be of interest only to parser authors.","title":"Tools"},{"location":"api/#table-9-running-parsers","text":"Function Description parse Executes a parser. succeeded Determines whether a parser result was successful. status Returns the status of a parser result. success Returns the value from a parser result if it was successful. failure Returns the error message from a parser result if it failed. run Executes a parser and either returns a successful result or throws an error.","title":"Table 9: Running parsers"},{"location":"api/#table-10-error-generation","text":"Function Description expected Creates an error list containing a single expected error message. unexpected Creates an error list containing a single unexpected error message. generic Creates an error list containing a single generic error message. nested Adds a nested error to an error list. compound Adds a compound error to an error list. other Creates an error list containing a single other error message. merge Merges two error lists. formatErrors Generates an error message out of a parser context and result. getPosition Determines the line/column position of a given context.","title":"Table 10: Error generation"},{"location":"api/#table-11-authoring-parsers","text":"Function Description parser Creates a new parser. okReply Generates a reply representing a success. failReply Generates a reply representing a failure. fatalReply Generates a reply representing a fatal failure.","title":"Table 11: Authoring parsers"},{"location":"api/#types","text":"Kessel is written in JavaScript, which is a dynamically typed language, and so none of these types actually exist within the code. However, there is a lot of consistency around what functions expect from parameters and what they provide as return values, and we are able to document that here. For TypeScript users, there will be a declaration file provided which will codify all of these types.","title":"Types"},{"location":"api/#table-13-types","text":"Type Description CompoundError A nested error that happened at a different location than the current context and has its own error message. Context The parsing context, which changes as more of the input is parsed. ErrorList A list of parsing errors. ErrorType The type of a parsing error, used to determine how it should be displayed in an error message. Formatter A function that formats error information into a string. Input Parser input text, which can be in one of several different forms. LocalError A simple parsing error. NestedError An error that happened at a different location than the current context. Parser A function which actually performs parsing. Reply The state of a parser after it has performed its parsing, consisting of an updated context and a result. Result The output of a parser, consisting of either a parsed value or a parsing error. Status The condition of a parser result, including whether the parse succeeded or not.","title":"Table 13: Types"},{"location":"installation/","text":"Installation npm install @barandis/kessel This won't actually be available on NPM until I finish basic documentation, which should happen around the beginning of December. There are also self-contained files ( kessel.js and the minified kessel.min.js ) in the lib directory of the distribution. These will work in the browser (where a global kessel object is provided) or with CommonJS or AMD. Assertions The default Kessel library uses assertions to ensure that input to parsers is what it's supposed to be. This is more than type-checking like in TypeScript - runtime failures will result if the wrong kind of input is given to a parser. Defensive programming is not normally a philosophy that I take to, but understanding the source of errors is so important in parsing that it seems appropriate here. The assertions slow down parsing, though I suspect that the amount of time added is negligible (this has not yet been benchmarked, though that is on the list of things to do). Every input that has a definitive type is checked, so if you have a alt that takes a thousand parsers, maybe that will be a bit slower. The distribution does contain versions without assertions, named kessel.noassert.js and kessel.noassert.min.js . If you are seriously concerned about performance you can choose to use these instead.","title":"Installation"},{"location":"installation/#installation","text":"npm install @barandis/kessel This won't actually be available on NPM until I finish basic documentation, which should happen around the beginning of December. There are also self-contained files ( kessel.js and the minified kessel.min.js ) in the lib directory of the distribution. These will work in the browser (where a global kessel object is provided) or with CommonJS or AMD.","title":"Installation"},{"location":"installation/#assertions","text":"The default Kessel library uses assertions to ensure that input to parsers is what it's supposed to be. This is more than type-checking like in TypeScript - runtime failures will result if the wrong kind of input is given to a parser. Defensive programming is not normally a philosophy that I take to, but understanding the source of errors is so important in parsing that it seems appropriate here. The assertions slow down parsing, though I suspect that the amount of time added is negligible (this has not yet been benchmarked, though that is on the list of things to do). Every input that has a definitive type is checked, so if you have a alt that takes a thousand parsers, maybe that will be a bit slower. The distribution does contain versions without assertions, named kessel.noassert.js and kessel.noassert.min.js . If you are seriously concerned about performance you can choose to use these instead.","title":"Assertions"},{"location":"overview/","text":"Overview Kessel is a parser combinator library inspired heavily by the Parsec library written in Haskell and its F# counterpart FParsec . It shares many of the features of these libraries, brought to JavaScript, and includes some others. Full UTF-8 support, including 3- and 4-byte characters that JavaScript doesn't regularly support Detailed error messages and facilities to customize error messages Optimized implementations of combinators to help make up for the relative slowness of parser combinators in general Written in a consistent functional style, which makes it natural to create new parsers that look and work just like the packaged ones Selectable backtracking Ability to write arbitrary functions that contain other parsers and can be used as parsers themselves To illustrate, here's a short parser definition for a CSV parser. This is a fully featured parser which can handle quoted commas, escaped quotes, and the like. This example is taken from a similar example in the online book Real World Haskell . It's shorter than the Haskell/Parsec version, but JavaScript's lack of custom operators means it's perhaps a bit more dense. Parser Code import { alt , char , end , join , many , newline , noneOf , run , second , sep , seqB , string , value , } from '@barandis/kessel' const quotedChar = alt ( noneOf ( '\"' ), value ( string ( '\"\"' ), '\"' )) const quotedCell = second ( seqB ( char ( '\"' ), join ( many ( quotedChar )), char ( '\"' , 'quote at end of cell' ), )) const cell = alt ( quotedCell , join ( many ( noneOf ( ',\\n\\r' )))) const line = sep ( cell , char ( ',' )) const csv = end ( line , newline ) const parseCsv = input => run ( csv , input ) Example Run // CSV input is from Wikipedia's article on comma-separated values // https://en.wikipedia.org/wiki/Comma-separated_values#Example const text = `Year,Make,Model,Description,Price 1997,Ford,E350,\"ac, abs, moon\",3000.00 1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00 1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",,5000.00 1996,Jeep,Grand Cherokee,\"MUST SELL! air, moon roof, loaded\",4799.00` const result = parseCsv ( text ) // `result` is equal to the following: // [ // ['Year', 'Make', 'Model', 'Description', 'Price'], // ['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition\"', '', '4900.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition, Very Large\"', '', '5000.00'], // ['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL! air, moon roof, loaded', '4799.00'] // ]","title":"Overview"},{"location":"overview/#overview","text":"Kessel is a parser combinator library inspired heavily by the Parsec library written in Haskell and its F# counterpart FParsec . It shares many of the features of these libraries, brought to JavaScript, and includes some others. Full UTF-8 support, including 3- and 4-byte characters that JavaScript doesn't regularly support Detailed error messages and facilities to customize error messages Optimized implementations of combinators to help make up for the relative slowness of parser combinators in general Written in a consistent functional style, which makes it natural to create new parsers that look and work just like the packaged ones Selectable backtracking Ability to write arbitrary functions that contain other parsers and can be used as parsers themselves To illustrate, here's a short parser definition for a CSV parser. This is a fully featured parser which can handle quoted commas, escaped quotes, and the like. This example is taken from a similar example in the online book Real World Haskell . It's shorter than the Haskell/Parsec version, but JavaScript's lack of custom operators means it's perhaps a bit more dense. Parser Code import { alt , char , end , join , many , newline , noneOf , run , second , sep , seqB , string , value , } from '@barandis/kessel' const quotedChar = alt ( noneOf ( '\"' ), value ( string ( '\"\"' ), '\"' )) const quotedCell = second ( seqB ( char ( '\"' ), join ( many ( quotedChar )), char ( '\"' , 'quote at end of cell' ), )) const cell = alt ( quotedCell , join ( many ( noneOf ( ',\\n\\r' )))) const line = sep ( cell , char ( ',' )) const csv = end ( line , newline ) const parseCsv = input => run ( csv , input ) Example Run // CSV input is from Wikipedia's article on comma-separated values // https://en.wikipedia.org/wiki/Comma-separated_values#Example const text = `Year,Make,Model,Description,Price 1997,Ford,E350,\"ac, abs, moon\",3000.00 1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00 1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",,5000.00 1996,Jeep,Grand Cherokee,\"MUST SELL! air, moon roof, loaded\",4799.00` const result = parseCsv ( text ) // `result` is equal to the following: // [ // ['Year', 'Make', 'Model', 'Description', 'Price'], // ['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition\"', '', '4900.00'], // ['1999', 'Chevy', 'Venture \"Extended Edition, Very Large\"', '', '5000.00'], // ['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL! air, moon roof, loaded', '4799.00'] // ]","title":"Overview"},{"location":"guide/ch-00/","text":"This user's guide is an in-depth introduction to parsing with Kessel. It explains what parsers are and how they work, covers the most common and important combinators, and explains how you can improve your parsers by improving their error messages. The goal of this guide is to get you to a place where you can write useful, real-world parsers with Kessel. It doesn't cover every feature (see the API Documentation for that) but concentrates on concepts that can be used over and over whatever features you use and whatever parsers you write.","title":"Introduction"},{"location":"guide/ch-01/","text":"Most programmers probably have a good intuitive idea of what a parser is: it's some code that reads a piece of a longer string of text. By that reckoning, this might be the world's simplest parser: const parser = text => { const [ char , ... rest ] = text return [ char , rest ] } This simple little function strips the first character off the text and returns it along with the rest of the unparsed text (which can then have the parser called on it again). It matches any character, so it's like Kessel's any parser. This example parser doesn't handle parsing errors (what happens when text is the empty string?) and is pretty simplistic with what it can work with, but it shares a surprising amount with a Kessel parser. The TypeScript type of the example parser is (text: string) => [string, string] . It takes a string and returns a tuple of two strings, one for the parsed character and one for the remaining text. !!! note \"Tuples\" JavaScript, of course, doesn't have tuples. However, its arrays act very much like tuples in that, unlike most other languages, they can have elements of different types. We consistently use the term tuple when using arrays like this. The TypeScript type of a Kessel parser is very similar: Parser<T> = (ctx: Context) => [Context, Result<T>] A parser in Kessel is a function which takes a context as an argument. It returns an updated context, along with a result. These types are just enhanced versions of what is in the simple parser; a context is just the input text along with information about the current parsing location within that text, and a result is either the parsed value (if the parser was successful) or error information (if it was not). !!! note \"TypeScript types\" Kessel is written in JavaScript, and its author regards TypeScript as a solution looking for a problem. However, one of the purposes of a type system is to create a common language, and we use that here to talk about parameters and return types. If you're not coding in TypeScript, you can safely regard types as nothing more than documentation. Basic parsers Many of the parsers that Kessel come ready to go without any additional information needed. A good example of this is letter . letter is a function that attempts to match a character in the range 'a'-'z' or 'A'-'Z' in the current location in the context passed into it. If it does, the parser is successful; the returned tuple will have a context updated to show which is the next character to parse, along with a result that has the parsed character as its value. There are a few of these basic parsers that match certain classes of characters, like digits, whitespace, and different cases of letters. And of course there's any , which like our simple little example above, parses any character at all. Parser functions The letter parser is ready to use right out of the box; it has all of the information that it needs to do its job. But most parsers need a little extra to get started. For instance, char is a parser that parses only a particular character, but it doesn't automatically know which character, so we have to have a way to tell it. That's done with parameters, and in the case of char , it's just a single parameter that is the character the parser should be trying to parse. char('a') will try to match the letter 'a' , while char('\u042f') will match a Russian capital letter \"Ya\". In this guide we refer to char as a parser function . Wait a minute... A couple paragraphs back, we said \" char is a parser...\", but then we said that char takes a character as an argument. But we've also said that parsers take contexts as arguments, not characters. So what gives? Technically, char isn't a parser at all. It's a function that returns a parser (hence calling it a parser function ). Therefore, while char may not be a parser, char('a') is, and char('\u042f') is a different parser. We don't ever use char by itself; we always use it with an argument. This is the same as saying that we never use the parser function by itself; we instead always use parsers it returns. So unless there's good reason to get into the technical aspect, it's pretty safe just to call them all parsers . Combinators Finally, there is a class of parser functions that take other parsers for their arguments. These parsers are called combinators and hold a special place in a library like Kessel because they can do things that no regular parser can do. They deserve several chapters of discussion, and we'll do just that starting in Chapter 4 .","title":"1. Parsers Parsers Parsers"},{"location":"guide/ch-01/#basic-parsers","text":"Many of the parsers that Kessel come ready to go without any additional information needed. A good example of this is letter . letter is a function that attempts to match a character in the range 'a'-'z' or 'A'-'Z' in the current location in the context passed into it. If it does, the parser is successful; the returned tuple will have a context updated to show which is the next character to parse, along with a result that has the parsed character as its value. There are a few of these basic parsers that match certain classes of characters, like digits, whitespace, and different cases of letters. And of course there's any , which like our simple little example above, parses any character at all.","title":"Basic parsers"},{"location":"guide/ch-01/#parser-functions","text":"The letter parser is ready to use right out of the box; it has all of the information that it needs to do its job. But most parsers need a little extra to get started. For instance, char is a parser that parses only a particular character, but it doesn't automatically know which character, so we have to have a way to tell it. That's done with parameters, and in the case of char , it's just a single parameter that is the character the parser should be trying to parse. char('a') will try to match the letter 'a' , while char('\u042f') will match a Russian capital letter \"Ya\". In this guide we refer to char as a parser function . Wait a minute... A couple paragraphs back, we said \" char is a parser...\", but then we said that char takes a character as an argument. But we've also said that parsers take contexts as arguments, not characters. So what gives? Technically, char isn't a parser at all. It's a function that returns a parser (hence calling it a parser function ). Therefore, while char may not be a parser, char('a') is, and char('\u042f') is a different parser. We don't ever use char by itself; we always use it with an argument. This is the same as saying that we never use the parser function by itself; we instead always use parsers it returns. So unless there's good reason to get into the technical aspect, it's pretty safe just to call them all parsers .","title":"Parser functions"},{"location":"guide/ch-01/#combinators","text":"Finally, there is a class of parser functions that take other parsers for their arguments. These parsers are called combinators and hold a special place in a library like Kessel because they can do things that no regular parser can do. They deserve several chapters of discussion, and we'll do just that starting in Chapter 4 .","title":"Combinators"},{"location":"guide/ch-02/","text":"Now we've seen a couple examples of Kessel parsers, but we haven't actually done anything with them. A parser isn't worth much if you don't give it some text to parse, and we haven't seen how to do that yet. Let's fix that. Kessel offers up the function run to run a parser against input text. It handles creating the context which is then passed to the parser that's being run. We'll talk about that context in a bit, but first let's make a parser just run. I will be doing this in a Node.js REPL. Enter node into a terminal and it should greet you with a message similar to this (the version number may, of course, be different). Welcome to Node.js v14.13.0. Type \".help\" for more information. > The only setup we need is to make sure Kessel is loaded. Locate kessel.js and include it in a require expression. (As I write this, I'm working in a local copy of the repo itself, so it's at ./lib/kessel.js for me; change that part in the command below to match where it is for you.) > let K = require('./lib/kessel') undefined And we're ready to go. This is the way I'm running every example in this user's guide and in the tutorial. There are lots of different ways to run JavScripot code and you can run it any way you want...load it into a browser via a local webpage, write and execute scripts, however you like. Running a parser Let's run a simple parser. > K.run(K.letter, 'abcdef') 'a' run executes the letter parser against the input, and letter matches the first character, which run returns. Namespaces Since we assigned the require expression to the variable K , all of Kessel's parsers and functions are available as properties on K . This might be convenient in code so that you can easily differentiate which parsers came from Kessel and which are custom. Another good way to do it is by destructuring the require expression: const { run, letter } = require('./lib/kessel') Then you could call the parsers and functions without the K prefix. > run(letter, 'abcdef') 'a' This is the way I normally write JavaScript code. However, when working in a REPL as we are here, it's not very convenient to have to know exactly which library functions you're going to use at the very beginning, so we import them all into K and use them from there. What if the parser fails? > K.run(K.letter, '123456') Uncaught Error: Parse error at (line 1, column 1): 123456 ^ Expected a letter A short stack trace follows that, but that's not as interesting as the error message. That message gives the line and column number where the error happened, prints out the line and points to the location, and says what was expected. In a short example, this information isn't that helpful, but if you're parsing a thousand-line document that uses 500 different parsers, you'll appreciate the detail of the error messages. ... Parsing a parser? So after all of the talk in Chapter 1 about contexts , we come over here and see no hint of a context at all when we're running our first parser. Well, that is the way of things. Contexts are handled transparently. run creates the context out of the input text you give to it, and even when we get to composite parsers, we'll see that the context gets passed from parser to parser without us ever even having to see it. You can write an extraordinarily complex parser with Kessel and never even have to know that contexts exist. But run isn't the only game in town. In fact, run is pretty quick and dirty, either returning a successful result or just bailing with an exception. Oftentimes we would like more control than that. That's where parse comes in. parse does everything almost the same as run . It accepts the same arguments (a parser and some input text), it creates the context in the background, it executes the parser against that context. The difference is in what it returns. > K.parse(K.letter, 'abcdef') [ { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 1 }, { status: 'ok', value: 'a' } ] Alright, so that's a little more involved than the 'a' that run returned. Given a little thought, you might guess that what we have here is the infamous [Context, Result<T>] tuple that we talked about in Chapter 1 , and you would be right. parse basically takes the output tuple that its parser returns and passes it right along to us. This is really notable when we run a parser that fails. run throws an exception, but parse is a different story. > K.parse(K.letter, '123456') [ { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 0 }, { status: 'fail', errors: [ [Object] ] } ] So parse gives us a window into the way that parsers work internally since it returns all of the information that parsers use. To know what to do with all of this information, we're going to have to learn a little about Context and Result . Fortunately, we cover that next.","title":"2. Making Parsers Go"},{"location":"guide/ch-02/#running-a-parser","text":"Let's run a simple parser. > K.run(K.letter, 'abcdef') 'a' run executes the letter parser against the input, and letter matches the first character, which run returns. Namespaces Since we assigned the require expression to the variable K , all of Kessel's parsers and functions are available as properties on K . This might be convenient in code so that you can easily differentiate which parsers came from Kessel and which are custom. Another good way to do it is by destructuring the require expression: const { run, letter } = require('./lib/kessel') Then you could call the parsers and functions without the K prefix. > run(letter, 'abcdef') 'a' This is the way I normally write JavaScript code. However, when working in a REPL as we are here, it's not very convenient to have to know exactly which library functions you're going to use at the very beginning, so we import them all into K and use them from there. What if the parser fails? > K.run(K.letter, '123456') Uncaught Error: Parse error at (line 1, column 1): 123456 ^ Expected a letter A short stack trace follows that, but that's not as interesting as the error message. That message gives the line and column number where the error happened, prints out the line and points to the location, and says what was expected. In a short example, this information isn't that helpful, but if you're parsing a thousand-line document that uses 500 different parsers, you'll appreciate the detail of the error messages.","title":"Running a parser"},{"location":"guide/ch-02/#parsing-a-parser","text":"So after all of the talk in Chapter 1 about contexts , we come over here and see no hint of a context at all when we're running our first parser. Well, that is the way of things. Contexts are handled transparently. run creates the context out of the input text you give to it, and even when we get to composite parsers, we'll see that the context gets passed from parser to parser without us ever even having to see it. You can write an extraordinarily complex parser with Kessel and never even have to know that contexts exist. But run isn't the only game in town. In fact, run is pretty quick and dirty, either returning a successful result or just bailing with an exception. Oftentimes we would like more control than that. That's where parse comes in. parse does everything almost the same as run . It accepts the same arguments (a parser and some input text), it creates the context in the background, it executes the parser against that context. The difference is in what it returns. > K.parse(K.letter, 'abcdef') [ { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 1 }, { status: 'ok', value: 'a' } ] Alright, so that's a little more involved than the 'a' that run returned. Given a little thought, you might guess that what we have here is the infamous [Context, Result<T>] tuple that we talked about in Chapter 1 , and you would be right. parse basically takes the output tuple that its parser returns and passes it right along to us. This is really notable when we run a parser that fails. run throws an exception, but parse is a different story. > K.parse(K.letter, '123456') [ { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 0 }, { status: 'fail', errors: [ [Object] ] } ] So parse gives us a window into the way that parsers work internally since it returns all of the information that parsers use. To know what to do with all of this information, we're going to have to learn a little about Context and Result . Fortunately, we cover that next.","title":"...Parsing a parser?"},{"location":"guide/ch-03/","text":"For convenience, let's reprint the successful parse example from the last page. > K.parse(K.letter, 'abcdef') [ { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 1 }, { status: 'ok', value: 'a' } ] We know by now that this pair of objects is the context followed by the result. Let's go ahead now and discuss what those actually are . The context object Here's the isolated context object from the successful parse result above. { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 1 } Alright, that's fine, but the context is supposed to contain the input text itself. But where's the text? To answer that question, we're going to have to learn (just a little) about character encodings. The most common way to represent characters in the modern age is an encoding called UTF-8. In this encoding, each character is one to four bytes long; the one-byte characters happen to have the same encodings as ASCII characters. This made UTF-8 popular, especially in the West: ASCII is already a subset of UTF-8, and with the multi-byte characters there's plenty of room to cover all of the other languages of the world (with plenty of room left over for emojis). JavaScript comes from a time before UTF-8, and it represents its characters in a two-or-four-byte encoding. 1 The merits of an encoding like this aren't in question; in some ways they're even better because the less-variable length makes it easier to do some things internally within the language. But this encoding causes us some problems. In parsing, it's really important to have a solid concept of \"character\", and these four-byte characters are counted as two characters in most JavaScript operations. (For example, '\ud83c\udf54'.length === 2 is true even though the hamburger emoji is only one character.) Alright, so what does this have to do with context? Basically, since there are some pitfalls to JavaScript string encoding, Kessel has to put in some safeguards, and since it already has to bother with encoding to that degree, it just chucks it all and uses UTF-8 encoding instead. That means it can't use JavaScript strings internally, so instead it uses arrays of UTF-8 encoded bytes . When the context is created, the input text is converted into a UTF-8 byte array. That array is tucked away in the context object within a DataView , which is simply an object that makes it easier to access the byte array. You can see it if you look really close at that example context object again: { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 1 } There it is, it's the buffer property view property in the context. An ArrayBuffer object is a byte array, and this one happens to hold UTF-8 encoded bytes. Let's look a little closer, since this view doesn't show us much about it. > const [ctx1, res1] = K.parse(K.letter, 'abcdef') undefined > ctx1.view.buffer ArrayBuffer { [Uint8Contents]: <61 62 63 64 65 66>, byteLength: 6 } There's the text! The contents of the array buffer are six numbers, which just happen to be (in hexadecimal) the UTF-8 code points for the letters 'abcdef' . Mystery solved. 2 3 As for the rest of the context \u2014 well, there's just the index . It just points at the byte that is the next to be read when the next parser is applied. The byte array itself doesn't change once the context is created, so rather than stripping bytes off the front (as in the simple example at the start of Chapter 1 ), this index is simply updated. As a final note about context, let's see what happens to index in a parse failure. > K.parse(K.letter, '123456') [ { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 0 }, { status: 'fail', errors: [ [Object] ] } ] This time index does not move. When letter fails, it does not consume any input, so the next parse attempt will happen at the same place. index reflects this by remaining at 0 when letter fails. This happens with every parser in Kessel that is not a combinator \u2014 they are atomic, so when they fail, it's as though they never ran in the first place. 4 The result object Alright, that was the hard part. Results are easy. Let's isolate the result object of the passing letter parse from the top of this page: { status: 'ok', value: 'a' } Doesn't get much more straightforward than that. The status is 'ok' , which means that nothing failed. The value is 'a' , and it's not coincidental that it's the same as the return value of the successful run invocation from the last chapter . And that's all there is to it. So how does the failed case look? { status: 'fail', errors: [ [Object] ] } This time, the status again tells us how it all worked out, in this case that the parse failed. With failure, there is no value property; in its place is errors , which is an array of objects describing errors that happened in the parse (there can be more than one, but there was not in this case.) Here's a closer look at the object in that errors property. > const [ctx2, res2] = K.parse(K.letter, '123456') undefined > res2.errors[0] { type: 'expected', label: 'a letter' } Each of the errors is just an object with a type and a label . These are used for making nice error messages. There are other types of errors that have different properties than this, but that's something we'll look at later in the guide. Why parse ? Alright, so we've learned a lot about what goes on in the parser internals, but where does that get us in real life? Why wouldn't we just use run and not have to worry about all of these details? Fact is, you may find that run is indeed best for you. But there are certainly reasons to use parse instead. You don't want an exception thrown on failure. You want to write your own error message formatter. Your parser is embedded within other code that will check for the parser's success or failure and act accordingly. You want the added detail for any number of other reasons. If one of these reasons compels you to use parse , rest assured that there are some helper functions to let you avoid getting deep into the internals of a parser reply. Each of these functions takes the reply object that is returned by parse and picks out some part of it to return to you. success returns the same thing as run does, except that it returns null on failure rather than throwing an exception. failure does the opposite; it returns an error message on failure and returns null on success (again, no exception is thrown). succeeded returns true if the parse was successful and false if it was not. status returns 'ok' , 'fail' , or 'fatal' to tell how the parse went. (We'll talk about 'fatal' later in the guide.) Finally, there is formatErrors . This takes a failed reply and returns a detailed error message; it's the same error message that both run and failure use. Using formatErrors grants you access to more options, including the ability to send a custom formatting function in case you want something different out of the error messages. (See Formatter for information about what that function has to look like.) So that's a pretty deep dive into parser internals, but at this point we've done nothing more than parse a single letter off the front of a string. Let's face it, that's not very useful. In the next chapter, we'll start to address that. JavaScript implementations can choose their encoding, as long as how it acts conforms to the spec. And that spec mandates something that is a weird amalgam of UCS-2 and UTF-16; it's not quite UCS-2 because it has four-byte characters through pairs of two-byte code points called surrogate pairs , but it isn't quite UTF-16 because it allows partial and reversed surrogate pairs. \u21a9 JavaScript would encode this same string as <61 00 62 00 63 00 64 00 65 00 66 00> . \u21a9 To show how UTF-8 works, here's the same sort of thing, except using the first six letters of the Russian (Cyrillic) alphabet: > const [ctxr, resr] = K.parse(K.letter, '\u0430\u0431\u0432\u0433\u0434\u0435') undefined > ctxr.view.buffer ArrayBuffer { [Uint8Contents]: <d0 b0 d0 b1 d0 b2 d0 b3 d0 b4 d0 b5>, byteLength: 12 } Twelve bytes to represent six characters; in UTF-8, Russian letters are two bytes long. A JavaScript string with the same content would be encoded <30 04 31 04 32 04 33 04 34 04 35 04> . Even though these particular characters are the same length in both encodings, the encoding values are entirely different. \u21a9 Alright, one more thing about index : it is a byte index, not a character index. Let's see how it works in that Russian text again (this uses letterU because letter only succeeds with ASCII letters). > K.parse(K.letterU, '\u0430\u0431\u0432\u0433\u0434\u0435') [ { view: DataView { byteLength: 12, byteOffset: 0, buffer: [ArrayBuffer] }, index: 2 }, { status: 'ok', value: '\u0430' } ] This time index is incremented by 2, because Russian letters are two bytes long. \u21a9","title":"3. Parsers, How Do They Work?"},{"location":"guide/ch-03/#the-context-object","text":"Here's the isolated context object from the successful parse result above. { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 1 } Alright, that's fine, but the context is supposed to contain the input text itself. But where's the text? To answer that question, we're going to have to learn (just a little) about character encodings. The most common way to represent characters in the modern age is an encoding called UTF-8. In this encoding, each character is one to four bytes long; the one-byte characters happen to have the same encodings as ASCII characters. This made UTF-8 popular, especially in the West: ASCII is already a subset of UTF-8, and with the multi-byte characters there's plenty of room to cover all of the other languages of the world (with plenty of room left over for emojis). JavaScript comes from a time before UTF-8, and it represents its characters in a two-or-four-byte encoding. 1 The merits of an encoding like this aren't in question; in some ways they're even better because the less-variable length makes it easier to do some things internally within the language. But this encoding causes us some problems. In parsing, it's really important to have a solid concept of \"character\", and these four-byte characters are counted as two characters in most JavaScript operations. (For example, '\ud83c\udf54'.length === 2 is true even though the hamburger emoji is only one character.) Alright, so what does this have to do with context? Basically, since there are some pitfalls to JavaScript string encoding, Kessel has to put in some safeguards, and since it already has to bother with encoding to that degree, it just chucks it all and uses UTF-8 encoding instead. That means it can't use JavaScript strings internally, so instead it uses arrays of UTF-8 encoded bytes . When the context is created, the input text is converted into a UTF-8 byte array. That array is tucked away in the context object within a DataView , which is simply an object that makes it easier to access the byte array. You can see it if you look really close at that example context object again: { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 1 } There it is, it's the buffer property view property in the context. An ArrayBuffer object is a byte array, and this one happens to hold UTF-8 encoded bytes. Let's look a little closer, since this view doesn't show us much about it. > const [ctx1, res1] = K.parse(K.letter, 'abcdef') undefined > ctx1.view.buffer ArrayBuffer { [Uint8Contents]: <61 62 63 64 65 66>, byteLength: 6 } There's the text! The contents of the array buffer are six numbers, which just happen to be (in hexadecimal) the UTF-8 code points for the letters 'abcdef' . Mystery solved. 2 3 As for the rest of the context \u2014 well, there's just the index . It just points at the byte that is the next to be read when the next parser is applied. The byte array itself doesn't change once the context is created, so rather than stripping bytes off the front (as in the simple example at the start of Chapter 1 ), this index is simply updated. As a final note about context, let's see what happens to index in a parse failure. > K.parse(K.letter, '123456') [ { view: DataView { byteLength: 6, byteOffset: 0, buffer: [ArrayBuffer] }, index: 0 }, { status: 'fail', errors: [ [Object] ] } ] This time index does not move. When letter fails, it does not consume any input, so the next parse attempt will happen at the same place. index reflects this by remaining at 0 when letter fails. This happens with every parser in Kessel that is not a combinator \u2014 they are atomic, so when they fail, it's as though they never ran in the first place. 4","title":"The context object"},{"location":"guide/ch-03/#the-result-object","text":"Alright, that was the hard part. Results are easy. Let's isolate the result object of the passing letter parse from the top of this page: { status: 'ok', value: 'a' } Doesn't get much more straightforward than that. The status is 'ok' , which means that nothing failed. The value is 'a' , and it's not coincidental that it's the same as the return value of the successful run invocation from the last chapter . And that's all there is to it. So how does the failed case look? { status: 'fail', errors: [ [Object] ] } This time, the status again tells us how it all worked out, in this case that the parse failed. With failure, there is no value property; in its place is errors , which is an array of objects describing errors that happened in the parse (there can be more than one, but there was not in this case.) Here's a closer look at the object in that errors property. > const [ctx2, res2] = K.parse(K.letter, '123456') undefined > res2.errors[0] { type: 'expected', label: 'a letter' } Each of the errors is just an object with a type and a label . These are used for making nice error messages. There are other types of errors that have different properties than this, but that's something we'll look at later in the guide.","title":"The result object"},{"location":"guide/ch-03/#why-parse","text":"Alright, so we've learned a lot about what goes on in the parser internals, but where does that get us in real life? Why wouldn't we just use run and not have to worry about all of these details? Fact is, you may find that run is indeed best for you. But there are certainly reasons to use parse instead. You don't want an exception thrown on failure. You want to write your own error message formatter. Your parser is embedded within other code that will check for the parser's success or failure and act accordingly. You want the added detail for any number of other reasons. If one of these reasons compels you to use parse , rest assured that there are some helper functions to let you avoid getting deep into the internals of a parser reply. Each of these functions takes the reply object that is returned by parse and picks out some part of it to return to you. success returns the same thing as run does, except that it returns null on failure rather than throwing an exception. failure does the opposite; it returns an error message on failure and returns null on success (again, no exception is thrown). succeeded returns true if the parse was successful and false if it was not. status returns 'ok' , 'fail' , or 'fatal' to tell how the parse went. (We'll talk about 'fatal' later in the guide.) Finally, there is formatErrors . This takes a failed reply and returns a detailed error message; it's the same error message that both run and failure use. Using formatErrors grants you access to more options, including the ability to send a custom formatting function in case you want something different out of the error messages. (See Formatter for information about what that function has to look like.) So that's a pretty deep dive into parser internals, but at this point we've done nothing more than parse a single letter off the front of a string. Let's face it, that's not very useful. In the next chapter, we'll start to address that. JavaScript implementations can choose their encoding, as long as how it acts conforms to the spec. And that spec mandates something that is a weird amalgam of UCS-2 and UTF-16; it's not quite UCS-2 because it has four-byte characters through pairs of two-byte code points called surrogate pairs , but it isn't quite UTF-16 because it allows partial and reversed surrogate pairs. \u21a9 JavaScript would encode this same string as <61 00 62 00 63 00 64 00 65 00 66 00> . \u21a9 To show how UTF-8 works, here's the same sort of thing, except using the first six letters of the Russian (Cyrillic) alphabet: > const [ctxr, resr] = K.parse(K.letter, '\u0430\u0431\u0432\u0433\u0434\u0435') undefined > ctxr.view.buffer ArrayBuffer { [Uint8Contents]: <d0 b0 d0 b1 d0 b2 d0 b3 d0 b4 d0 b5>, byteLength: 12 } Twelve bytes to represent six characters; in UTF-8, Russian letters are two bytes long. A JavaScript string with the same content would be encoded <30 04 31 04 32 04 33 04 34 04 35 04> . Even though these particular characters are the same length in both encodings, the encoding values are entirely different. \u21a9 Alright, one more thing about index : it is a byte index, not a character index. Let's see how it works in that Russian text again (this uses letterU because letter only succeeds with ASCII letters). > K.parse(K.letterU, '\u0430\u0431\u0432\u0433\u0434\u0435') [ { view: DataView { byteLength: 12, byteOffset: 0, buffer: [ArrayBuffer] }, index: 2 }, { status: 'ok', value: '\u0430' } ] This time index is incremented by 2, because Russian letters are two bytes long. \u21a9","title":"Why parse?"},{"location":"guide/ch-04/","text":"","title":"4. Combining Parsers"},{"location":"parsers/all/","text":"all: Parser<string> Parses the entire remaining input. Example const parser = all const s = parse ( parser , 'content' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"content\" Success Always succeeds. Consumes all remaining characters and returns those characters as a single string. If the current parse location is already at the end of input, all will return the empty string and consume nothing. See Also Parser anyString eof","title":"all"},{"location":"parsers/all/#example","text":"const parser = all const s = parse ( parser , 'content' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"content\"","title":"Example"},{"location":"parsers/all/#success","text":"Always succeeds. Consumes all remaining characters and returns those characters as a single string. If the current parse location is already at the end of input, all will return the empty string and consume nothing.","title":"Success"},{"location":"parsers/all/#see-also","text":"Parser anyString eof","title":"See Also"},{"location":"parsers/alpha/","text":"alpha: Parser<string> Parses an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). This does not parse UTF-8 alphanumeric characters in general. Use alphaU for that. Example const parser = alpha const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '---' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected an alphanumeric character Success Succeeds if the next character is an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alphaU letter lower upper","title":"alpha"},{"location":"parsers/alpha/#example","text":"const parser = alpha const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '---' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected an alphanumeric character","title":"Example"},{"location":"parsers/alpha/#success","text":"Succeeds if the next character is an ASCII alphanumeric character ( 0-9 , a-z , or A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/alpha/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/alpha/#see-also","text":"Parser alphaU letter lower upper","title":"See Also"},{"location":"parsers/alphau/","text":"alphaU: Parser<string> Parses a Unicode alphanumeric character. A character is a Unicode alphanumeric character if it has either the Unicode Alphabetic binary property or the Unicode Number binary property. Example const parser = alphaU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '---' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected a Unicode alphanumeric character Success Succeeds if the next character is a Unicode alphanumeric character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alpha letterU lowerU upperU","title":"alphaU"},{"location":"parsers/alphau/#example","text":"const parser = alphaU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '---' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // --- // ^ // Expected a Unicode alphanumeric character","title":"Example"},{"location":"parsers/alphau/#success","text":"Succeeds if the next character is a Unicode alphanumeric character. Consumes and returns that character.","title":"Success"},{"location":"parsers/alphau/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/alphau/#see-also","text":"Parser alpha letterU lowerU upperU","title":"See Also"},{"location":"parsers/alt/","text":"alt(...ps: Parser[], m?: string): Parser Applies each of its parsers, one at a time, until the first one succeeds, the first one fails fatally, or they all fail. If a parser in ps succeeds, no further parsers will be applied and the result of the successful parser will be returned. If a parser in ps fails fatally, no further parsers will be applied and alt will fail fatally. This rule is necessary to ensure that each branch of the alt is starting from the same state (a fatal failure generally means input is consumed and the state has therefore changed). If all parsers in ps fail, then alt fails as well. alt(p, q) is the same as orElse(p, q) , while alt(p, q, r) is the same as orElse(orElse(p, q), r) , etc. Because of JavaScript's lack of custom operators, alt becomes much more commonly used. In languages with custom operators, that orElse(orElse(p, q), r) would become a much more manageable p <|> q <|> r (if orElse was implemented as <|> , as it is in Parsec and FParsec), and alt itself would be less necessary. orElse(p, q) is more efficient than alt(p, q) , though once a third parser is added alt becomes more efficient. The differences should not be enough to be of concern. Example const parser = alt ( left ( letter , digit ), right ( digit , letter ), space ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const r = parse ( parser , '1a' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // \"a\" const p = parse ( parser , ' ' ) console . log ( status ( p )) // \"ok\" console . log ( success ( p )) // \" \" const f = parse ( parser , '-a' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // -a // ^ // Expected a letter, a digit, or whitespace const t = parse ( parser , 'a ' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit or a letter The example shows three success cases, s , r , and p , one for each parser passed to alt . If all of these fail, as in the first failure case ( f ), then failure is the result. In the second failure case ( t ), the first parser fails but consumes input as it does so, so alt is halted at that point without applying its second or third parsers. Fatal failure is the result. Parameters ...ps : The parsers to apply one at a time until one succeeds. m : An optional message to be used as the expected error message in the event of failure, in place of the collected expected error messages of the parsers in ps . Success Succeeds if any parser in ps succeeds. Its result is returned. Failure Fails if every parser in ps fails. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws if any member of ps is not a parser. See Also Parser attempt seq","title":"alt"},{"location":"parsers/alt/#example","text":"const parser = alt ( left ( letter , digit ), right ( digit , letter ), space ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const r = parse ( parser , '1a' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // \"a\" const p = parse ( parser , ' ' ) console . log ( status ( p )) // \"ok\" console . log ( success ( p )) // \" \" const f = parse ( parser , '-a' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // -a // ^ // Expected a letter, a digit, or whitespace const t = parse ( parser , 'a ' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a // ^ // Expected a digit or a letter The example shows three success cases, s , r , and p , one for each parser passed to alt . If all of these fail, as in the first failure case ( f ), then failure is the result. In the second failure case ( t ), the first parser fails but consumes input as it does so, so alt is halted at that point without applying its second or third parsers. Fatal failure is the result.","title":"Example"},{"location":"parsers/alt/#parameters","text":"...ps : The parsers to apply one at a time until one succeeds. m : An optional message to be used as the expected error message in the event of failure, in place of the collected expected error messages of the parsers in ps .","title":"Parameters"},{"location":"parsers/alt/#success","text":"Succeeds if any parser in ps succeeds. Its result is returned.","title":"Success"},{"location":"parsers/alt/#failure","text":"Fails if every parser in ps fails.","title":"Failure"},{"location":"parsers/alt/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/alt/#throws","text":"Throws if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/alt/#see-also","text":"Parser attempt seq","title":"See Also"},{"location":"parsers/always/","text":"always<T>(x: T): Parser<T> Always succeeds and returns its passed value. This is the only parser that can return a value that is not a string. (Some combinators can also do this.) This parser serves both as the pure member of the Applicative type class and the return member of the Monad type class in Haskell. It can be used to lift arbitrary values into the context of a parser, particularly to lift functions to allow them to be used by apply and to lift values that functions return to allow them to be used by chain . Example const parser = always ( 3.14 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 3.14 Parameters x : An arbitrary value that this parser always returns. Success Always succeeds. Returns x and consumes no input. See Also Parser apply chain value","title":"always"},{"location":"parsers/always/#example","text":"const parser = always ( 3.14 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 3.14","title":"Example"},{"location":"parsers/always/#parameters","text":"x : An arbitrary value that this parser always returns.","title":"Parameters"},{"location":"parsers/always/#success","text":"Always succeeds. Returns x and consumes no input.","title":"Success"},{"location":"parsers/always/#see-also","text":"Parser apply chain value","title":"See Also"},{"location":"parsers/any/","text":"any: Parser<string> Parses any single character. Example const parser = any const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Success Succeeds as long as there is a character to be read. That character is consumed and returned. Failure Fails at the end of input. See Also Parser anyString","title":"any"},{"location":"parsers/any/#example","text":"const parser = any const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/any/#success","text":"Succeeds as long as there is a character to be read. That character is consumed and returned.","title":"Success"},{"location":"parsers/any/#failure","text":"Fails at the end of input.","title":"Failure"},{"location":"parsers/any/#see-also","text":"Parser anyString","title":"See Also"},{"location":"parsers/anyof/","text":"anyOf(cs: string | string[]): Parser<string> Parses a character if that character is included in cs . Example const parser = anyOf ( 'Test' ) const s = parse ( parser , 'Test' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"T\" const f = parse ( parser , 'Exit' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Exit // ^ // Expected any of 'T', 'e', 's', or 't' Parameters cs : The set of characters that the next character is expected to be a part of. This can be either a string or an array of single-character strings. Success Succeeds if the next character is one of the characters in cs . Consumes and returns that character. Failure Fails if the next character is any other character. Throws Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length. See Also Parser noneOf","title":"anyOf"},{"location":"parsers/anyof/#example","text":"const parser = anyOf ( 'Test' ) const s = parse ( parser , 'Test' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"T\" const f = parse ( parser , 'Exit' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Exit // ^ // Expected any of 'T', 'e', 's', or 't'","title":"Example"},{"location":"parsers/anyof/#parameters","text":"cs : The set of characters that the next character is expected to be a part of. This can be either a string or an array of single-character strings.","title":"Parameters"},{"location":"parsers/anyof/#success","text":"Succeeds if the next character is one of the characters in cs . Consumes and returns that character.","title":"Success"},{"location":"parsers/anyof/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/anyof/#throws","text":"Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length.","title":"Throws"},{"location":"parsers/anyof/#see-also","text":"Parser noneOf","title":"See Also"},{"location":"parsers/anystring/","text":"anyString(n: number): Parser<string> Parses a string that is n characters long. Example const parser = anyString ( 3 ) const s = parse ( parser , 'abcdef' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"abc\" const f = parse ( parser , 'ab' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // Expected a string of 3 characters Parameters n : The number of characters to read. Success Succeeds if there are at least n characters remaining to read. Consumes that many characters and returns them as a single string. If n is less than 1, no characters will be consumed and the empty string will be returned. Failure Fails if there are not at least n characters remaining in the input. Throws Throws an error if n is not a number. See Also Parser all any","title":"anyString"},{"location":"parsers/anystring/#example","text":"const parser = anyString ( 3 ) const s = parse ( parser , 'abcdef' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"abc\" const f = parse ( parser , 'ab' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // Expected a string of 3 characters","title":"Example"},{"location":"parsers/anystring/#parameters","text":"n : The number of characters to read.","title":"Parameters"},{"location":"parsers/anystring/#success","text":"Succeeds if there are at least n characters remaining to read. Consumes that many characters and returns them as a single string. If n is less than 1, no characters will be consumed and the empty string will be returned.","title":"Success"},{"location":"parsers/anystring/#failure","text":"Fails if there are not at least n characters remaining in the input.","title":"Failure"},{"location":"parsers/anystring/#throws","text":"Throws an error if n is not a number.","title":"Throws"},{"location":"parsers/anystring/#see-also","text":"Parser all any","title":"See Also"},{"location":"parsers/apply/","text":"apply(p: Parser, q: Parser, m?: string): Parser Applies two parsers, the second of which must return a function. Returns the result of that function when the result of the other parser is passed to it. This parser is the applicative-style counterpart of the monadic-style chain . It corresponds to the <*> member of the Applicative type class in Haskell, which basically means that it's used for applying functions that are already \"inside\" a parser. As with chain it's not likely to see a lot of use, as none of the Kessel parsers are actually implemented in terms of it, but it's available should anyone feel the need to write parsers in an applicative style (or the JavaScript equivalent, which is certainly not as intuitive). As this parser requires that one of its parser return a function, always is often used to provide that parser. There is another version of this parser ( applyB ) that will backtrack and fail non-fatally if q fails non-fatally. Example const parser = apply ( left ( letter , digit ), always ( c => c . toUpperCase ())) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Parameters p : A parser whose result is passed to the function that results from q . q : A parser that returns a function. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and q succeed. Returns the result of the function returned by q when applied to the result of p . Failure Fails if p fails. Fails if q fails after p succeeds without consuming any input. Fatal Failure Fails fatally if either p or q fails fatally. Fails if q fails after p succeeds while consuming some input. Throws Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. Throws an error if q succeeds but does not return a non-parser function. See Also Parser always applyB chain","title":"apply"},{"location":"parsers/apply/#example","text":"const parser = apply ( left ( letter , digit ), always ( c => c . toUpperCase ())) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a'","title":"Example"},{"location":"parsers/apply/#parameters","text":"p : A parser whose result is passed to the function that results from q . q : A parser that returns a function. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/apply/#success","text":"Succeeds if both p and q succeed. Returns the result of the function returned by q when applied to the result of p .","title":"Success"},{"location":"parsers/apply/#failure","text":"Fails if p fails. Fails if q fails after p succeeds without consuming any input.","title":"Failure"},{"location":"parsers/apply/#fatal-failure","text":"Fails fatally if either p or q fails fatally. Fails if q fails after p succeeds while consuming some input.","title":"Fatal Failure"},{"location":"parsers/apply/#throws","text":"Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. Throws an error if q succeeds but does not return a non-parser function.","title":"Throws"},{"location":"parsers/apply/#see-also","text":"Parser always applyB chain","title":"See Also"},{"location":"parsers/applyb/","text":"applyB(p: Parser, q: Parser, m?: string): Parser Applies two parsers, the second of which must return a function. Returns the result of that function when the result of the other parser is passed to it. If p succeeds but q fails, the parser will backtrack to the location where p was originally applied and applyB will fail non-fatally. Example const parser = applyB ( left ( letter , digit ), always ( c => c . toUpperCase ())) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Parameters p : A parser whose result is passed to the function that results from q . q : A parser that returns a function. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and q succeed. Returns the result of the function returned by q when applied to the result of p . Failure Fails if p or q fails. Fatal Failure Fails fatally if either p or q fails fatally. Throws Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. Throws an error if q succeeds but does not return a non-parser function. See Also Parser always apply chainB","title":"applyB"},{"location":"parsers/applyb/#example","text":"const parser = applyB ( left ( letter , digit ), always ( c => c . toUpperCase ())) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , '1a' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1a // ^ // Expected a letter const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a'","title":"Example"},{"location":"parsers/applyb/#parameters","text":"p : A parser whose result is passed to the function that results from q . q : A parser that returns a function. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/applyb/#success","text":"Succeeds if both p and q succeed. Returns the result of the function returned by q when applied to the result of p .","title":"Success"},{"location":"parsers/applyb/#failure","text":"Fails if p or q fails.","title":"Failure"},{"location":"parsers/applyb/#fatal-failure","text":"Fails fatally if either p or q fails fatally.","title":"Fatal Failure"},{"location":"parsers/applyb/#throws","text":"Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. Throws an error if q succeeds but does not return a non-parser function.","title":"Throws"},{"location":"parsers/applyb/#see-also","text":"Parser always apply chainB","title":"See Also"},{"location":"parsers/assoc1l/","text":"assoc1L(p: Parser, o: Parser, m?: string): Parser Parses one or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content left-associatively. The operation parser o must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so o must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If o succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first o to the values returned by the first two p s, then applying the function returned by the second o to that value and the value returned by the third p , and so on. assoc1L fails if p never succeeds, but it is not required that o ever succeed. If o never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1L ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 34 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocL for an explanation of the example. That example works identically to this one. Parameters p : The content parser. o : The operation parser. This parser must return a function. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds at least once and neither p nor o ever fail fatally. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned. Failure Fails if p fails on its first attempt. Fatal Failure Fails fatally if either p or o fail fatally. Throws Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string. See Also Parser assocL assoc1R","title":"assoc1L"},{"location":"parsers/assoc1l/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1L ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 34 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocL for an explanation of the example. That example works identically to this one.","title":"Example"},{"location":"parsers/assoc1l/#parameters","text":"p : The content parser. o : The operation parser. This parser must return a function. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/assoc1l/#success","text":"Succeeds if p succeeds at least once and neither p nor o ever fail fatally. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned.","title":"Success"},{"location":"parsers/assoc1l/#failure","text":"Fails if p fails on its first attempt.","title":"Failure"},{"location":"parsers/assoc1l/#fatal-failure","text":"Fails fatally if either p or o fail fatally.","title":"Fatal Failure"},{"location":"parsers/assoc1l/#throws","text":"Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/assoc1l/#see-also","text":"Parser assocL assoc1R","title":"See Also"},{"location":"parsers/assoc1r/","text":"assoc1R(p: Parser, o: Parser, m?: string): Parser Parses one or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content right-associatively. The operation parser o must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so o must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If o succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first o to the values returned by the first two p s, then applying the function returned by the second o to that value and the value returned by the third p , and so on. assoc1R fails if p never succeeds, but it is not required that o ever succeed. If o never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1R ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // -78 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocR for an explanation of the example. That example works identically to this one. Parameters p : The content parser. o : The operation parser. This parser must return a function. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds at least once and neither p nor o ever fail fatally. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned. Failure Fails if p fails on its first attempt. Fatal Failure Fails fatally if either p or o fail fatally. Throws Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string. See Also Parser assoc1L assocR","title":"assoc1R"},{"location":"parsers/assoc1r/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assoc1R ( number , op ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // -78 const f = parse ( parser , 'ab-cd+ef' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab-cd+ef // ^ // Expected a digit See assocR for an explanation of the example. That example works identically to this one.","title":"Example"},{"location":"parsers/assoc1r/#parameters","text":"p : The content parser. o : The operation parser. This parser must return a function. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/assoc1r/#success","text":"Succeeds if p succeeds at least once and neither p nor o ever fail fatally. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned.","title":"Success"},{"location":"parsers/assoc1r/#failure","text":"Fails if p fails on its first attempt.","title":"Failure"},{"location":"parsers/assoc1r/#fatal-failure","text":"Fails fatally if either p or o fail fatally.","title":"Fatal Failure"},{"location":"parsers/assoc1r/#throws","text":"Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/assoc1r/#see-also","text":"Parser assoc1L assocR","title":"See Also"},{"location":"parsers/assocl/","text":"assocL(p: Parser, o: Parser, x: *, m?: string): Parser Parses zero or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content left-associatively. The operation parser o must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so o must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If o succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first o to the values returned by the first two p s, then applying the function returned by the second o to that value and the value returned by the third p , and so on. If p never succeeds, assocL still succeeds, but it returns the value x directly. If o never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocL ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 34 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these left-associatively results in (12 - 34) + 56 , which evaluates to 34 . Parameters p : The content parser. o : The operation parser. This parser must return a function. x : The default return value. This is used as a result if p doesn't succeed at least once. m : The optional expected error message that will take the place of the default error message. Success Succeeds if neither p nor o fail fatally. If p never succeeds, x is returned. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned. Fatal Failure Fails fatally if either p or o fail fatally. Throws Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string. See Also Parser assoc1L assocR","title":"assocL"},{"location":"parsers/assocl/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocL ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 34 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is op , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these left-associatively results in (12 - 34) + 56 , which evaluates to 34 .","title":"Example"},{"location":"parsers/assocl/#parameters","text":"p : The content parser. o : The operation parser. This parser must return a function. x : The default return value. This is used as a result if p doesn't succeed at least once. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/assocl/#success","text":"Succeeds if neither p nor o fail fatally. If p never succeeds, x is returned. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned.","title":"Success"},{"location":"parsers/assocl/#fatal-failure","text":"Fails fatally if either p or o fail fatally.","title":"Fatal Failure"},{"location":"parsers/assocl/#throws","text":"Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/assocl/#see-also","text":"Parser assoc1L assocR","title":"See Also"},{"location":"parsers/assocr/","text":"assocR(p: Parser, o: Parser, x: *, m?: string): Parser Parses zero or more occurrences of a content parser, separated by an operation parser, then applies the operations to the content right-associatively. The operation parser o must return a function that will be applied to the results of the content parser p that surround it. Most parsers return strings or arrays, so o must be map , value , or one of the other small number of parsers that can return arbitrary values. p must be the last to match. If o succeeds but p fails after it, then the parser state is left at the location immediately after the last success of p . The result is constructed by applying the function returned by the first o to the values returned by the first two p s, then applying the function returned by the second o to that value and the value returned by the third p , and so on. If p never succeeds, assocR still succeeds, but it returns the value x directly. If o never succeeds but p succeeds once, that result from p is returned. Example const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocR ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // -78 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is o , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these right-associatively results in 12 - (34 + 56) , which evaluates to -78 . (This is not mathematically valid \u2014 subtraction is left-associative absent parentheses \u2014 but it serves to illustrate how right-associativity works.) Parameters p : The content parser. o : The operation parser. This parser must return a function. x : The default return value. This is used as a result if p doesn't succeed at least once. m : The optional expected error message that will take the place of the default error message. Success Succeeds if neither p nor o fail fatally. If p never succeeds, x is returned. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned. Fatal Failure Fails fatally if either p or o fail fatally. Throws Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string. See Also Parser assocL assoc1R","title":"assocR"},{"location":"parsers/assocr/#example","text":"const number = map ( join ( many ( digit )), x => parseInt ( x )) const op = orElse ( value ( char ( '+' ), ( a , b ) => a + b ), value ( char ( '-' ), ( a , b ) => a - b ), ) const parser = assocR ( number , op , 0 ) const s = parse ( parser , '12-34+56' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // -78 This is a complex parser, so an explanation of the example is in order. The content parser in this example is number , which gathers digits and parses them into an integer (this simple example does not recognize decimal points or signs). The operation parser is o , which matches either the character + or the character - and returns a function that adds two numbers or subtracts two numbers, respectively. When applied to the input '12-34+56' , the results of the content parser are 12 , 34 , and 56 , while the results of the operation parser are the function that subtracts two numbers and the function that adds two numbers. Applying these right-associatively results in 12 - (34 + 56) , which evaluates to -78 . (This is not mathematically valid \u2014 subtraction is left-associative absent parentheses \u2014 but it serves to illustrate how right-associativity works.)","title":"Example"},{"location":"parsers/assocr/#parameters","text":"p : The content parser. o : The operation parser. This parser must return a function. x : The default return value. This is used as a result if p doesn't succeed at least once. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/assocr/#success","text":"Succeeds if neither p nor o fail fatally. If p never succeeds, x is returned. If p succeeds once and o does not, the result of p is returned. Otherwise, the left associative application of the results of o to the results of p is returned.","title":"Success"},{"location":"parsers/assocr/#fatal-failure","text":"Fails fatally if either p or o fail fatally.","title":"Fatal Failure"},{"location":"parsers/assocr/#throws","text":"Throws an error if either p or o are not parsers. Throws an error if any result of o is not a function. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/assocr/#see-also","text":"Parser assocL assoc1R","title":"See Also"},{"location":"parsers/attempt/","text":"attempt(p: Parser, m?: string): Parser Applies a parser and, if it fails after consuming input, backtracks to the original location and fails non-fatally. attempt implements general backtracking. It is different from the backtracking B parsers ( seqB , leftB , etc.) in that it is meant to deal with all fatal failures (the B parsers only deal with fatal failures that result from non-fatal failures that come after successes). It's common to use this parser in conjunction with alt , opt , and other parsers which only fail if their parsers fail fatally. If an optional error message string is provided (as the second argument), then that message will become the new text of an error message for a regular failure, or it will become the text of a compound error message if the parser had to backtrack. Example const parser = attempt ( left ( letter , digit )) const parserm = attempt ( left ( letter , digit ), 'a letter, then a digit' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const n = parse ( parserm , '12' ) console . log ( status ( n )) // \"fail\" console . log ( failure ( n )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter, then a digit const b = parse ( parser , 'ab' ) console . log ( status ( b )) // \"fail\" console . log ( failure ( b )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit const c = parse ( parserm , 'ab' ) console . log ( status ( c )) // \"fail\" console . log ( failure ( c )) // Parse error at (line 1, column 1): // // ab // ^ // Could not be parse a letter, then a digit because: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p : The parser that is applied and backtracked over if it fails fatally. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns p 's result. Failure Fails if p fails. Fails if p fails fatally. In this case the fatal failure is turned into non-fatal failure and the state is backtracked to where it was before p was applied. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also NestedError Parser alt def opt","title":"attempt"},{"location":"parsers/attempt/#example","text":"const parser = attempt ( left ( letter , digit )) const parserm = attempt ( left ( letter , digit ), 'a letter, then a digit' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const n = parse ( parserm , '12' ) console . log ( status ( n )) // \"fail\" console . log ( failure ( n )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter, then a digit const b = parse ( parser , 'ab' ) console . log ( status ( b )) // \"fail\" console . log ( failure ( b )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit const c = parse ( parserm , 'ab' ) console . log ( status ( c )) // \"fail\" console . log ( failure ( c )) // Parse error at (line 1, column 1): // // ab // ^ // Could not be parse a letter, then a digit because: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/attempt/#parameters","text":"p : The parser that is applied and backtracked over if it fails fatally. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/attempt/#success","text":"Succeeds if p succeeds. Returns p 's result.","title":"Success"},{"location":"parsers/attempt/#failure","text":"Fails if p fails. Fails if p fails fatally. In this case the fatal failure is turned into non-fatal failure and the state is backtracked to where it was before p was applied.","title":"Failure"},{"location":"parsers/attempt/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/attempt/#see-also","text":"NestedError Parser alt def opt","title":"See Also"},{"location":"parsers/between/","text":"between(s: Parser, e: Parser, p: Parser, m?: string): Parser Applies a pre-parser, a content parser, and a post-parser in order, returning the value of the content parser. All three parsers must succeed for between to succeed. Take care to avoid parsing too far with p ; e.g., if the example used join(many(any)) as a content parser instead of what it does, it would also match the ending \" . This would mean that e would never succeed because p already consumed its \" , so between would never succeed. There is another version of this parser, betweenB , which backtracks and fails non-fatally if a non-fatal failure happens after input is consumed. between(s, e, p) is an optimized implementation of chain(chain(s, () => p), x => value(e, x)) . (Using higher-level parsers, this can also be written left(right(s, p), e) .) Example const parser = between ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input The first failure case in the example ( f ) is non-fatal failure, because no characters were consumed before the failure occurred. The second failure case ( t ) is fatal failure because, though e fails non-fatally, input was consumed before that failure happened. Parameters s : The parser that is applied first. Its result is discarded. e : The parser that is applied last. Its result is discarded. p : The parser that is applied after s and before e . Its result is returned by between itself. m : The optional expected error message that will take the place of the default error message. Success Succeeds if all three parsers succeed. Returns the result of p . Failure Fails if any of its three parsers fails before any input is consumed. Fatal Failure Fails fatally if any of its three parsers fails fatally. Fails fatally if any of its three parsers fails after some input was consumed. Throws Throws an error if any of s , e , and p are not parsers. Throws an error if m exists and is not a string. See Also Parser betweenB until","title":"between"},{"location":"parsers/between/#example","text":"const parser = between ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input The first failure case in the example ( f ) is non-fatal failure, because no characters were consumed before the failure occurred. The second failure case ( t ) is fatal failure because, though e fails non-fatally, input was consumed before that failure happened.","title":"Example"},{"location":"parsers/between/#parameters","text":"s : The parser that is applied first. Its result is discarded. e : The parser that is applied last. Its result is discarded. p : The parser that is applied after s and before e . Its result is returned by between itself. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/between/#success","text":"Succeeds if all three parsers succeed. Returns the result of p .","title":"Success"},{"location":"parsers/between/#failure","text":"Fails if any of its three parsers fails before any input is consumed.","title":"Failure"},{"location":"parsers/between/#fatal-failure","text":"Fails fatally if any of its three parsers fails fatally. Fails fatally if any of its three parsers fails after some input was consumed.","title":"Fatal Failure"},{"location":"parsers/between/#throws","text":"Throws an error if any of s , e , and p are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/between/#see-also","text":"Parser betweenB until","title":"See Also"},{"location":"parsers/betweenb/","text":"betweenB(pre: Parser<U>, post: Parser<V>, p: Parser<T>): Parser<T> Applies a pre-parser, a content parser, and a post-parser in order, returning the value of the content parser. All three parsers must succeed for betweenB to succeed. Take care to avoid parsing too far with p ; e.g., if the example used join(many(any)) as a content parser instead of what it does, it would also match the ending \" . This would mean that post would never succeed because p already consumed its \" , so betweenB would never succeed. If any of the parsers fails after some input was consumed, the state will be backtracked to where it was before pre was applied. Example const parser = betweenB ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // \"test // ^ // The parser backtracked after: // // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input Parameters pre : The parser that is applied first. Its result is discarded. post : The parser that is applied last. Its result is discarded. p : The parser that is applied after pre and before post . Its result is returned by between itself. Success Succeeds if all three parsers succeed. Returns the result of p . Failure Fails if any of its three parsers fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any of its three parsers fails fatally. Throws Throws an error if any of pre , post , and p are not parsers. See Also Parser between untilB","title":"betweenB"},{"location":"parsers/betweenb/#example","text":"const parser = betweenB ( char ( '\"' ), char ( '\"' ), join ( many ( noneOf ( '\"' )))) const s = parse ( parser , '\"test\"' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"test\" const f = parse ( parser , 'test\"' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test\" // ^ // Expected '\"' const t = parse ( parser , '\"test' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // \"test // ^ // The parser backtracked after: // // Parse error at (line 1, column 6): // // \"test // ^ // Expected '\"' // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/betweenb/#parameters","text":"pre : The parser that is applied first. Its result is discarded. post : The parser that is applied last. Its result is discarded. p : The parser that is applied after pre and before post . Its result is returned by between itself.","title":"Parameters"},{"location":"parsers/betweenb/#success","text":"Succeeds if all three parsers succeed. Returns the result of p .","title":"Success"},{"location":"parsers/betweenb/#failure","text":"Fails if any of its three parsers fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/betweenb/#fatal-failure","text":"Fails fatally if any of its three parsers fails fatally.","title":"Fatal Failure"},{"location":"parsers/betweenb/#throws","text":"Throws an error if any of pre , post , and p are not parsers.","title":"Throws"},{"location":"parsers/betweenb/#see-also","text":"Parser between untilB","title":"See Also"},{"location":"parsers/block/","text":"block(g: GeneratorFunction, m?: string): Parser Executes a generator function that can yield to parsers in its body. block is the most versatile parser in the entire library and provides a way to parse pretty much anything without having to write a custom parser. It corresponds to using do-notation blocks in Haskell (hence the name block ). The generator function can do anything that any function could do. In addition, it can have yield expressions that yield any parser. That parser will be applied at that point, and if it's successful, its result will be fed back into the generator function, able to be used as needed (for example, in const number = yield join(many1(digit)) in the example, the result of the join parser is assigned to the variable number ). When the generator function returns, its return value becomes the value returned by the block parser. If any of the parsers fail when yielded, then block will fail. If any input was consumed before the failure, that failure will be fatal. block can be used to implement pretty much any other combinator. It, in conjunction with any , could be used to implement any other parser in this library. However, if there is a parser that already does what needs to be done, it's sure to be more efficient than just shoving everything into a block . This is most notable with sequences. A block parser that discards a number of parser results and keeps one, returning that result, can very often be implemented as a seq wrapped in nth . This is a fairly common use case. Example const parser = block ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' 1729 ' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit The first yielded parser here is spaces . This skips zero or more whitespace characters. Its result is discarded as it is not assigned to anything (besides, spaces only returns null so its result isn't useful). The second yielded parser is opt(orElse(char('+'), char('-'))) . This will match either a '+' or '-' if it's there, or return null if the next character is neither of those (without opt it would fail, and we don't want that because it's okay for a number to have no sign). This value (either '+' , '-' , or null ) is assigned to the variable sign . The third yielded parser is join(many1(digit)) . This simply matches a series of one or more digit characters ( 0-9 ), returning them as a single string instead of an array of characters (because of join ). This parses a natural number, assigning the result to number . (When combined with sign , this could be a negative number as well, so the two together parse an integer.) The fourth yielded parser skips whitespace at the end, similar to the first parser. After the parsing is done, sign and number are used in a calculation that turns them into an integer of the JavaScript number type. This number is returned at the end, so the block parser in total results in this number. Note that it isn't a string, like most parsers return; block can return anything that its function can return. The first case ( s ) shows success. Whitespace was skipped before and after the number, an optional sign was parsed (which was not present), and then the string '1729' was parsed. The calculation turned this into the number 1729 , which was returned. The second case ( f ) fails because the first character is not a digit. It does not have to be whitespace ( spaces can match zero spaces) and it does not have to be a sign (that parser is optional), but the digit part of the third parser has to be matched. No input was consumed before this failure, so it is not a fatal failure. The third case ( t ) fails because, while the whitespace was ignored and the optional sign was parsed, the third parser fails against the non-digit 'a' . Since input was consumed (the negative sign) before this failure, it is fatal. Parameters g : A generator function that provides the body of the block parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the block parser. m : The optional expected error message that will take the place of the default error message. Success Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function. Failure Fails if any yielded parser fails before any input is consumed. Fatal Failure Fails fatally if any yielded parser fails fatally. Fails fatally if any yielded parser fails non-fatally after some input was consumed. Throws Throws an error if g is not a generator function. Throws an error if m exists and is not a string. Throws an error if any yield statement is executed and the value that is yielded is not a parser. See Also Parser blockB seq","title":"block"},{"location":"parsers/block/#example","text":"const parser = block ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' 1729 ' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // 1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit The first yielded parser here is spaces . This skips zero or more whitespace characters. Its result is discarded as it is not assigned to anything (besides, spaces only returns null so its result isn't useful). The second yielded parser is opt(orElse(char('+'), char('-'))) . This will match either a '+' or '-' if it's there, or return null if the next character is neither of those (without opt it would fail, and we don't want that because it's okay for a number to have no sign). This value (either '+' , '-' , or null ) is assigned to the variable sign . The third yielded parser is join(many1(digit)) . This simply matches a series of one or more digit characters ( 0-9 ), returning them as a single string instead of an array of characters (because of join ). This parses a natural number, assigning the result to number . (When combined with sign , this could be a negative number as well, so the two together parse an integer.) The fourth yielded parser skips whitespace at the end, similar to the first parser. After the parsing is done, sign and number are used in a calculation that turns them into an integer of the JavaScript number type. This number is returned at the end, so the block parser in total results in this number. Note that it isn't a string, like most parsers return; block can return anything that its function can return. The first case ( s ) shows success. Whitespace was skipped before and after the number, an optional sign was parsed (which was not present), and then the string '1729' was parsed. The calculation turned this into the number 1729 , which was returned. The second case ( f ) fails because the first character is not a digit. It does not have to be whitespace ( spaces can match zero spaces) and it does not have to be a sign (that parser is optional), but the digit part of the third parser has to be matched. No input was consumed before this failure, so it is not a fatal failure. The third case ( t ) fails because, while the whitespace was ignored and the optional sign was parsed, the third parser fails against the non-digit 'a' . Since input was consumed (the negative sign) before this failure, it is fatal.","title":"Example"},{"location":"parsers/block/#parameters","text":"g : A generator function that provides the body of the block parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the block parser. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/block/#success","text":"Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function.","title":"Success"},{"location":"parsers/block/#failure","text":"Fails if any yielded parser fails before any input is consumed.","title":"Failure"},{"location":"parsers/block/#fatal-failure","text":"Fails fatally if any yielded parser fails fatally. Fails fatally if any yielded parser fails non-fatally after some input was consumed.","title":"Fatal Failure"},{"location":"parsers/block/#throws","text":"Throws an error if g is not a generator function. Throws an error if m exists and is not a string. Throws an error if any yield statement is executed and the value that is yielded is not a parser.","title":"Throws"},{"location":"parsers/block/#see-also","text":"Parser blockB seq","title":"See Also"},{"location":"parsers/blockb/","text":"blockB(g: GeneratorFunction, m?: string): Parser Executes a generator function that can yield to parsers in its body. This is a backtracking version of the block parser. It operates in exactly the same manner, except that if one of its parsers fail non-fatally after other of its parsers have consumed some input, it will backtrack to the position it was at the beginning of the blockB parser and report a non-fatal failure ( block in this case would not backtrack and its failure would be fatal). The same caveats also apply; blockB can implement any other parser, but it's best to use a more specific one if it suits. Example const parser = blockB ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' -1729 ' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // -1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // -abcd // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit See block for a detailed breakdown of the example. That example works exactly the same as this one except with regard to the third case. With block , this case is a fatal error, but blockB backtracks and converts the error to a non-fatal one. Parameters g : A generator function that provides the body of the blockB parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the blockB parser. m : The optional expected error message that will take the place of the default error message. Success Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function. Failure Fails if any yielded parser fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any yielded parser fails fatally. Throws Throws an error if g is not a generator function. Throws an error if m exists and is not a string. Throws an error if any yield statement is executed and the value that is yielded is not a parser. See Also Parser block seqB","title":"blockB"},{"location":"parsers/blockb/#example","text":"const parser = blockB ( function * () { yield spaces const sign = yield optional ( orElse ( char ( '+' ), char ( '-' ))) const number = yield join ( many1 ( digit )) yield spaces const result = parseInt ( number ) * ( sign === '-' ? - 1 : 1 ) return result }) const s = parse ( parser , ' -1729 ' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // -1729 const f = parse ( parser , 'abcd' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abcd // ^ // Expected a digit const t = parse ( parser , '-abcd' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // -abcd // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // -abcd // ^ // Expected a digit See block for a detailed breakdown of the example. That example works exactly the same as this one except with regard to the third case. With block , this case is a fatal error, but blockB backtracks and converts the error to a non-fatal one.","title":"Example"},{"location":"parsers/blockb/#parameters","text":"g : A generator function that provides the body of the blockB parser. This generator function can yield parsers, which will have those parsers' results fed back into the function when it's restarted (so that they can be assigned to variables, used in calculations, etc.). The return value of this generator function becomes the result of the blockB parser. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/blockb/#success","text":"Succeeds if every parser that is applied in the generator function succeeds. (Not all parsers need be applied; those that are skipped by conditional statements, for instance, will never execute.) Returns the return value of the generator function.","title":"Success"},{"location":"parsers/blockb/#failure","text":"Fails if any yielded parser fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/blockb/#fatal-failure","text":"Fails fatally if any yielded parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/blockb/#throws","text":"Throws an error if g is not a generator function. Throws an error if m exists and is not a string. Throws an error if any yield statement is executed and the value that is yielded is not a parser.","title":"Throws"},{"location":"parsers/blockb/#see-also","text":"Parser block seqB","title":"See Also"},{"location":"parsers/chain/","text":"chain(p: Parser, fn: function, m?: string): Parser Applies a parser to the input, passes its result to a function, and then applies the parser that function returns to the input. chain is not used that often itself, but it is a primitive combinator that provides the basis for numerous other parsers. It corresponds to the bind operation in the Monad type class in Haskell, which is often spelled >>= . It can therefore be used to implement sequencing in a monadic style, contrasting with the applicative style offered by apply . This parser is not expected to see a lot of use since none of the Kessels parsers are implemented in terms of it, but it is available in case someone wants to parse monadically without using block . There is another version of this parser ( chainB ) that will backtrack and fail non-fatally if the parser returned by fn fails non-fatally. Example const parser = chain ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' In this example, chain first applies any , which returns the next character of the input. fn then returns char(c) , where c is the result of the any application, and this parser is applied. The upshot is that this example of chain succeeds if the next two characters are the same. In the case of f , chain fails fatally. This is because a character was consumed in p 's success, and if a character is consumed before failure, fatal failure is the result. Parameters p : The parser which is applied first and whose result is passed into fn . fn : A function which, when passed the result of p , should return a second parser to be applied to the input. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn . Failure Fails if p fails. Fails if the parser returned by fn fails after p succeeds but consumes no input. Fatal Failure Fails fatally if either p or the parser returned by fn fail fatally. Fails fatally if the parser returned by fn fails after p succeeds and consumes some input. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if m exists and is not a string. Throws an error if p succeeds and the value returned by fn is not a parser. See Also Parser apply chainB map","title":"chain"},{"location":"parsers/chain/#example","text":"const parser = chain ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' In this example, chain first applies any , which returns the next character of the input. fn then returns char(c) , where c is the result of the any application, and this parser is applied. The upshot is that this example of chain succeeds if the next two characters are the same. In the case of f , chain fails fatally. This is because a character was consumed in p 's success, and if a character is consumed before failure, fatal failure is the result.","title":"Example"},{"location":"parsers/chain/#parameters","text":"p : The parser which is applied first and whose result is passed into fn . fn : A function which, when passed the result of p , should return a second parser to be applied to the input. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/chain/#success","text":"Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn .","title":"Success"},{"location":"parsers/chain/#failure","text":"Fails if p fails. Fails if the parser returned by fn fails after p succeeds but consumes no input.","title":"Failure"},{"location":"parsers/chain/#fatal-failure","text":"Fails fatally if either p or the parser returned by fn fail fatally. Fails fatally if the parser returned by fn fails after p succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/chain/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if m exists and is not a string. Throws an error if p succeeds and the value returned by fn is not a parser.","title":"Throws"},{"location":"parsers/chain/#see-also","text":"Parser apply chainB map","title":"See Also"},{"location":"parsers/chainb/","text":"chainB(p: Parser, fn: function, m?: string): Parser Applies a parser to the input, passes its result to a function, and then applies the parser that function returns to the input. If p succeeds but the parser that is returned by fn fails, the state will backtrack to the location where p was originally applied and chainB will fail non-fatally. Example const parser = chainB ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a' Parameters p : The parser which is applied first and whose result is passed into fn . fn : A function which, when passed the result of p , should return a second parser to be applied to the input. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn . Failure Fails if either p or the parser returned by fn fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or the parser returned by fn fail fatally. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if m exists and is not a string. Throws an error if p succeeds and the value returned by fn is not a parser. See Also Parser chain","title":"chainB"},{"location":"parsers/chainb/#example","text":"const parser = chainB ( any , c => char ( c )) const s = parse ( parser , 'aabbcc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input const t = parse ( parser , 'abc' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // abc // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // abc // ^ // Expected 'a'","title":"Example"},{"location":"parsers/chainb/#parameters","text":"p : The parser which is applied first and whose result is passed into fn . fn : A function which, when passed the result of p , should return a second parser to be applied to the input. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/chainb/#success","text":"Succeeds if both p and the parser returned by fn succeed. Returns the result of the parser returned by fn .","title":"Success"},{"location":"parsers/chainb/#failure","text":"Fails if either p or the parser returned by fn fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/chainb/#fatal-failure","text":"Fails fatally if either p or the parser returned by fn fail fatally.","title":"Fatal Failure"},{"location":"parsers/chainb/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if m exists and is not a string. Throws an error if p succeeds and the value returned by fn is not a parser.","title":"Throws"},{"location":"parsers/chainb/#see-also","text":"Parser chain","title":"See Also"},{"location":"parsers/char/","text":"char(c: string): Parser<string> Parses the character c . There is no character type in JavaScript, as a \"character\" is just a string with a length of 1. However, using char is a bit more efficient than using string and should be used as long as only one character is needed. Example const parser = char ( 'a' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected 'a' Parameters c : The character that the next input character must be in order to succeed. Success Succeeds if the next input character is c . Consumes and returns that character. Failure Fails if the next input character is any other character, including the opposite case version of c . Throws Throws an error if c is not a string or if it isn't exactly one character in length. See Also Parser any charI range string","title":"char"},{"location":"parsers/char/#example","text":"const parser = char ( 'a' ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected 'a'","title":"Example"},{"location":"parsers/char/#parameters","text":"c : The character that the next input character must be in order to succeed.","title":"Parameters"},{"location":"parsers/char/#success","text":"Succeeds if the next input character is c . Consumes and returns that character.","title":"Success"},{"location":"parsers/char/#failure","text":"Fails if the next input character is any other character, including the opposite case version of c .","title":"Failure"},{"location":"parsers/char/#throws","text":"Throws an error if c is not a string or if it isn't exactly one character in length.","title":"Throws"},{"location":"parsers/char/#see-also","text":"Parser any charI range string","title":"See Also"},{"location":"parsers/chari/","text":"charI(c: string): Parser<string> Parses the character c or its opposite case equivalent. In other words, this is a case-insensitive version of char . Example const parser = charI ( 'a' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'BCD' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // BCD // ^ // Expected 'a' Parameters c : The character that the next input character must be (of any case) in order to succeed. Success Succeeds if the next input character is either c or its opposite case counterpart. Consumes and returns that character. Failure Fails if the next input character is any other character. Throws Throws an error if c is not a string or if it isn't exactly one character in length. See Also Parser any char stringI","title":"charI"},{"location":"parsers/chari/#example","text":"const parser = charI ( 'a' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'BCD' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // BCD // ^ // Expected 'a'","title":"Example"},{"location":"parsers/chari/#parameters","text":"c : The character that the next input character must be (of any case) in order to succeed.","title":"Parameters"},{"location":"parsers/chari/#success","text":"Succeeds if the next input character is either c or its opposite case counterpart. Consumes and returns that character.","title":"Success"},{"location":"parsers/chari/#failure","text":"Fails if the next input character is any other character.","title":"Failure"},{"location":"parsers/chari/#throws","text":"Throws an error if c is not a string or if it isn't exactly one character in length.","title":"Throws"},{"location":"parsers/chari/#see-also","text":"Parser any char stringI","title":"See Also"},{"location":"parsers/compact/","text":"compact(p: Parser, m?: string): Parser Applies a parser and returns the elements of the resulting array except for any null or undefined elements. This combinator is useful in conjunction with parsers like seq and many , which may return null values amongst their array elements, particularly if the opt parser is used in their contained parsers. In a prior version of Kessel, seq and many dropped their null values by default, but this was found to be less than ideal for a number of reasons. compact brings that behavior back when needed. Example const parser = compact ( seq ( opt ( char ( '-' )), digit , digit )) const s = parse ( parser , '-12' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"-\", \"1\", \"2\"] const r = parser ( parser , '12' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // [\"1\", \"2\"] const f = parse ( parser , 'ab' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // Expected '-' or a digit Parameters p : The parser that is applied, which must return an array. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the resulting array's elements except for null and undefined elements. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. Throws an error if m exists and is not a string. See Also Parser many map opt seq","title":"compact"},{"location":"parsers/compact/#example","text":"const parser = compact ( seq ( opt ( char ( '-' )), digit , digit )) const s = parse ( parser , '-12' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"-\", \"1\", \"2\"] const r = parser ( parser , '12' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // [\"1\", \"2\"] const f = parse ( parser , 'ab' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ab // ^ // Expected '-' or a digit","title":"Example"},{"location":"parsers/compact/#parameters","text":"p : The parser that is applied, which must return an array. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/compact/#success","text":"Succeeds if p succeeds. Returns the resulting array's elements except for null and undefined elements.","title":"Success"},{"location":"parsers/compact/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/compact/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/compact/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/compact/#see-also","text":"Parser many map opt seq","title":"See Also"},{"location":"parsers/def/","text":"def(p: Parser, x: *, m?: string): Parser Applies a parser and returns its result on success or an arbitrary value on failure. The only way def can fail is if its parser fails fatally. For this reason, a common use case is to wrap the parser in attempt to ensure that the default value is always returned on any kind of failure. Take care when doing this, as backtracking can erase important error information. x can be a value of any type, so this becomes one of the small number of combinators that can return results that are not strings or arrays of strings. Example const parser = def ( join ( sequence ( letter , digit )), 'Z0' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a1\" const r = parse ( parser , '12' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // \"Z0\" const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p : The parser that gets applied. If it succeeds, its result is returned. x : An arbitrary value that is returned if p fails. m : The optional expected message that will be added if def fails fatally. Success Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, x is returned. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser attempt opt","title":"def"},{"location":"parsers/def/#example","text":"const parser = def ( join ( sequence ( letter , digit )), 'Z0' ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a1\" const r = parse ( parser , '12' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // \"Z0\" const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/def/#parameters","text":"p : The parser that gets applied. If it succeeds, its result is returned. x : An arbitrary value that is returned if p fails. m : The optional expected message that will be added if def fails fatally.","title":"Parameters"},{"location":"parsers/def/#success","text":"Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, x is returned.","title":"Success"},{"location":"parsers/def/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/def/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/def/#see-also","text":"Parser attempt opt","title":"See Also"},{"location":"parsers/digit/","text":"digit: Parser<string> Parses a decimal digit ( 0-9 ). Note that this parses ASCII digits, not UTF-8 digits in general. For that, use regex(/^\\p{Nd}/u) . Example const parser = digit const s = parse ( parser , '123' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a digit Success Succeeds if the next character is a decimal digit ( 0-9 ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser hex octal","title":"digit"},{"location":"parsers/digit/#example","text":"const parser = digit const s = parse ( parser , '123' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a digit","title":"Example"},{"location":"parsers/digit/#success","text":"Succeeds if the next character is a decimal digit ( 0-9 ). Consumes and returns that character.","title":"Success"},{"location":"parsers/digit/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/digit/#see-also","text":"Parser hex octal","title":"See Also"},{"location":"parsers/empty/","text":"empty(p: Parser, m?: string): Parser Applies a parser and succeeds if that parser succeeds but does not return a result. If the parser does return a result, empty will fail. This parser cannot produce a useful error message automatically. To provide a custom message, pass an expected error message in as the second argument. Example const parser = empty ( optional ( char ( '+' ))) const s = parse ( parser , '123' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Unknown error(s) Parameters p : The parser to be applied. empty fails if this p succeeds but produces a result. m : The optional expected message that will be added if empty fails. Success Succeeds if p succeeds but doesn't return a result. Failure Fails if p fails. Fails if p succeeds but returns a result. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser not","title":"empty"},{"location":"parsers/empty/#example","text":"const parser = empty ( optional ( char ( '+' ))) const s = parse ( parser , '123' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , '+123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // +123 // ^ // Unknown error(s)","title":"Example"},{"location":"parsers/empty/#parameters","text":"p : The parser to be applied. empty fails if this p succeeds but produces a result. m : The optional expected message that will be added if empty fails.","title":"Parameters"},{"location":"parsers/empty/#success","text":"Succeeds if p succeeds but doesn't return a result.","title":"Success"},{"location":"parsers/empty/#failure","text":"Fails if p fails. Fails if p succeeds but returns a result.","title":"Failure"},{"location":"parsers/empty/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/empty/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/empty/#see-also","text":"Parser not","title":"See Also"},{"location":"parsers/end/","text":"end(p: Parser, s: Parser, m?: string): Parser Parses zero or more occurrences of a content parser, separated and optionally ended by a separator parser. end applies the content parser p zero or more times as long as both it and the preceding separator parser s match. The operation of the parser in EBNF is (p (s p)* s?)? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser need not be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the separator parser. Example const parser = end ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string. See Also Parser end1 sep","title":"end"},{"location":"parsers/end/#example","text":"const parser = end ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/end/#parameters","text":"p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/end/#success","text":"Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result.","title":"Success"},{"location":"parsers/end/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/end/#throws","text":"Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/end/#see-also","text":"Parser end1 sep","title":"See Also"},{"location":"parsers/end1/","text":"end1(p: Parser, s: Parser, m?: string): Parser Parses one or more occurrences of a content parser, separated and optionally ended by a separator parser. end1 applies the content parser p one or more times as long as both it and the preceding separator parser sep match. The operation of the parser in EBNF is p (s p)* s? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser need not be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the separator parser. Example const parser = end1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111,' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string. See Also Parser end sep1","title":"end1"},{"location":"parsers/end1/#example","text":"const parser = end1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc,' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111,' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1,' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/end1/#parameters","text":"p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/end1/#success","text":"Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned.","title":"Success"},{"location":"parsers/end1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/end1/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/end1/#throws","text":"Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/end1/#see-also","text":"Parser end sep1","title":"See Also"},{"location":"parsers/eof/","text":"eof: Parser<null> Attempts to parse a character and succeeds if there is no character to parse. The only time that there is no character to read is at the end of input, so this parser checks specifically for that condition. Example const parser = eof const s = parse ( parser , '' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected end of input Success Succeeds if the current parse location is at the end of input. Returns nothing and consumes no input. Failure Fails if there is any character left to read. See Also Parser all","title":"eof"},{"location":"parsers/eof/#example","text":"const parser = eof const s = parse ( parser , '' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected end of input","title":"Example"},{"location":"parsers/eof/#success","text":"Succeeds if the current parse location is at the end of input. Returns nothing and consumes no input.","title":"Success"},{"location":"parsers/eof/#failure","text":"Fails if there is any character left to read.","title":"Failure"},{"location":"parsers/eof/#see-also","text":"Parser all","title":"See Also"},{"location":"parsers/failfatally/","text":"failFatally(msg: string): Parser<null> Fails fatally automatically with a custom generic error message. Note that this explicit failure parser is the only way to fail fatally without consuming input. Every other case of fatal failure in Kessel is associated with failure after consuming input. Example const parser = failFatally ( 'a letter please?' ) const t = parse ( parser , '123' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter please? Parameters msg : The generic error message to apply. Fatal Failure Always fails fatally. The failure message will be generic(msg) . No input is consumed. Throws Throws an error if msg is not a string. See Also Parser failNormally generic","title":"failFatally"},{"location":"parsers/failfatally/#example","text":"const parser = failFatally ( 'a letter please?' ) const t = parse ( parser , '123' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter please?","title":"Example"},{"location":"parsers/failfatally/#parameters","text":"msg : The generic error message to apply.","title":"Parameters"},{"location":"parsers/failfatally/#fatal-failure","text":"Always fails fatally. The failure message will be generic(msg) . No input is consumed.","title":"Fatal Failure"},{"location":"parsers/failfatally/#throws","text":"Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/failfatally/#see-also","text":"Parser failNormally generic","title":"See Also"},{"location":"parsers/failnormally/","text":"failNormally(msg: string): Parser<null> Fails automatically with a custom generic error message. Example const parser = failNormally ( 'a letter, please?' ) const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter, please? Parameters msg : The generic error message to apply. Failure Always fails. The failure message will be generic(msg) . Throws Throws an error if msg is not a string. See Also Parser failFatally generic","title":"failNormally"},{"location":"parsers/failnormally/#example","text":"const parser = failNormally ( 'a letter, please?' ) const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // a letter, please?","title":"Example"},{"location":"parsers/failnormally/#parameters","text":"msg : The generic error message to apply.","title":"Parameters"},{"location":"parsers/failnormally/#failure","text":"Always fails. The failure message will be generic(msg) .","title":"Failure"},{"location":"parsers/failnormally/#throws","text":"Throws an error if msg is not a string.","title":"Throws"},{"location":"parsers/failnormally/#see-also","text":"Parser failFatally generic","title":"See Also"},{"location":"parsers/fifth/","text":"fifth(p: Parser, m?: string): Parser Applies a parser and returns the fifth element of the resulting array. This parser works only if p returns an array, and it returns the fifth element of that array. It's most useful with parsers like seq and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. fifth(p) is an optimized implementation of chain(p, x => always(x[4])) . Example const parser = fifth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"5\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the fifth element of the array that p returns. If there are not at least five elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array. See Also Parser first fourth nth second third","title":"fifth"},{"location":"parsers/fifth/#example","text":"const parser = fifth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"5\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/fifth/#parameters","text":"p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/fifth/#success","text":"Succeeds if p succeeds. Returns the fifth element of the array that p returns. If there are not at least five elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/fifth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/fifth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/fifth/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/fifth/#see-also","text":"Parser first fourth nth second third","title":"See Also"},{"location":"parsers/first/","text":"first(p: Parser, m?: string): Parser Applies a parser and returns the first element of the resulting array. This parser works only if p returns an array, and it returns the first element of that array. It's most useful with parsers like seq and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. first(p) is an optimized implementation of chain(p, x => always(x[0])) . Example const parser = first ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the first element of the array that p returns. If there is not at least one element in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array. See Also Parser fifth fourth nth second third","title":"first"},{"location":"parsers/first/#example","text":"const parser = first ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/first/#parameters","text":"p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/first/#success","text":"Succeeds if p succeeds. Returns the first element of the array that p returns. If there is not at least one element in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/first/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/first/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/first/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/first/#see-also","text":"Parser fifth fourth nth second third","title":"See Also"},{"location":"parsers/fourth/","text":"fourth(p: Parser, m?: string): Parser Applies a parser and returns the fourth element of the resulting array. This parser works only if p returns an array, and it returns the fourth element of that array. It's most useful with parsers like seq and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. fourth(p) is an optimized implementation of chain(p, x => always(x[3])) . Example const parser = fourth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the fourth element of the array that p returns. If there are not at least four elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array. See Also Parser fifth first nth second third","title":"fourth"},{"location":"parsers/fourth/#example","text":"const parser = fourth ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/fourth/#parameters","text":"p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/fourth/#success","text":"Succeeds if p succeeds. Returns the fourth element of the array that p returns. If there are not at least four elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/fourth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/fourth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/fourth/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/fourth/#see-also","text":"Parser fifth first nth second third","title":"See Also"},{"location":"parsers/hex/","text":"hex: Parser<string> Parses a hexadecimal digit ( 0-9 , a-f , or A-F ). Example const parser = hex const s = parse ( parser , 'cafe' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"c\" const f = parse ( parser , 'xyz' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // xyz // ^ // Expected a hexadecimal digit Success Succeeds if the next character is a hexadecimal digit ( 0-9 , a-f , or A-F ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser digit octal","title":"hex"},{"location":"parsers/hex/#example","text":"const parser = hex const s = parse ( parser , 'cafe' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"c\" const f = parse ( parser , 'xyz' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // xyz // ^ // Expected a hexadecimal digit","title":"Example"},{"location":"parsers/hex/#success","text":"Succeeds if the next character is a hexadecimal digit ( 0-9 , a-f , or A-F ). Consumes and returns that character.","title":"Success"},{"location":"parsers/hex/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/hex/#see-also","text":"Parser digit octal","title":"See Also"},{"location":"parsers/join/","text":"join(p: Parser, m?: string): Parser Applies a parser and returns the elements of the resulting array into a string. This combinator solves the problem in JavaScript that there is no separate character type, and therefore a string is not just a list/array of characters. (Parsec parsers, for example, can return arrays of characters which Haskell regards also as strings in their own right.) Parsers like seq and many return arrays, and often they are arrays of single-character strings. join will turn these results into simple strings. join(p) is an optimized implementation of chain(p, x => x.join('')) . Example const parser = join ( many1 ( any )) const s = parse ( parser , 'abcde' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"abcde\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character Parameters p : The parser that is applied, which must return an array. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the resulting array's elements joined into a string. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. Throws an error if m exists and is not a string. See Also Parser map","title":"join"},{"location":"parsers/join/#example","text":"const parser = join ( many1 ( any )) const s = parse ( parser , 'abcde' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"abcde\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character","title":"Example"},{"location":"parsers/join/#parameters","text":"p : The parser that is applied, which must return an array. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/join/#success","text":"Succeeds if p succeeds. Returns the resulting array's elements joined into a string.","title":"Success"},{"location":"parsers/join/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/join/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/join/#throws","text":"Throws an error if p is not a parser. Throws an error if p succeeds but does not return an array. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/join/#see-also","text":"Parser map","title":"See Also"},{"location":"parsers/left/","text":"left(p: Parser, q: Parser, m?: string): Parser Applies two parsers in order, returning the result of the first one. The result of the second parser is discarded. If either parser fails, then the entire left parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p or q failed fatally). There is another version of this parser ( leftB ) that will backtrack and fail non-fatally if p1 succeeds and p2 fails non-fatally. left(p, q) is the equivalent of p <* q in the Haskell Applicative class and is written .>> in FParsec. It can be regarded as an optimized implementation of either of the following. chain(p, x => value(q, x)) // monadic style apply(p, value(q, x => x)) // applicative style Example const parser = left ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fatal failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. Parameters p : The first parser to apply. If both parsers succeed, this parser's result will be left 's result. q : The second parser to apply. This parser's result will be discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and q succeed. Returns the result of p . Failure Fails if p fails. Fails if q fails after p succeeds but does not consume input. Fatal Failure Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeds and consumes some input. Throws Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. See Also Parser leftB right seq","title":"left"},{"location":"parsers/left/#example","text":"const parser = left ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fatal failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally.","title":"Example"},{"location":"parsers/left/#parameters","text":"p : The first parser to apply. If both parsers succeed, this parser's result will be left 's result. q : The second parser to apply. This parser's result will be discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/left/#success","text":"Succeeds if both p and q succeed. Returns the result of p .","title":"Success"},{"location":"parsers/left/#failure","text":"Fails if p fails. Fails if q fails after p succeeds but does not consume input.","title":"Failure"},{"location":"parsers/left/#fatal-failure","text":"Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/left/#throws","text":"Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/left/#see-also","text":"Parser leftB right seq","title":"See Also"},{"location":"parsers/leftb/","text":"leftB(p: Parser, q: Parser, m?: string): Parser Applies two parsers in order, returning the result of the first one. The result of the second parser is discarded. If either parser fails, then the entire leftB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p was applied. Example const parser = leftB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p : The first parser to apply. If both parsers succeed, this parser's result will be leftB 's result. q : The second parser to apply. This parser's result will be discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and q succeed. Returns the result of p . Failure Fails if either p or q fail. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or q fail fatally. Throws Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. See Also Parser left rightB seqB","title":"leftB"},{"location":"parsers/leftb/#example","text":"const parser = leftB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/leftb/#parameters","text":"p : The first parser to apply. If both parsers succeed, this parser's result will be leftB 's result. q : The second parser to apply. This parser's result will be discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/leftb/#success","text":"Succeeds if both p and q succeed. Returns the result of p .","title":"Success"},{"location":"parsers/leftb/#failure","text":"Fails if either p or q fail. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/leftb/#fatal-failure","text":"Fails fatally if either p or q fail fatally.","title":"Fatal Failure"},{"location":"parsers/leftb/#throws","text":"Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/leftb/#see-also","text":"Parser left rightB seqB","title":"See Also"},{"location":"parsers/letter/","text":"letter: Parser<string> Parses an ASCII letter ( a-z or A-Z ). This does not parse UTF-8 letters in general. Use letterU for that. Example const parser = letter const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Success Succeeds if the next character is an ASCII letter ( a-z or A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alpha letterU lower upper","title":"letter"},{"location":"parsers/letter/#example","text":"const parser = letter const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter","title":"Example"},{"location":"parsers/letter/#success","text":"Succeeds if the next character is an ASCII letter ( a-z or A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/letter/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/letter/#see-also","text":"Parser alpha letterU lower upper","title":"See Also"},{"location":"parsers/letteru/","text":"letterU: Parser<string> Parses a Unicode letter. A character is a Unicode letter if it has the Unicode Alphabetic binary property. Example const parser = letterU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a Unicode letter Success Succeeds if the next character is a Unicode letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alphaU letter lowerU upperU","title":"letterU"},{"location":"parsers/letteru/#example","text":"const parser = letterU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a Unicode letter","title":"Example"},{"location":"parsers/letteru/#success","text":"Succeeds if the next character is a Unicode letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/letteru/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/letteru/#see-also","text":"Parser alphaU letter lowerU upperU","title":"See Also"},{"location":"parsers/lower/","text":"lower: Parser<string> Parses an ASCII lowercase letter ( a-z ). This does not parse UTF-8 lowercase letters in general. Use lowerU for that. Example const parser = lower const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter Success Succeeds if the next character is an ASCII lowercase letter ( a-z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alpha letter lowerU upper","title":"lower"},{"location":"parsers/lower/#example","text":"const parser = lower const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"a\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter","title":"Example"},{"location":"parsers/lower/#success","text":"Succeeds if the next character is an ASCII lowercase letter ( a-z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/lower/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/lower/#see-also","text":"Parser alpha letter lowerU upper","title":"See Also"},{"location":"parsers/loweru/","text":"lowerU: Parser<string> Parses a Unicode lowercase letter. A character is a Unicode lowercase letter if it has the Unicode Lowercase . This is approximately equal to characters that match the regular expression /\\p{Ll}/u but includes a few other characters as well. Example const parser = lowerU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0410\u0411\u0412 // ^ // Expected a Unicode lowercase letter Success Succeeds if the next character is a Unicode lowercase letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alphaU letterU lower upperU","title":"lowerU"},{"location":"parsers/loweru/#example","text":"const parser = lowerU const s = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\u0430\" const f = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0410\u0411\u0412 // ^ // Expected a Unicode lowercase letter","title":"Example"},{"location":"parsers/loweru/#success","text":"Succeeds if the next character is a Unicode lowercase letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/loweru/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/loweru/#see-also","text":"Parser alphaU letterU lower upperU","title":"See Also"},{"location":"parsers/many/","text":"many(p: Parser, m?: string): Parser Applies a parser as many times as possible until it fails, collecting the results into a resulting array. many executes a parser zero or more times, as long as it continues to succeed. The operation of the parser in EBNF is p* . When the parser fails, that does not mean that many fails; that signals that many is through executing and the successful results up to that point are returned. Example const parser = many ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\"] const t = parse ( parser , '112b' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter The failure case in this example shows the only way that many can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes many to fail. many does not fail from non-fatal failures of its parser. Parameters p : The parser to apply repeatedly until it fails. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p does not fail fatally. Returns the results that p had before failing in an array. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser many1","title":"many"},{"location":"parsers/many/#example","text":"const parser = many ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\"] const t = parse ( parser , '112b' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter The failure case in this example shows the only way that many can fail: its underlying right parser fails fatally because it consumed input before failing, and that fatal failure causes many to fail. many does not fail from non-fatal failures of its parser.","title":"Example"},{"location":"parsers/many/#parameters","text":"p : The parser to apply repeatedly until it fails. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/many/#success","text":"Succeeds if p does not fail fatally. Returns the results that p had before failing in an array.","title":"Success"},{"location":"parsers/many/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/many/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/many/#see-also","text":"Parser many1","title":"See Also"},{"location":"parsers/many1/","text":"many1(p: Parser, m?: string): Parser Applies a parser as many times as possible until it fails, collecting the results into a resulting array. many1 executes a parser one or more times, as long as it continues to succeed. The operation of the parser in EBNF is p+ . When the parser fails, that does not mean that many1 fails (as long as the parser succeeded at least once); that signals that many1 is through executing and the successful results up to that point are returned. As long as p succeeds at least once, the only way many1 can fail is if p fails fatally. Example const parser = many1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\"] const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter Parameters p : The parser to apply repeatedly until it fails. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds at least once and does not fail fatally. Returns the results that p had before failing in an array. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser many","title":"many1"},{"location":"parsers/many1/#example","text":"const parser = many1 ( right ( digit , letter )) const s = parse ( parser , '1a2b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\"] const f = parse ( parser , 'aabb' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 2): // // aabb // ^ // Expected a digit const t = parse ( parser , '112b' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // 112b // ^ // Expected a letter","title":"Example"},{"location":"parsers/many1/#parameters","text":"p : The parser to apply repeatedly until it fails. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/many1/#success","text":"Succeeds if p succeeds at least once and does not fail fatally. Returns the results that p had before failing in an array.","title":"Success"},{"location":"parsers/many1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/many1/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/many1/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/many1/#see-also","text":"Parser many","title":"See Also"},{"location":"parsers/map/","text":"map(p: Parser, fn: function, m?: string): Parser Applies a parser and returns the value that a function returns when passed the parser's result. fn can return anything, so map is one of the few combinators that can return something other than a string. map corresponds to fmap in Haskell (often simply map in other languages), which is a member of the Functor type class. It is often written <$> in languages that support custom operators. Example const parser = map ( lower , c => c . toUpperCase ()) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter In this example, a lower parser is used to read a lowercase letter. That character is passed into a function that uppercases it, then that uppercase letter is returned. Parameters p : A parser to apply to the input. fn : A function of one argument which gets passed the result of p . Its return value becomes map 's result. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the value that fn returns when passed the result of p . Failure Fails if p fails. In this case fn is never invoked. Fatal Failure Fails fatally if p fails fatally. In this case fn is never invoked. Throws Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if m exists and is not a string. See Also Parser chain join pipe","title":"map"},{"location":"parsers/map/#example","text":"const parser = map ( lower , c => c . toUpperCase ()) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'ABC' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // ABC // ^ // Expected a lowercase letter In this example, a lower parser is used to read a lowercase letter. That character is passed into a function that uppercases it, then that uppercase letter is returned.","title":"Example"},{"location":"parsers/map/#parameters","text":"p : A parser to apply to the input. fn : A function of one argument which gets passed the result of p . Its return value becomes map 's result. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/map/#success","text":"Succeeds if p succeeds. Returns the value that fn returns when passed the result of p .","title":"Success"},{"location":"parsers/map/#failure","text":"Fails if p fails. In this case fn is never invoked.","title":"Failure"},{"location":"parsers/map/#fatal-failure","text":"Fails fatally if p fails fatally. In this case fn is never invoked.","title":"Fatal Failure"},{"location":"parsers/map/#throws","text":"Throws an error if p is not a parser. Throws an error if fn is not a non-parser function. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/map/#see-also","text":"Parser chain join pipe","title":"See Also"},{"location":"parsers/newline/","text":"newline: Parser<string> Parses an ASCII newline. ASCII newlines include \\r , \\n , and \\r\\n . Example const parser = newline const s = parse ( parser , '\\r\\nNext line' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\\r\\n\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a newline Success Succeeds if the next character is either \\r or \\n , or if the next two characters are \\r\\n . This character (or these characters) are consumed and returned as a single string. Failure Fails if the next character is any other character. See Also Parser newlineU space spaces spaces1","title":"newline"},{"location":"parsers/newline/#example","text":"const parser = newline const s = parse ( parser , '\\r\\nNext line' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\\r\\n\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a newline","title":"Example"},{"location":"parsers/newline/#success","text":"Succeeds if the next character is either \\r or \\n , or if the next two characters are \\r\\n . This character (or these characters) are consumed and returned as a single string.","title":"Success"},{"location":"parsers/newline/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/newline/#see-also","text":"Parser newlineU space spaces spaces1","title":"See Also"},{"location":"parsers/newlineu/","text":"newlineU: Parser<string> Parses a Unicode newline. Unicode newlines include the ASCII newlines \\r , \\n , and \\r\\n , as well as the characters \"next line\" ( \\u0085 ), \"line separator\" ( \\u2028 ), and \"paragraph separator\" ( \\u2029 ). Example const parser = newlineU const s = parse ( parser , '\\u2028Next line' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\\u2028\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode newline Success Succeeds if the next character (or two characters, for \\r\\n ) is a Unicode newline. This character (or these characters) are consumed and returned as a single string. Failure Fails if the next character is any other character. See Also Parser newline spacesU spaces1U spaceU","title":"newlineU"},{"location":"parsers/newlineu/#example","text":"const parser = newlineU const s = parse ( parser , '\\u2028Next line' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"\\u2028\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode newline","title":"Example"},{"location":"parsers/newlineu/#success","text":"Succeeds if the next character (or two characters, for \\r\\n ) is a Unicode newline. This character (or these characters) are consumed and returned as a single string.","title":"Success"},{"location":"parsers/newlineu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/newlineu/#see-also","text":"Parser newline spacesU spaces1U spaceU","title":"See Also"},{"location":"parsers/noneof/","text":"noneOf(cs: string | string[]): Parser<string> Parses a character if that character is not included in cs . Example const parser = noneOf ( 'Test' ) const s = parse ( parser , 'Exit' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"E\" const f = parse ( parser , 'Test' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Test // ^ // Expected none of 'T', 'e', 's', or 't' Parameters cs : The set of characters that the next character is excluded from being a part of. This can be either a string or an array of single-character strings. Success Succeeds if the next character is not one of the characters in cs . Consumes and returns that character. Failure Fails if the next character is any character in cs . Throws Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length. See Also Parser anyOf","title":"noneOf"},{"location":"parsers/noneof/#example","text":"const parser = noneOf ( 'Test' ) const s = parse ( parser , 'Exit' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"E\" const f = parse ( parser , 'Test' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // Test // ^ // Expected none of 'T', 'e', 's', or 't'","title":"Example"},{"location":"parsers/noneof/#parameters","text":"cs : The set of characters that the next character is excluded from being a part of. This can be either a string or an array of single-character strings.","title":"Parameters"},{"location":"parsers/noneof/#success","text":"Succeeds if the next character is not one of the characters in cs . Consumes and returns that character.","title":"Success"},{"location":"parsers/noneof/#failure","text":"Fails if the next character is any character in cs .","title":"Failure"},{"location":"parsers/noneof/#throws","text":"Throws an error if cs is not either a string or an array. Throws an error if cs is an array but at least one of the elements is either not a string or is not exactly one character in length.","title":"Throws"},{"location":"parsers/noneof/#see-also","text":"Parser anyOf","title":"See Also"},{"location":"parsers/not/","text":"not(p: Parser, m?: string): Parser Applies a parser and succeeds without consuming input if that parser fails. not cannot feasibly produce an automatic error message on failure. To add an error message, pass an expected error message in as the second argument. Example const parser = not ( digit ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Unknown message(s) Parameters p : The parser to apply. If it fails, not succeeds. m : The optional expected message that will be added if not fails. Success Succeeds if p fails or fails fatally. Does not consume input or return a result. Failure Fails if p succeeds. No input is consumed and the state is not changed. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser empty","title":"not"},{"location":"parsers/not/#example","text":"const parser = not ( digit ) const s = parse ( parser , 'a' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , '1' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1 // ^ // Unknown message(s)","title":"Example"},{"location":"parsers/not/#parameters","text":"p : The parser to apply. If it fails, not succeeds. m : The optional expected message that will be added if not fails.","title":"Parameters"},{"location":"parsers/not/#success","text":"Succeeds if p fails or fails fatally. Does not consume input or return a result.","title":"Success"},{"location":"parsers/not/#failure","text":"Fails if p succeeds. No input is consumed and the state is not changed.","title":"Failure"},{"location":"parsers/not/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/not/#see-also","text":"Parser empty","title":"See Also"},{"location":"parsers/nth/","text":"nth(p: Parser, n: number. m?: string): Parser Applies a parser and returns a given element of the resulting array. This parser works only if p returns an array, and it returns the n th (parsers/0-based) element of that array. It's most useful with parsers like seq and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. nth(p, n) is an optimized implementation of chain(p, x => always(x[n])) . Example const parser = nth ( many1 ( any ), 3 ) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p : The parser to apply. This parser should return an array. n : The 0-based index of the element from p 's result that should be returned. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the element of the array that p returns with the index n . If there are not n + 1 elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array. See Also Parser fifth first fourth second third","title":"nth"},{"location":"parsers/nth/#example","text":"const parser = nth ( many1 ( any ), 3 ) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"4\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/nth/#parameters","text":"p : The parser to apply. This parser should return an array. n : The 0-based index of the element from p 's result that should be returned. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/nth/#success","text":"Succeeds if p succeeds. Returns the element of the array that p returns with the index n . If there are not n + 1 elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/nth/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/nth/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/nth/#throws","text":"Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/nth/#see-also","text":"Parser fifth first fourth second third","title":"See Also"},{"location":"parsers/octal/","text":"octal: Parser<string> Parses an octal digit ( 0-7 ). Example const parser = octal const s = parse ( parser , '123' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '890' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 890 // ^ // Expected an octal digit Success Succeeds if the next character is an octal digit ( 0-7 ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser digit hex","title":"octal"},{"location":"parsers/octal/#example","text":"const parser = octal const s = parse ( parser , '123' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '890' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 890 // ^ // Expected an octal digit","title":"Example"},{"location":"parsers/octal/#success","text":"Succeeds if the next character is an octal digit ( 0-7 ). Consumes and returns that character.","title":"Success"},{"location":"parsers/octal/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/octal/#see-also","text":"Parser digit hex","title":"See Also"},{"location":"parsers/opt/","text":"opt(p: Parser, m?: string): Parser Optionally matches a parser. If this parser succeeds, its result is returned. If it fails, null is returned. opt will only fail (fatally) if its parser fails fatally. A common use case is to skip some optional input; in this case, opt can be wrapped in skip , it can be placed in a position in another combinator where its output is ignored (such as left 's second parser.md), or its output can simply not be used. Example const parser = opt ( sequence ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"1\"] const r = parse ( parser , '1' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // null const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p : The parser that gets applied. m : The optional expected error message that will take the place of the default error message. Success Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, opt still succeeds, but it returns nothing ( null ) and still generates an error message (for use in sequential combinators when the next parser also fails). Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser def peek skip","title":"opt"},{"location":"parsers/opt/#example","text":"const parser = opt ( sequence ( letter , digit )) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"1\"] const r = parse ( parser , '1' ) console . log ( status ( r )) // \"ok\" console . log ( success ( r )) // null const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/opt/#parameters","text":"p : The parser that gets applied. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/opt/#success","text":"Succeeds unless p fails fatally. If p succeeds, its result is returned. If p fails, opt still succeeds, but it returns nothing ( null ) and still generates an error message (for use in sequential combinators when the next parser also fails).","title":"Success"},{"location":"parsers/opt/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/opt/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/opt/#see-also","text":"Parser def peek skip","title":"See Also"},{"location":"parsers/peek/","text":"peek(p: Parser, m?: string): Parser Applies a parser and returns its result on success, but does not consume input. This parser allows for peeking ahead to see what characters are coming up without actually consuming those characters. It's common to see it in block parsers to drive logic that determines which parser gets applied based on the next character. Since peek does not consume input no matter what it encounters, it cannot fail fatally. If its parser fails fatally, there is essentially automatic backtracking done, and the failure is converted into a non-fatal one. Example const parser = peek ( sequence ( letter , letter )) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\"] console . log ( s [ 0 ]. index ) // 0 const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'a1' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a1 // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // a1 // ^ // Expected a letter Parameters p : The parser to apply without consuming input. If p succeeds, its result will be returned. m : The optional expected message that will be added if peek fails. Success Succeeds as long as p does not fail fatally. If p succeeds, its result is returned. If p fails, nothing is returned. In either case, no input is consumed. Failure Fails if p fails, either regularly or fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser block opt","title":"peek"},{"location":"parsers/peek/#example","text":"const parser = peek ( sequence ( letter , letter )) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\"] console . log ( s [ 0 ]. index ) // 0 const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'a1' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // a1 // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // a1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/peek/#parameters","text":"p : The parser to apply without consuming input. If p succeeds, its result will be returned. m : The optional expected message that will be added if peek fails.","title":"Parameters"},{"location":"parsers/peek/#success","text":"Succeeds as long as p does not fail fatally. If p succeeds, its result is returned. If p fails, nothing is returned. In either case, no input is consumed.","title":"Success"},{"location":"parsers/peek/#failure","text":"Fails if p fails, either regularly or fatally.","title":"Failure"},{"location":"parsers/peek/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/peek/#see-also","text":"Parser block opt","title":"See Also"},{"location":"parsers/pipe/","text":"pipe(...ps: Parser[], fn: function, m?: string): Parser Applies some parsers in order, then returns the result of a function to which all of the parser results have been passed. fn will be passed one argument for every member of ps . JavaScript does not enforce that there has to be a parameter for each passed argument, but likely you will want to provide an fn that has an arity equal to the number of parsers in ps . There is another version of this parser ( pipeB ) that fails non-fatally and backtracks if the parser that fails does so non-fatally. fn can return anything, so this is one of the few combinators that can return something other than a string. pipe is functionally the same as applicative lift functions in Haskell. A two-parser pipe is the same as liftA2 , a three-parser pipe is the same as liftA3 , etc. A single-parser pipe is therefore the same as map . pipe(p, q, fn) can be regarded as an optimized implementation of either of the following. chain(p, a => chain(q, b => always(fn(a, b)))) // monadic style apply(p, apply(q, always(b => a => fn(a, b)))) // applicative style Example const parser = pipe ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter In this example, the upper and lower parsers are applied, and the results of each are passed to an arity-2 function which lowercases the first argument and uppercases the second. The first failure example ( f ) shows non-fatal failure caused by the first parser failing non-fatally, but the second ( t ) shows a fatal failure caused by a parser ( upper in this case) consuming a character before a later parser fails. Parameters ...ps : Zero or more parsers, each of which is applied to the input in order. fn : A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe . m : The optional expected error message that will take the place of the default error message. Success Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it. Failure Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the ones before it succeed but do not consume input. Fatal Failure Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after a prior parser succeeds and consumes some input. Throws Throws an error if the last argument is not a non-parser function or a string. Throws an error if the second-to-last argument is not a non-parser function if the last argument is a string. Throws an error if any other argument is not a parser. See Also Parser map pipeB","title":"pipe"},{"location":"parsers/pipe/#example","text":"const parser = pipe ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter In this example, the upper and lower parsers are applied, and the results of each are passed to an arity-2 function which lowercases the first argument and uppercases the second. The first failure example ( f ) shows non-fatal failure caused by the first parser failing non-fatally, but the second ( t ) shows a fatal failure caused by a parser ( upper in this case) consuming a character before a later parser fails.","title":"Example"},{"location":"parsers/pipe/#parameters","text":"...ps : Zero or more parsers, each of which is applied to the input in order. fn : A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe . m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/pipe/#success","text":"Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it.","title":"Success"},{"location":"parsers/pipe/#failure","text":"Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the ones before it succeed but do not consume input.","title":"Failure"},{"location":"parsers/pipe/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after a prior parser succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/pipe/#throws","text":"Throws an error if the last argument is not a non-parser function or a string. Throws an error if the second-to-last argument is not a non-parser function if the last argument is a string. Throws an error if any other argument is not a parser.","title":"Throws"},{"location":"parsers/pipe/#see-also","text":"Parser map pipeB","title":"See Also"},{"location":"parsers/pipeb/","text":"pipeB<T>(...ps: Parser[], fn: (...args: any[]) => T): Parser<T> !!! warning \"Not a real type\" The type given above is not a real type, because TypeScript/JavaScript does not have the ability to do rest arguments before other arguments. The \"real\" type is `pipeB<T>(...ps: (Parser<any> | ((...args: any[]) => T))[]): Parser<T>` The given type is more expressive and makes for better documentation, but even that one is imperfect. TypeScript cannot express as much information in this type as would be useful. Namely, the parsers in `ps` can all have different generic parameters, and the types of the parameters to `fn` should match those generic parameters in number and in order. A two-parser `pipeB` can be expressed with `pipeB<T, U>(p: Parser<T>, q: Parser<U>, fn: (a: T, b: U) => V): Parser<V>`. A three-parser version would have the type `pipeB<T, U, V>(p: Parser<T>, q: Parser<U>, r: Parser<V>, fn: (a: T, b: U, c: V) => W): Parser<W>`, and so on. Unfortunately it's impossible to write a type with a variable number of arguments. Applies some parsers in order, then returns the result of a function to which all of the parser results have been passed. fn will be passed one argument for every member of ps . JavaScript does not enforce that there has to be a parameter for each passed argument, but likely you will want to provide an fn that has an arity equal to the number of parsers in ps . If any of the parsers fail, then backtracking will return the state to where it was before the first parser was applied. fn can return anything, so this is one of the few combinators that can return something other than a string. Example const parser = pipeB ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ABC // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter See pipe for an explanation of this example. It's identical except for the final case failing fatally there and being backtracked and failing non-fatally here. Parameters ...ps : Zero or more parsers, each of which is applied to the input in order. fn : A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe . Success Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it. Failure Fails if the any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser. See Also Parser pipe","title":"pipeB"},{"location":"parsers/pipeb/#example","text":"const parser = pipeB ( upper , lower , ( a , b ) => a . toLowerCase () + b . toUpperCase ()) const s = parse ( parser , 'Abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"aB\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter const t = parse ( parser , 'ABC' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ABC // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ABC // ^ // Expected a lowercase letter See pipe for an explanation of this example. It's identical except for the final case failing fatally there and being backtracked and failing non-fatally here.","title":"Example"},{"location":"parsers/pipeb/#parameters","text":"...ps : Zero or more parsers, each of which is applied to the input in order. fn : A function which receives the results of all of the parsers in ps if they all succeed. Its return value becomes the result of pipe .","title":"Parameters"},{"location":"parsers/pipeb/#success","text":"Succeeds if all of the parsers in ps succeed. Returns the result of fn when all of the results of ...ps are passed to it.","title":"Success"},{"location":"parsers/pipeb/#failure","text":"Fails if the any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/pipeb/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/pipeb/#throws","text":"Throws an error if the last argument is not a non-parser function. Throws an error if any other argument is not a parser.","title":"Throws"},{"location":"parsers/pipeb/#see-also","text":"Parser pipe","title":"See Also"},{"location":"parsers/range/","text":"range(s: string, e: string): Parser<string> Parses a character between s and e (inclusive). \"Between\" is defined according to code points. This is fine in most cases, but it can get weird with higher code points. For example, there is no \"h\" in the set of mathematical lowercase italic symbols. The \"h\" that would be used in that set of symbols would instead be the Planck's Constant character, which is in a completely different part of the UTF-8 spectrum and therefore is not \"between\" mathematical lowercase italic symbols a and z . Take care with non-ASCII characters. Example const parser = range ( '0' , '3' ) const s = parse ( parser , '246' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"2\" const f = parse ( parser , '468' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 468 // ^ // Expected a character between '0' and '3' Parameters s : The character representing the lower bound of the range. The next character's code point must be greater than or equal to s 's code point for the parser to succeed. e : The character representing the upper bound of the range. The next character's code point must be less than or equal to e 's code point for the parser to succeed. Success Succeeds if the code point of the next character is between the code points of s and e , inclusive. Consumes and returns that character. Failure Fails if the code point of the next character is less than s 's code point or greater than e 's code point. Throws Throws an error if either s or e are not strings or if either is not exactly one character in length. See Also Parser any char regex satisfy","title":"range"},{"location":"parsers/range/#example","text":"const parser = range ( '0' , '3' ) const s = parse ( parser , '246' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"2\" const f = parse ( parser , '468' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 468 // ^ // Expected a character between '0' and '3'","title":"Example"},{"location":"parsers/range/#parameters","text":"s : The character representing the lower bound of the range. The next character's code point must be greater than or equal to s 's code point for the parser to succeed. e : The character representing the upper bound of the range. The next character's code point must be less than or equal to e 's code point for the parser to succeed.","title":"Parameters"},{"location":"parsers/range/#success","text":"Succeeds if the code point of the next character is between the code points of s and e , inclusive. Consumes and returns that character.","title":"Success"},{"location":"parsers/range/#failure","text":"Fails if the code point of the next character is less than s 's code point or greater than e 's code point.","title":"Failure"},{"location":"parsers/range/#throws","text":"Throws an error if either s or e are not strings or if either is not exactly one character in length.","title":"Throws"},{"location":"parsers/range/#see-also","text":"Parser any char regex satisfy","title":"See Also"},{"location":"parsers/regex/","text":"regex(pattern: string | RegExp): Parser<string> Matches the current input location against a regular expression pattern. Example const parser = regex ( /^\\d+/ ) const s = parse ( parser , '123abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"123\" const f = parse ( parser , 'abc123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc123 // ^ // Expected a string matching /^\\d+/ Parameters pattern : The regular expression pattern to match against the current input location. This pattern can be either a RegExp object or a string (which is automatically converted into a RegExp object without flags). It will have an ^ anchor added to it if it doesn't already have one; all regex matches are done against the beginning of the input (based on its current state). No flags are removed, but the g flag is ignored because there can be only one match because of the ^ anchor. Success Succeeds if a match occurs at the current location of the input. The full match is returned as a single string, and that many characters are consumed. It is possible for this match to be zero characters long in the case where a * quantifier is used in the pattern. Failure Fails if there is no match at the current location of the input. Note that some patterns cannot fail; a pattern with a * quantifier, for example, can successfully match on zero characters. Throws Throws an error if pattern is neither a RegExp object or a string. Throws an error if pattern is a string and cannot be converted into a RegExp object because it is not a valid regular expression pattern. See Also Parser satisfy string","title":"regex"},{"location":"parsers/regex/#example","text":"const parser = regex ( /^\\d+/ ) const s = parse ( parser , '123abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"123\" const f = parse ( parser , 'abc123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc123 // ^ // Expected a string matching /^\\d+/","title":"Example"},{"location":"parsers/regex/#parameters","text":"pattern : The regular expression pattern to match against the current input location. This pattern can be either a RegExp object or a string (which is automatically converted into a RegExp object without flags). It will have an ^ anchor added to it if it doesn't already have one; all regex matches are done against the beginning of the input (based on its current state). No flags are removed, but the g flag is ignored because there can be only one match because of the ^ anchor.","title":"Parameters"},{"location":"parsers/regex/#success","text":"Succeeds if a match occurs at the current location of the input. The full match is returned as a single string, and that many characters are consumed. It is possible for this match to be zero characters long in the case where a * quantifier is used in the pattern.","title":"Success"},{"location":"parsers/regex/#failure","text":"Fails if there is no match at the current location of the input. Note that some patterns cannot fail; a pattern with a * quantifier, for example, can successfully match on zero characters.","title":"Failure"},{"location":"parsers/regex/#throws","text":"Throws an error if pattern is neither a RegExp object or a string. Throws an error if pattern is a string and cannot be converted into a RegExp object because it is not a valid regular expression pattern.","title":"Throws"},{"location":"parsers/regex/#see-also","text":"Parser satisfy string","title":"See Also"},{"location":"parsers/repeat/","text":"repeat(p: Parser, n: number, m?: string): Parser Applies a parser a certain number of times, collecting the results into an array to return. The parser p must succeed the full n times for repeat to succeed. Any fewer successes results in failure. As with other combinators that run multiple parsers, it's possible for repeat to fail fatally even if the parser that failed did not fail fatally (because, for example, an earlier success consumed some input). There is another version of this parser, repeatB , that will backtrack and fail non-fatally when this happens. Example const parser = repeat ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter Parameters p : The parser to apply. Its results are returned in an array. n : The number of times that p is applied. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds n times. The results are collected into an array and returned. Failure Fails if p does not succeed at least once. Fails if p succeeds at least once but not n times and if the prior successes of do not consume any input. Fatal Failure Fails fatally if p fails fatally. Fails fatally if p does not succeed n times and if prior successes consume some input. Throws Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if m exists and is not a string. See Also Parser opt repeatB seq","title":"repeat"},{"location":"parsers/repeat/#example","text":"const parser = repeat ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter","title":"Example"},{"location":"parsers/repeat/#parameters","text":"p : The parser to apply. Its results are returned in an array. n : The number of times that p is applied. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/repeat/#success","text":"Succeeds if p succeeds n times. The results are collected into an array and returned.","title":"Success"},{"location":"parsers/repeat/#failure","text":"Fails if p does not succeed at least once. Fails if p succeeds at least once but not n times and if the prior successes of do not consume any input.","title":"Failure"},{"location":"parsers/repeat/#fatal-failure","text":"Fails fatally if p fails fatally. Fails fatally if p does not succeed n times and if prior successes consume some input.","title":"Fatal Failure"},{"location":"parsers/repeat/#throws","text":"Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/repeat/#see-also","text":"Parser opt repeatB seq","title":"See Also"},{"location":"parsers/repeatb/","text":"repeatB(p: Parser, n: number, m?: string): Parser Applies a parser a certain number of times, collecting the results into an array to return. The parser p must succeed the full n times for repeatB to succeed. Any fewer successes results in failure. Any input that is consumed in the process will be backtracked. Example const parser = repeatB ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab3 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter Parameters p : The parser to apply. Its results are returned in an array. n : The number of times that p is applied. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds n times. The results are collected into an array and returned. Failure Fails if p fails before it has succeeded n times. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if p fails fatally before it has succeeded n times. Throws Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if m exists and is not a string. See Also Parser repeat seqB","title":"repeatB"},{"location":"parsers/repeatb/#example","text":"const parser = repeatB ( letter , 3 ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\"] const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter const t = parse ( parser , 'ab3' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab3 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab3 // ^ // Expected a letter","title":"Example"},{"location":"parsers/repeatb/#parameters","text":"p : The parser to apply. Its results are returned in an array. n : The number of times that p is applied. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/repeatb/#success","text":"Succeeds if p succeeds n times. The results are collected into an array and returned.","title":"Success"},{"location":"parsers/repeatb/#failure","text":"Fails if p fails before it has succeeded n times. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/repeatb/#fatal-failure","text":"Fails fatally if p fails fatally before it has succeeded n times.","title":"Fatal Failure"},{"location":"parsers/repeatb/#throws","text":"Throws an error if p is not a parser. Throws an error if n is not a number. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/repeatb/#see-also","text":"Parser repeat seqB","title":"See Also"},{"location":"parsers/right/","text":"right(p: Parser, q: Parser, m?: string): Parser Applies two parsers in order, returning the result of the second one. The result of the first parser is discarded. If either parser fails, then the entire right parser also fails. If input was consumed by either parser and one of them fails, then the failure is fatal (whether or not p or q failed fatally). There is another version of this parser ( rightB ) that will backtrack and fail non-fatally if p succeeds and q fails non-fatally. right(p, q) is the equivalent of p *> q in the Haskell Applicative class and is written >>. in FParsec. It can be regarded as an optimized implementation of either of the following. chain(p, () => q) // monadic style apply(p, apply(q, x => () => x)) // applicative style Example const parser = right ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally. Parameters p : The first parser to apply. This parser's result will be discarded. q : The second parser to apply. If both parsers succeed, this parser's result will be right 's result. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and q succeed. Returns the result of q . Failure Fails if p fails. Fails if q fails after p succeeds but does not consume any input. Fatal Failure Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeeds and consumes some input. Throws Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. See Also Parser left rightB seq","title":"right"},{"location":"parsers/right/#example","text":"const parser = right ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit In this example, f represents a non-fatal failure because the first parser ( letter ) failed without consuming, but t represents a fata failure because the first parser consumed a character before the second parser ( digit ) failed non-fatally.","title":"Example"},{"location":"parsers/right/#parameters","text":"p : The first parser to apply. This parser's result will be discarded. q : The second parser to apply. If both parsers succeed, this parser's result will be right 's result. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/right/#success","text":"Succeeds if both p and q succeed. Returns the result of q .","title":"Success"},{"location":"parsers/right/#failure","text":"Fails if p fails. Fails if q fails after p succeeds but does not consume any input.","title":"Failure"},{"location":"parsers/right/#fatal-failure","text":"Fails fatally if either p or q fail fatally. Fails fatally if q fails after p succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/right/#throws","text":"Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/right/#see-also","text":"Parser left rightB seq","title":"See Also"},{"location":"parsers/rightb/","text":"rightB(p: Parser, q: Parser, m?: string): Parser Applies two parsers in order, returning the result of the second one. The result of the first parser is discarded. If either parser fails, then the entire rightB parser also fails. If input was consumed by either parser and one of them fails, backtracking will take the state back to where it was before p was applied. Example const parser = rightB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit Parameters p : The first parser to apply. This parser's result will be discarded. q : The second parser to apply. If both parsers succeed, this parser's result will be rightB 's result. m : The optional expected error message that will take the place of the default error message. Success Succeeds if both p and q succeed. Returns the result of q . Failure Fails if either p or q fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or q fail fatally. Throws Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string. See Also Parser leftB right seqB","title":"rightB"},{"location":"parsers/rightb/#example","text":"const parser = rightB ( letter , digit ) const s = parse ( parser , 'a1' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"1\" const f = parse ( parser , '12' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 12 // ^ // Expected a letter const t = parse ( parser , 'ab' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab // ^ // The parser backtracked after: // // Parse error at (line 1, column 2): // // ab // ^ // Expected a digit","title":"Example"},{"location":"parsers/rightb/#parameters","text":"p : The first parser to apply. This parser's result will be discarded. q : The second parser to apply. If both parsers succeed, this parser's result will be rightB 's result. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/rightb/#success","text":"Succeeds if both p and q succeed. Returns the result of q .","title":"Success"},{"location":"parsers/rightb/#failure","text":"Fails if either p or q fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/rightb/#fatal-failure","text":"Fails fatally if either p or q fail fatally.","title":"Fatal Failure"},{"location":"parsers/rightb/#throws","text":"Throws an error if either p or q are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/rightb/#see-also","text":"Parser leftB right seqB","title":"See Also"},{"location":"parsers/satisfy/","text":"satisfy(fn: (arg: string) => boolean): Parser<string> Parses a character for which the predicate fn returns true when passed that character. Since the parser cannot reasonably figure out what conditions cause fn to pass, it does not generate an error message on failure by default. To provide a useful error message, supply that message as the optional second argument. Example const parser = satisfy ( x => x === x . toUpperCase ()) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Unknown error(s) Parameters fn : The predicate function that the next character must pass in order for the parser to succeed. Success Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character. Failure Fails if fn returns false when the next character is passed into it. Throws Throws an error if fn is not a non-parser function. See Also Parser range regex satisfyM","title":"satisfy"},{"location":"parsers/satisfy/#example","text":"const parser = satisfy ( x => x === x . toUpperCase ()) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Unknown error(s)","title":"Example"},{"location":"parsers/satisfy/#parameters","text":"fn : The predicate function that the next character must pass in order for the parser to succeed.","title":"Parameters"},{"location":"parsers/satisfy/#success","text":"Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character.","title":"Success"},{"location":"parsers/satisfy/#failure","text":"Fails if fn returns false when the next character is passed into it.","title":"Failure"},{"location":"parsers/satisfy/#throws","text":"Throws an error if fn is not a non-parser function.","title":"Throws"},{"location":"parsers/satisfy/#see-also","text":"Parser range regex satisfyM","title":"See Also"},{"location":"parsers/satisfym/","text":"satisfyM(fn: (arg: string) => boolean, msg: string): Parser<string> Parses a character for which predicate fn returns true when passed that character. If the parser fails, msg is used as the expected error message. Example const parser = satisfyM ( x => x === x . toUpperCase (), 'an uppercase letter' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter Parameters fn : The predicate function that the next character must pass in order for the parser to succeed. msg : The text of the error message generated if the parser fails. Success Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character. Failure Fails if fn returns false when the next character is passed into it. If this happens, expected(msg) is used as the error message. Throws Throws an error if fn is not a non-parser function. Throws an error if str is not a string. See Also Parser satisfy","title":"satisfyM"},{"location":"parsers/satisfym/#example","text":"const parser = satisfyM ( x => x === x . toUpperCase (), 'an uppercase letter' ) const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter","title":"Example"},{"location":"parsers/satisfym/#parameters","text":"fn : The predicate function that the next character must pass in order for the parser to succeed. msg : The text of the error message generated if the parser fails.","title":"Parameters"},{"location":"parsers/satisfym/#success","text":"Succeeds if fn returns true when the next character is passed into it. Consumes and returns that character.","title":"Success"},{"location":"parsers/satisfym/#failure","text":"Fails if fn returns false when the next character is passed into it. If this happens, expected(msg) is used as the error message.","title":"Failure"},{"location":"parsers/satisfym/#throws","text":"Throws an error if fn is not a non-parser function. Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/satisfym/#see-also","text":"Parser satisfy","title":"See Also"},{"location":"parsers/second/","text":"second(p: Parser, m?: string): Parser Applies a parser and returns the second element of the resulting array. This parser works only if p returns an array, and it returns the second element of that array. It's most useful with parsers like seq and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. second(p) is an optimized implementation of chain(p, x => always(x[1])) . Example const parser = second ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"2\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the second element of the array that p returns. If there are not at least two elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array. See Also Parser fifth first fourth nth third","title":"second"},{"location":"parsers/second/#example","text":"const parser = second ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"2\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/second/#parameters","text":"p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/second/#success","text":"Succeeds if p succeeds. Returns the second element of the array that p returns. If there are not at least two elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/second/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/second/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/second/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/second/#see-also","text":"Parser fifth first fourth nth third","title":"See Also"},{"location":"parsers/sep/","text":"sep(p: Parser, s: Parser, m?: string): Parser Parses zero or more occurrences of a content parser, separated by a separator parser. sep applies the content parser p zero or more times as long as both it and the preceding separator parser s match. The operation of the parser in EBNF is (p (s p)*)? . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser must be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the content parser (i.e., at the beginning of the text matched by the separator parser). Example const parser = sep ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string. See Also Parser end sep1","title":"sep"},{"location":"parsers/sep/#example","text":"const parser = sep ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sep/#parameters","text":"p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/sep/#success","text":"Succeeds as long as neither parser fails fatally. When either parser first fails, the successful results of p up to that point are collected and returned. Since p can match zero or more times, even failure to match p altogether still results in success, just with an empty array as a result.","title":"Success"},{"location":"parsers/sep/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sep/#throws","text":"Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/sep/#see-also","text":"Parser end sep1","title":"See Also"},{"location":"parsers/sep1/","text":"sep1(p: Parser, s: Parser, m?: string): Parser Parses one or more occurrences of a content parser, separated by a separator parser. sep1 applies the content parser p one or more times as long as both it and the preceding separator parser s match. The operation of the parser in EBNF is p (s p)* . Results of the separator parser are discarded, but results of the content parser are returned in an array. The content parser must be the last to match. If the separator parser succeeds but the content parser fails after it, then the parser state is left at the location immediately after the last success of the content parser (i.e., at the beginning of the text matched by the separator parser). Example const parser = sep1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter Parameters p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned. Failure Fails if p does not succeed at least once. Fatal Failure Fails fatally if either parser fails fatally. Throws Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string. See Also Parser end1 sep","title":"sep1"},{"location":"parsers/sep1/#example","text":"const parser = sep1 ( count ( letter , 3 ), char ( ',' )) const s = parse ( parser , 'aaa,bbb,ccc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"aaa\", \"bbb\", \"ccc\"] const f = parse ( parser , '111' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 111 // ^ // Expected a letter const t = parse ( parser , 'aaa,bbb,cc1' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 11): // // aaa,bbb,cc1 // ^ // Expected a letter","title":"Example"},{"location":"parsers/sep1/#parameters","text":"p : The content parser. The results of this parser are returned in an array. s : The separator parser. The results of this parser are discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/sep1/#success","text":"Succeeds as long as p matches at least once and neither parser fails fatally. When either parser first fails after at least one success from p , the successful results of p up to that point are collected and returned.","title":"Success"},{"location":"parsers/sep1/#failure","text":"Fails if p does not succeed at least once.","title":"Failure"},{"location":"parsers/sep1/#fatal-failure","text":"Fails fatally if either parser fails fatally.","title":"Fatal Failure"},{"location":"parsers/sep1/#throws","text":"Throws an error if either p or s are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/sep1/#see-also","text":"Parser end1 sep","title":"See Also"},{"location":"parsers/seq/","text":"seq(...ps: Parser[], m?: string): Parser Applies a series of parsers in order, returning an array that contains each parser's result. seq will only succeed if all of its parsers succeed. If one of them fails, seq will fail fatally if it had consumed any input up to that point, even if the parser that failed did so non-fatally. There is another version of this parser ( seqB ) that fails non-fatally and backtracks if the parser that fails does so non-fatally. All of the results are gathered into an array. Example const parser = seq ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter Parameters ...ps : A series of parsers to apply to the input, one at a time, in order. m : An optional message to be used as the expected error message in the event of failure, in place of the collected expected error messages of the parsers in ps . Success Succeeds if every parser in ps succeeds. Returns all of the results of the parsers in ps gathered into an array. Failure Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the prior parsers succeed but do not consume any input. Fatal Failure Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after any prior parser succeeds and consumes some input. Throws Throws an error if any member of ps is not a parser. See Also Parser block left right seqB","title":"seq"},{"location":"parsers/seq/#example","text":"const parser = seq ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter","title":"Example"},{"location":"parsers/seq/#parameters","text":"...ps : A series of parsers to apply to the input, one at a time, in order. m : An optional message to be used as the expected error message in the event of failure, in place of the collected expected error messages of the parsers in ps .","title":"Parameters"},{"location":"parsers/seq/#success","text":"Succeeds if every parser in ps succeeds. Returns all of the results of the parsers in ps gathered into an array.","title":"Success"},{"location":"parsers/seq/#failure","text":"Fails if the first parser in ps fails. Fails if any subsequent parser in ps fails after the prior parsers succeed but do not consume any input.","title":"Failure"},{"location":"parsers/seq/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally. Fails fatally if any parser in ps fails after any prior parser succeeds and consumes some input.","title":"Fatal Failure"},{"location":"parsers/seq/#throws","text":"Throws an error if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/seq/#see-also","text":"Parser block left right seqB","title":"See Also"},{"location":"parsers/seqb/","text":"seqB(...ps: Parser[], m?: string): Parser Applies a series of parsers in order, returning an array that contains each parser's result. seqB will only succeed if all of its parsers succeed. If one of them fails, seqB will also fail. If input was consumed before the failure occurred, seqB will backtrack to the location where its first parser was applied. All of the results are gathered into an array. Example const parser = seqB ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a11 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter Parameters ...ps : A series of parsers to apply to the input, one at a time, in order. m : An optional message to be used as the expected error message in the event of failure, in place of the collected expected error messages of the parsers in ps . Success Succeeds if every parser in ps succeeds. Returns all of the results of the parsers in ps gathered into an array. Failure Fails if any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if any parser in ps fails fatally. Throws Throws an error if any member of ps is not a parser. See Also Parser blockB leftB rightB seq","title":"seqB"},{"location":"parsers/seqb/#example","text":"const parser = seqB ( letter , digit , letter ) const s = parse ( parser , 'a1b' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"1\", \"b\"] const f = parse ( parser , '11b' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 11b // ^ // Expected a letter const t = parse ( parser , 'a11' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // a11 // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // a11 // ^ // Expected a letter","title":"Example"},{"location":"parsers/seqb/#parameters","text":"...ps : A series of parsers to apply to the input, one at a time, in order. m : An optional message to be used as the expected error message in the event of failure, in place of the collected expected error messages of the parsers in ps .","title":"Parameters"},{"location":"parsers/seqb/#success","text":"Succeeds if every parser in ps succeeds. Returns all of the results of the parsers in ps gathered into an array.","title":"Success"},{"location":"parsers/seqb/#failure","text":"Fails if any parser in ps fails. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/seqb/#fatal-failure","text":"Fails fatally if any parser in ps fails fatally.","title":"Fatal Failure"},{"location":"parsers/seqb/#throws","text":"Throws an error if any member of ps is not a parser.","title":"Throws"},{"location":"parsers/seqb/#see-also","text":"Parser blockB leftB rightB seq","title":"See Also"},{"location":"parsers/skip/","text":"skip(p: Parser, m?: string): Parser Applies a parser and discards its result on success. skip(p) is an optimized implementation of chain(p, () => always(null)) . Example const parser = skip ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter Parameters p : The parser to apply to the input. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Discards the result and returns null . Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser opt","title":"skip"},{"location":"parsers/skip/#example","text":"const parser = skip ( letter ) const s = parse ( parser , 'abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , '123' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 123 // ^ // Expected a letter","title":"Example"},{"location":"parsers/skip/#parameters","text":"p : The parser to apply to the input. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/skip/#success","text":"Succeeds if p succeeds. Discards the result and returns null .","title":"Success"},{"location":"parsers/skip/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/skip/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/skip/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/skip/#see-also","text":"Parser opt","title":"See Also"},{"location":"parsers/space/","text":"space: Parser<string> Parses an ASCII whitespace character. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Example const parser = space const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a whitespace character Success Succeeds if the next character is an ASCII whitespace character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser newline spaces spaces1 spaceU","title":"space"},{"location":"parsers/space/#example","text":"const parser = space const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a whitespace character","title":"Example"},{"location":"parsers/space/#success","text":"Succeeds if the next character is an ASCII whitespace character. Consumes and returns that character.","title":"Success"},{"location":"parsers/space/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/space/#see-also","text":"Parser newline spaces spaces1 spaceU","title":"See Also"},{"location":"parsers/spaces/","text":"spaces: Parser<null> Parses zero or more ASCII whitespace characters and discards them. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Example const parser = spaces const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null Success Always succeeds. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded. See Also Parser newline space spaces1 spacesU","title":"spaces"},{"location":"parsers/spaces/#example","text":"const parser = spaces const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null","title":"Example"},{"location":"parsers/spaces/#success","text":"Always succeeds. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces/#see-also","text":"Parser newline space spaces1 spacesU","title":"See Also"},{"location":"parsers/spaces1/","text":"spaces1: Parser<null> Parses one or more ASCII whitespace characters and discards them. ASCII whitespace characters include any ASCII newline ( \\r , \\n , or \\r\\n ) along with a space ( ) or a horizontal tab ( \\t ). Example const parser = spaces1 const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more whitespace characters Success Succeeds if at least one ASCII whitespace character is read. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded. Failure Fails if the next character is not an ASCII whitespace character. See Also Parser newline space spaces spaces1U","title":"spaces1"},{"location":"parsers/spaces1/#example","text":"const parser = spaces1 const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more whitespace characters","title":"Example"},{"location":"parsers/spaces1/#success","text":"Succeeds if at least one ASCII whitespace character is read. All ASCII whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces1/#failure","text":"Fails if the next character is not an ASCII whitespace character.","title":"Failure"},{"location":"parsers/spaces1/#see-also","text":"Parser newline space spaces spaces1U","title":"See Also"},{"location":"parsers/spaces1u/","text":"spaces1U: Parser<null> Parses one or more Unicode whitespace characters and discards them. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Example const parser = spaces1U const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more Unicode whitespace characters Success Succeeds if at least one Unicode whitespace character is read. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded. Failure Fails if the next character is not a Unicode whitespace character. See Also Parser newlineU spaces1 spacesU spaceU","title":"spaces1U"},{"location":"parsers/spaces1u/#example","text":"const parser = spaces1U const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected one or more Unicode whitespace characters","title":"Example"},{"location":"parsers/spaces1u/#success","text":"Succeeds if at least one Unicode whitespace character is read. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spaces1u/#failure","text":"Fails if the next character is not a Unicode whitespace character.","title":"Failure"},{"location":"parsers/spaces1u/#see-also","text":"Parser newlineU spaces1 spacesU spaceU","title":"See Also"},{"location":"parsers/spacesu/","text":"spacesU: Parser<null> Parses zero or more Unicode whitespace characters and discards them. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Example const parser = spacesU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null Success Always succeeds. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded. See Also Parser newlineU spaces spaces1U spaceU","title":"spacesU"},{"location":"parsers/spacesu/#example","text":"const parser = spacesU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // null","title":"Example"},{"location":"parsers/spacesu/#success","text":"Always succeeds. All Unicode whitespace characters until the next non-whitespace character are consumed and discarded.","title":"Success"},{"location":"parsers/spacesu/#see-also","text":"Parser newlineU spaces spaces1U spaceU","title":"See Also"},{"location":"parsers/spaceu/","text":"spaceU: Parser<string> Parse a Unicode whitespace character. A character is a Unicode whitespace character if it has the Unicode White_Space binary property. There are around 25 of these characters. Example const parser = spaceU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode whitespace character Success Succeeds if the next character is a Unicode whitespace character. Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser newlineU space spaces1U spacesU","title":"spaceU"},{"location":"parsers/spaceu/#example","text":"const parser = spaceU const s = parse ( parser , ' abc' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \" \" const f = parse ( parser , 'abc ' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected a Unicode whitespace character","title":"Example"},{"location":"parsers/spaceu/#success","text":"Succeeds if the next character is a Unicode whitespace character. Consumes and returns that character.","title":"Success"},{"location":"parsers/spaceu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/spaceu/#see-also","text":"Parser newlineU space spaces1U spacesU","title":"See Also"},{"location":"parsers/string/","text":"string(str: string): Parser<string> Parses the string str . The number of characters read equals the number of characters in str . If there are not that many characters remaining in the input, the parser will automatically fail. If str is the empty string, the parser will automatically succeed and consume no input. Example const parser = string ( 'Test' ) const s = parse ( parser , 'Testing' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"Test\" const f = parse ( parser , 'test' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test // ^ // Expected 'Test' Parameters str : The string to match against the input at its current location. Success Succeeds if the first n characters of the input at its current location is the same as str , where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input. Failure Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str . Throws Throws an error if str is not a string. See Also Parser char regex stringI","title":"string"},{"location":"parsers/string/#example","text":"const parser = string ( 'Test' ) const s = parse ( parser , 'Testing' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"Test\" const f = parse ( parser , 'test' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // test // ^ // Expected 'Test'","title":"Example"},{"location":"parsers/string/#parameters","text":"str : The string to match against the input at its current location.","title":"Parameters"},{"location":"parsers/string/#success","text":"Succeeds if the first n characters of the input at its current location is the same as str , where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input.","title":"Success"},{"location":"parsers/string/#failure","text":"Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str .","title":"Failure"},{"location":"parsers/string/#throws","text":"Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/string/#see-also","text":"Parser char regex stringI","title":"See Also"},{"location":"parsers/stringi/","text":"stringI(str: string): Parser<string> Parses the string str case-insensitively. The number of characters read equals the number of characters in str . If there are not that many characters remaining in the input, the parser will automatically fail. If str is the empty string, the parser will automatically succeed and consume no input. Example const parser = stringI ( 'Test' ) const s = parse ( parser , 'testing' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"test\" const f = parse ( parser , 'oops' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // oops // ^ // Expected 'Test' Parameters str : The string to case-insensitively match against the input at its current location. Success Succeeds if the first n characters of the input at its current location is the same as str (case-insensitive), where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input. Failure Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str case-insensitively. Throws Throws an error if str is not a string. See Also Parser charI regex string","title":"stringI"},{"location":"parsers/stringi/#example","text":"const parser = stringI ( 'Test' ) const s = parse ( parser , 'testing' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"test\" const f = parse ( parser , 'oops' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // oops // ^ // Expected 'Test'","title":"Example"},{"location":"parsers/stringi/#parameters","text":"str : The string to case-insensitively match against the input at its current location.","title":"Parameters"},{"location":"parsers/stringi/#success","text":"Succeeds if the first n characters of the input at its current location is the same as str (case-insensitive), where n equals the number of characters in str (including 0; having str be the empty string causes automatic success). The read characters are returned as a single string, and that many characters are consumed from the input.","title":"Success"},{"location":"parsers/stringi/#failure","text":"Fails if there are not as many characters left in the input as there are in str . Fails if the first n characters do not equal str case-insensitively.","title":"Failure"},{"location":"parsers/stringi/#throws","text":"Throws an error if str is not a string.","title":"Throws"},{"location":"parsers/stringi/#see-also","text":"Parser charI regex string","title":"See Also"},{"location":"parsers/third/","text":"third(p: Parser, m?: string): Parser Applies a parser and returns the third element of the resulting array. This parser works only if p returns an array, and it returns the third element of that array. It's most useful with parsers like seq and many that always return arrays, though it will work with parsers like map and always if they are programmed to return arrays. third(p) is an optimized implementation of chain(p, x => always(x[2])) . Example const parser = third ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"3\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input Parameters p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. Returns the third element of the array that p returns. If there are not at least three elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array. See Also Parser fifth first fourth nth second","title":"third"},{"location":"parsers/third/#example","text":"const parser = third ( many1 ( any )) const s = parse ( parser , '12345' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"3\" const f = parse ( parser , '' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // // ^ // Expected any character // Note: failure occurred at the end of input","title":"Example"},{"location":"parsers/third/#parameters","text":"p : The parser to apply. This parser should return an array. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/third/#success","text":"Succeeds if p succeeds. Returns the third element of the array that p returns. If there are not at least three elements in that array, it will return undefined in the same manner that undefined is always returned when indexing a non-existent element of an array.","title":"Success"},{"location":"parsers/third/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/third/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/third/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string. Throws an error if p succeeds but does not return an array.","title":"Throws"},{"location":"parsers/third/#see-also","text":"Parser fifth first fourth nth second","title":"See Also"},{"location":"parsers/until/","text":"until(p: Parser, e: Parser, m?: string): Parser Applies a content parser zero or more times as long as an end parser continues to fail. Once the end parser succeeds, the content parser's successes are collected into an array and returned. This parser differs from between in that the e parser is applied first ; because of this, there is no possibility of content parser p consuming whatever e is supposed to match and thereby causing the combinator to fail. The operation of this parser in EBNF is (!e p)* e . Example const parser = until ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter Parameters p : The content parser. After e succeeds, the prior results of this parser are returned as an array. e : The end parser. p will continue to be applied until e succeeds. Its result is discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds as long as e succeeds before p fails. Returns the results of p as an array. If e succeeds on the first attempt, p is never applied and the returned array is empty. Failure Fails if p and e both fail initially. Fails if p fails before e succeeds and prior successes from p did not consume any input. Fatal Failure Fails fatally if either p or e fail fatally. Fails fatally if p fails before e succeeds and prior successes from p consumed some input. Throws Throws an error if either p or e are not parsers. Throws an error if m exists and is not a string. See Also Parser between seq untilB","title":"until"},{"location":"parsers/until/#example","text":"const parser = until ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // \"fatal\" console . log ( failure ( t )) // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter","title":"Example"},{"location":"parsers/until/#parameters","text":"p : The content parser. After e succeeds, the prior results of this parser are returned as an array. e : The end parser. p will continue to be applied until e succeeds. Its result is discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/until/#success","text":"Succeeds as long as e succeeds before p fails. Returns the results of p as an array. If e succeeds on the first attempt, p is never applied and the returned array is empty.","title":"Success"},{"location":"parsers/until/#failure","text":"Fails if p and e both fail initially. Fails if p fails before e succeeds and prior successes from p did not consume any input.","title":"Failure"},{"location":"parsers/until/#fatal-failure","text":"Fails fatally if either p or e fail fatally. Fails fatally if p fails before e succeeds and prior successes from p consumed some input.","title":"Fatal Failure"},{"location":"parsers/until/#throws","text":"Throws an error if either p or e are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/until/#see-also","text":"Parser between seq untilB","title":"See Also"},{"location":"parsers/untilb/","text":"untilB(p: Parser, e: Parser, m?: string): Parser Applies a content parser zero or more times as long as an end parser continues to fail. Once the end parser succeeds, the content parser's successes are collected into an array and returned. This parser differs from betweenB in that the e parser is applied first ; because of this, there is no possibility of content parser p consuming whatever e is supposed to match and thereby causing the combinator to fail. If p fails before e succeeds and input was consumed, the state will backtrack to where it was before p was applied the first time. Example const parser = untilB ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab12> // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter Parameters p : The content parser. After e succeeds, the prior results of this parser are returned as an array. e : The end parser. p will continue to be applied until e succeeds. Its result is discarded. m : The optional expected error message that will take the place of the default error message. Success Succeeds as long as e succeeds before p fails. Returns the results of p as an array. If e succeeds on the first attempt, p is never applied and the returned array is empty. Failure Fails if p fails before e succeeds. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking. Fatal Failure Fails fatally if either p or e fail fatally. Throws Throws an error if either p or e are not parsers. Throws an error if m exists and is not a string. See Also Parser betweenB seqB until","title":"untilB"},{"location":"parsers/untilb/#example","text":"const parser = untilB ( letter , char ( '>' )) const s = parse ( parser , 'abcd>' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // [\"a\", \"b\", \"c\", \"d\"] const f = parse ( parser , '1234>' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // 1234> // ^ // Expected a letter const t = parse ( parser , 'ab12>' ) console . log ( status ( t )) // \"fail\" console . log ( failure ( t )) // Parse error at (line 1, column 1): // // ab12> // ^ // The parser backtracked after: // // Parse error at (line 1, column 3): // // ab12> // ^ // Expected a letter","title":"Example"},{"location":"parsers/untilb/#parameters","text":"p : The content parser. After e succeeds, the prior results of this parser are returned as an array. e : The end parser. p will continue to be applied until e succeeds. Its result is discarded. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/untilb/#success","text":"Succeeds as long as e succeeds before p fails. Returns the results of p as an array. If e succeeds on the first attempt, p is never applied and the returned array is empty.","title":"Success"},{"location":"parsers/untilb/#failure","text":"Fails if p fails before e succeeds. If any input was consumed, backtracking will occur and an additional error message will be provided that details the circumstances of the backtracking.","title":"Failure"},{"location":"parsers/untilb/#fatal-failure","text":"Fails fatally if either p or e fail fatally.","title":"Fatal Failure"},{"location":"parsers/untilb/#throws","text":"Throws an error if either p or e are not parsers. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/untilb/#see-also","text":"Parser betweenB seqB until","title":"See Also"},{"location":"parsers/upper/","text":"upper: Parser<string> Parses an ASCII uppercase letter ( A-Z ). This does not parse UTF-8 uppercase letters in general. Use upperU for that. Example const parser = upper const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter Success Succeeds if the next character is an ASCII uppercase letter ( A-Z ). Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alpha letter lower upperU","title":"upper"},{"location":"parsers/upper/#example","text":"const parser = upper const s = parse ( parser , 'ABC' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , 'abc' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // abc // ^ // Expected an uppercase letter","title":"Example"},{"location":"parsers/upper/#success","text":"Succeeds if the next character is an ASCII uppercase letter ( A-Z ). Consumes and returns that character.","title":"Success"},{"location":"parsers/upper/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/upper/#see-also","text":"Parser alpha letter lower upperU","title":"See Also"},{"location":"parsers/upperu/","text":"upperU: Parser<string> Parses either a Unicode uppercase letter or a Unicode titlecase character. A character is a Unicode uppercase character if it has the Unicode Uppercase binary property. This is approximately equal to characters that match the regular expression /\\p{Lu}/u except with a few additional characters. A character is a Unicode titlecase character if it has the Unicode Letter, Titlecase property, which is the same as characters that match the regular expression /\\p{Lt}/u . Titlecase characters are typically ligatures of an uppercase character with a lowercase character, such as \u01c8 . (The double-lowercase counterparts such as \u01c9 are considered lowercase letters and would be parsed by lowerU .) Example const parser = upperU const s = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0430\u0431\u0432 // ^ // Expected a Unicode uppercase letter Success Succeeds if the next character is a Unicode uppercase or titlecase letter. Consumes and returns that character. Failure Fails if the next character is any other character. See Also Parser alphaU letterU lowerU upper","title":"upperU"},{"location":"parsers/upperu/#example","text":"const parser = upperU const s = parse ( parser , '\u0410\u0411\u0412' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) // \"A\" const f = parse ( parser , '\u0430\u0431\u0432' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \u0430\u0431\u0432 // ^ // Expected a Unicode uppercase letter","title":"Example"},{"location":"parsers/upperu/#success","text":"Succeeds if the next character is a Unicode uppercase or titlecase letter. Consumes and returns that character.","title":"Success"},{"location":"parsers/upperu/#failure","text":"Fails if the next character is any other character.","title":"Failure"},{"location":"parsers/upperu/#see-also","text":"Parser alphaU letterU lowerU upper","title":"See Also"},{"location":"parsers/value/","text":"value(p: Parser, x: *, m?: string): Parser Applies a parser and, if it succeeds, returns another value. x can be anything, so value is one of the few combinators that can return something other than a string. value(p, x) is an optimized implementation of chain(p, () => always(x)) . Example const parser = value ( string ( '\"\"' ), '\"' ) const s = parse ( parser , '\"\"' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) / \"\\\"\" const f = parse ( parser , '\"' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \" // ^ // Expected '\"\"' In this example, if the parser string('\"\"') succeeds, then value returns a single character ( \" ). This parser could be used for detecting a quote inside a quoted string in CSV, for instance, where quotation marks are escaped by doubling them. Parameters p : The parser that gets applied to the input. x : The value for value to return if p succeeds. m : The optional expected error message that will take the place of the default error message. Success Succeeds if p succeeds. In this case, the result of p is discarded and x is returned instead. Failure Fails if p fails. Fatal Failure Fails fatally if p fails fatally. Throws Throws an error if p is not a parser. Throws an error if m exists and is not a string. See Also Parser always","title":"value"},{"location":"parsers/value/#example","text":"const parser = value ( string ( '\"\"' ), '\"' ) const s = parse ( parser , '\"\"' ) console . log ( status ( s )) // \"ok\" console . log ( success ( s )) / \"\\\"\" const f = parse ( parser , '\"' ) console . log ( status ( f )) // \"fail\" console . log ( failure ( f )) // Parse error at (line 1, column 1): // // \" // ^ // Expected '\"\"' In this example, if the parser string('\"\"') succeeds, then value returns a single character ( \" ). This parser could be used for detecting a quote inside a quoted string in CSV, for instance, where quotation marks are escaped by doubling them.","title":"Example"},{"location":"parsers/value/#parameters","text":"p : The parser that gets applied to the input. x : The value for value to return if p succeeds. m : The optional expected error message that will take the place of the default error message.","title":"Parameters"},{"location":"parsers/value/#success","text":"Succeeds if p succeeds. In this case, the result of p is discarded and x is returned instead.","title":"Success"},{"location":"parsers/value/#failure","text":"Fails if p fails.","title":"Failure"},{"location":"parsers/value/#fatal-failure","text":"Fails fatally if p fails fatally.","title":"Fatal Failure"},{"location":"parsers/value/#throws","text":"Throws an error if p is not a parser. Throws an error if m exists and is not a string.","title":"Throws"},{"location":"parsers/value/#see-also","text":"Parser always","title":"See Also"},{"location":"tools/compound/","text":"compound(msg: string, ctx: Context, errors: ErrorList): [CompoundError] Creates a compound error using ctx to describe where the errors in the list errors happened. Additionally, msg can be used to give further information about this context. This is used to detail information about an actual error location after backtracking has moved the current context away from that location. The errors parameter will become the error list for the new compound error. However, if errors itself contains only a single nested error, it will be collapsed into this new compound error. There is no need to have a compound error that contains nothing except a nested error. Parameters msg : A message describing the context or the error. ctx : The context where the nested error(s) happened. errors : The error(s) that happened in that location. Returns Returns a list containing a single compound error, whose own error list will contain the errors that happened at its context's location. See Also CompoundError ErrorList compound","title":"compound"},{"location":"tools/compound/#parameters","text":"msg : A message describing the context or the error. ctx : The context where the nested error(s) happened. errors : The error(s) that happened in that location.","title":"Parameters"},{"location":"tools/compound/#returns","text":"Returns a list containing a single compound error, whose own error list will contain the errors that happened at its context's location.","title":"Returns"},{"location":"tools/compound/#see-also","text":"CompoundError ErrorList compound","title":"See Also"},{"location":"tools/expected/","text":"expected(msg: string): [LocalError] Creates an error describing what outcome was expected. This error's type will be ErrorType.Expected . This is returned as a single-element ErrorList . For a larger list, use merge to join lists. Parameters msg : The error message describing what was expected. Returns Returns a single-element array with one error in it. See Also ErrorList LocalError merge","title":"expected"},{"location":"tools/expected/#parameters","text":"msg : The error message describing what was expected.","title":"Parameters"},{"location":"tools/expected/#returns","text":"Returns a single-element array with one error in it.","title":"Returns"},{"location":"tools/expected/#see-also","text":"ErrorList LocalError merge","title":"See Also"},{"location":"tools/failreply/","text":"failReply(ctx: Context, errors?: ErrorList, index?: number): Reply Creates a reply object representing an unsuccessful parse. This function creates a Result object with a status of Status.Fail out of the provided errors list ( [] by default), and it uses the supplied context (modifying its index if the index parameter is present) to create a new context for the reply. This function should always be used to create a failing reply, since it will always create both a new context and result, ensuring that older contexts aren't accidentally overwritten. Parameters ctx : The context for the newly created reply. errors : The error list detailing errors that hapopened at the context's location. Defaults to an empty array. index : The index into the context's input. This is used just to change that index if necessary (in backtracking, for example). Defaults to the context's current index. Returns Returns a reply object with the given context and result value. See Also Context ErrorList fatalReply okReply","title":"failReply"},{"location":"tools/failreply/#parameters","text":"ctx : The context for the newly created reply. errors : The error list detailing errors that hapopened at the context's location. Defaults to an empty array. index : The index into the context's input. This is used just to change that index if necessary (in backtracking, for example). Defaults to the context's current index.","title":"Parameters"},{"location":"tools/failreply/#returns","text":"Returns a reply object with the given context and result value.","title":"Returns"},{"location":"tools/failreply/#see-also","text":"Context ErrorList fatalReply okReply","title":"See Also"},{"location":"tools/failure/","text":"failure(reply: Reply<any>): string | null Returns the error message from a failed parse reply. If the reply is not, in fact, a failure, this function returns null . Parameters reply : A parse reply, presumably the return value of a call to parse . Returns Returns the error message that comes from the parse reply, if it was unsuccessful. If it succeeded, null is returned.. See Also Reply parse success","title":"failure"},{"location":"tools/failure/#parameters","text":"reply : A parse reply, presumably the return value of a call to parse .","title":"Parameters"},{"location":"tools/failure/#returns","text":"Returns the error message that comes from the parse reply, if it was unsuccessful. If it succeeded, null is returned..","title":"Returns"},{"location":"tools/failure/#see-also","text":"Reply parse success","title":"See Also"},{"location":"tools/fatalreply/","text":"fatalReply(ctx: Context, errors?: ErrorList, index?: number): Reply Creates a reply object representing a fatally unsuccessful parse. This function creates a Result object with a status of Status.Fatal out of the provided errors list ( [] by default), and it uses the supplied context (modifying its index if the index parameter is present) to create a new context for the reply. This function should always be used to create a fatally failing reply, since it will always create both a new context and result, ensuring that older contexts aren't accidentally overwritten. Parameters ctx : The context for the newly created reply. errors : The error list detailing errors that hapopened at the context's location. Defaults to an empty array. index : The index into the context's input. This is used just to change that index if necessary (in backtracking, for example). Defaults to the context's current index. Returns Returns a reply object with the given context and result value. See Also Context ErrorList failReply okReply","title":"fatalReply"},{"location":"tools/fatalreply/#parameters","text":"ctx : The context for the newly created reply. errors : The error list detailing errors that hapopened at the context's location. Defaults to an empty array. index : The index into the context's input. This is used just to change that index if necessary (in backtracking, for example). Defaults to the context's current index.","title":"Parameters"},{"location":"tools/fatalreply/#returns","text":"Returns a reply object with the given context and result value.","title":"Returns"},{"location":"tools/fatalreply/#see-also","text":"Context ErrorList failReply okReply","title":"See Also"},{"location":"tools/formaterrors/","text":"formatErrors(reply: Reply<any>, tabSize?: number, maxWidth?: number, formatter?: Formatter): string Formats a failed reply into a string. There is a default formatter, but a custom formatter can be supplied if necessary. The default formatter calculates the line and column based on the reply, includes all or part of the parsed line where the error happened, and displays a caret that points to the location of that error. Below that, unexpected, expected, generic, compound, and nested errors are displayed, in that order. Every error case in the examples found on the parser API pages illustrates how that error would be formatted by the default formatter. To use a custom formatter, a new function that conforms to the Formatter should be passed in as the formatter parameter. This function is responsible for both formatting and for the setting of default values for tabSize and maxWidth . Parameters reply : The failed reply returned from a parser, used to calculate the location of the error and the reason(s) why it happened. tabSize : The size of tab stops, used to determine how tab characters ( '\\t' ) are formatted. In the default formatter, this does not define the size of the tab; it and its multiples become the column numbers where tabs terminate. The default tab size in the default formatter is 8. maxWidth : The maximum width of a line that is displayed in the error message. This controls only whether the line is truncated in the error message. The default max width in the default formatter is 72. formatter : A formatting function that actually performs the formatting. The default formatter is a function not provided through the API, but the presence of this parameter allows an alternate formatting function to be used instead. Returns Returns a formatted error message. See Also Formatter Reply getPosition","title":"formatErrors"},{"location":"tools/formaterrors/#parameters","text":"reply : The failed reply returned from a parser, used to calculate the location of the error and the reason(s) why it happened. tabSize : The size of tab stops, used to determine how tab characters ( '\\t' ) are formatted. In the default formatter, this does not define the size of the tab; it and its multiples become the column numbers where tabs terminate. The default tab size in the default formatter is 8. maxWidth : The maximum width of a line that is displayed in the error message. This controls only whether the line is truncated in the error message. The default max width in the default formatter is 72. formatter : A formatting function that actually performs the formatting. The default formatter is a function not provided through the API, but the presence of this parameter allows an alternate formatting function to be used instead.","title":"Parameters"},{"location":"tools/formaterrors/#returns","text":"Returns a formatted error message.","title":"Returns"},{"location":"tools/formaterrors/#see-also","text":"Formatter Reply getPosition","title":"See Also"},{"location":"tools/generic/","text":"generic(msg: string): [LocalError] Creates a generic error. This error's type will be ErrorType.Generic . This is returned as a single-element ErrorList . For a larger list, use merge to join lists. Parameters msg : The error message. Returns Returns a single-element array with one error in it. See Also ErrorList LocalError merge","title":"generic"},{"location":"tools/generic/#parameters","text":"msg : The error message.","title":"Parameters"},{"location":"tools/generic/#returns","text":"Returns a single-element array with one error in it.","title":"Returns"},{"location":"tools/generic/#see-also","text":"ErrorList LocalError merge","title":"See Also"},{"location":"tools/getposition/","text":"getPosition(ctx: Context, tabSize?: number): { line: number, column: number } Calculates the position represented by a context. The context contains both the text and a pointer into that text, and this function determines which line and column number within the text is indicated by that pointer. This calculation takes tab stops into effect, which is the reason for the tabSize parameter (which defaults to 8). It also takes character sizes into account. A four-byte character takes up four bytes in the context, but it only takes one column. Zero-width characters (including the Unicode categories for non-spacing marks and for formatting characters) are accounted for as well. This function uses the same calculation used by the default formatter in formatErrors to calculate the line and column for its error message. Parameters ctx : The context supplying the text and position that is used to calculate the line and column numbers. tabSize : The size of the tab stops, used to calculate column numbers of characters that follow a tab within a line. Defaults to 8. Returns Returns an object of two properties, line and column , which are set to the 1-based line and column numbers of the position indicated by the context. See Also Context formatErrors","title":"getPosition"},{"location":"tools/getposition/#parameters","text":"ctx : The context supplying the text and position that is used to calculate the line and column numbers. tabSize : The size of the tab stops, used to calculate column numbers of characters that follow a tab within a line. Defaults to 8.","title":"Parameters"},{"location":"tools/getposition/#returns","text":"Returns an object of two properties, line and column , which are set to the 1-based line and column numbers of the position indicated by the context.","title":"Returns"},{"location":"tools/getposition/#see-also","text":"Context formatErrors","title":"See Also"},{"location":"tools/merge/","text":"merge(errors1: ErrorList, errors2: ErrorList): ErrorList Merges two error lists into a single error list. This currently simply concatenates the lists; it does not remove any member of either list. The error formatter itself is regarded as responsible for displaying only the errors in question, so merge retains them all. Parameters errors1 : The first error list to merge. errors2 : The second error list to merge. Returns Returns both lists concatenated into a new list. See Also ErrorList","title":"merge"},{"location":"tools/merge/#parameters","text":"errors1 : The first error list to merge. errors2 : The second error list to merge.","title":"Parameters"},{"location":"tools/merge/#returns","text":"Returns both lists concatenated into a new list.","title":"Returns"},{"location":"tools/merge/#see-also","text":"ErrorList","title":"See Also"},{"location":"tools/nested/","text":"nested(ctx: Context, errors: ErrorList): [NestedError] Creates a nested error using ctx to describe where the errors in the list errors happened. This is used to detail information about an actual error location after backtracking has moved the current context away from that location. The errors parameter will become the error list for the new nested error. However, if errors itself contains only a single nested error, it will be collapsed into the new nested error. There is no need to have a nested error that contains nothing except another nested error. Parameters ctx : The context where the nested error(s) happened. errors : The error(s) that happened in that location. Returns Returns a list containing a single nested error, whose own error list will contain the errors that happened at its context's location. See Also Context ErrorList NestedError compound","title":"nested"},{"location":"tools/nested/#parameters","text":"ctx : The context where the nested error(s) happened. errors : The error(s) that happened in that location.","title":"Parameters"},{"location":"tools/nested/#returns","text":"Returns a list containing a single nested error, whose own error list will contain the errors that happened at its context's location.","title":"Returns"},{"location":"tools/nested/#see-also","text":"Context ErrorList NestedError compound","title":"See Also"},{"location":"tools/okreply/","text":"okReply(ctx: Context, value?: *, index?: number): Reply Creates a reply object representing a successful parse. This function creates a Result object with a status of Status.Ok out of the provided value ( null by default), and it uses the supplied context (modifying its index if the index parameter is present) to create a new context for the reply. This function should always be used to create a successful reply, since it will always create both a new context and result, ensuring that older contexts aren't accidentally overwritten. Parameters ctx : The context for the newly created reply. value : The value that represents the result of the parse. Defaults to null . index : The index into the context's input. This is used just to change that index if necessary (in backtracking, for example). Defaults to the context's current index. Returns Returns a reply object with the given context and result value. See Also Context Reply failReply fatalReply","title":"okReply"},{"location":"tools/okreply/#parameters","text":"ctx : The context for the newly created reply. value : The value that represents the result of the parse. Defaults to null . index : The index into the context's input. This is used just to change that index if necessary (in backtracking, for example). Defaults to the context's current index.","title":"Parameters"},{"location":"tools/okreply/#returns","text":"Returns a reply object with the given context and result value.","title":"Returns"},{"location":"tools/okreply/#see-also","text":"Context Reply failReply fatalReply","title":"See Also"},{"location":"tools/other/","text":"other(msg: string): [LocalError] Creates some kind of error not explicity supported by Kessel. This error's type will be ErrorType.Other . This is returned as a single-element ErrorList . For a larger list, use merge to join lists. Error messages created by other are not displayed by the default formatter for error messages. They are only useful if a custom formatter is used. Parameters msg : The error message. Returns Returns a single-element array with one error in it. See Also ErrorList LocalError formatErrors merge","title":"other"},{"location":"tools/other/#parameters","text":"msg : The error message.","title":"Parameters"},{"location":"tools/other/#returns","text":"Returns a single-element array with one error in it.","title":"Returns"},{"location":"tools/other/#see-also","text":"ErrorList LocalError formatErrors merge","title":"See Also"},{"location":"tools/parse/","text":"parse(p: Parser<T>, input: Input): Reply<T> Executes a parser against input text. This is the primary parser execution function in Kessel. For the purpose of supporting UTF-8, the input is stored internally as a DataView . parse knows how to transform several types into views, and input can be any of these. string ArrayBuffer any of the typed arrays ( Uint8Array , Int16Array , etc.) DataView p , which can be any parser but likely is a combinator composed of many parsers, is executed against this text, and the reply that is returned provides all of the information about how well it worked. The utility functions status , succeeded , success , and failure can be used to extract that information from the reply. Parameters p : The parser to execute. input : The text to execute p against. Returns Returns a reply containing the context at the end of parsing and the parse result. Throws Throws an error if any parser within p throws an error. See Also Input Parser Reply failure run status succeeded success","title":"parse"},{"location":"tools/parse/#parameters","text":"p : The parser to execute. input : The text to execute p against.","title":"Parameters"},{"location":"tools/parse/#returns","text":"Returns a reply containing the context at the end of parsing and the parse result.","title":"Returns"},{"location":"tools/parse/#throws","text":"Throws an error if any parser within p throws an error.","title":"Throws"},{"location":"tools/parse/#see-also","text":"Input Parser Reply failure run status succeeded success","title":"See Also"},{"location":"tools/parser/","text":"parser<T>(p: (ctx: Context) => Reply<T>): Parser<T> Creates a parser. In essence, this factory function simply takes a parser function and returns that same function ( (ctx: Context) => Reply<T> and Parser<T> are equivalent). However, it flips some bits in the background to make sure everything works right with assertions. For that reason, only parsers used by this function can be used as parsers in Kessel; even functions with the same signature will fail if they came from elsewhere. Additionally, it's entirely possible that future changes will create other reasons why this function must be used to create a parser. Every parser in Kessel complies with this rule, so every parser that they return, directly or indirectly, also complies. In short: this is only something to be concerned about if you are authoring your own parsers. parser has a property attached to it called created . This property is a function that can be used on any object to see if it is, in fact, a parser that was created with this function. For example, passing the any to this function, parser.created(any) , will return true . !!! note \"Some parsers aren't parsers, but create parsers\" It has been noted elsewhere that not every \"parser\" in this API is actually a parser. For example, any may be a parser, but what about char ? ```javascript const isParser = parser.created(char) console.log(isParser) // false ``` However, these \"non-parsers\" are essentially just waiting for parameters to define their precise behavior (in the case of `char`, defining which character it matches), and after they have those parameters they return parsers. ```javascript const isParser = parser.created(char('a')) console.log(isParser) // true ``` We only bother to differentiate parsers and parser-creating functions when it would otherwise be ambiguous. Parameters p : A function used to create a parser. Returns Returns a parser conforming to the behavior of p . See Also Context Parser Reply","title":"parser"},{"location":"tools/parser/#parameters","text":"p : A function used to create a parser.","title":"Parameters"},{"location":"tools/parser/#returns","text":"Returns a parser conforming to the behavior of p .","title":"Returns"},{"location":"tools/parser/#see-also","text":"Context Parser Reply","title":"See Also"},{"location":"tools/run/","text":"run(p: Parser<T>, input: Input): T Executes a parser against input text. This is a convenience variation of parse . Like parse , it can accept strings, ArrayBuffer s, DataView s, and typed arrays as input. If p succeeds, its result is returned directly from run , rather than returning a Reply object or a Result (../types/result.md) from which it has to be extraced. If the parse fails, run will throw an error with the message generated by Kessel's error system. Parameters p : The parser to execute. input : The text to execute p against. Returns Returns the parsed result. Throws Throws an error if any parser within p throws an error. Throws an error if p fails, containing the full error message detailing that failure. See Also Input Parser parse","title":"run"},{"location":"tools/run/#parameters","text":"p : The parser to execute. input : The text to execute p against.","title":"Parameters"},{"location":"tools/run/#returns","text":"Returns the parsed result.","title":"Returns"},{"location":"tools/run/#throws","text":"Throws an error if any parser within p throws an error. Throws an error if p fails, containing the full error message detailing that failure.","title":"Throws"},{"location":"tools/run/#see-also","text":"Input Parser parse","title":"See Also"},{"location":"tools/status/","text":"status(reply: Reply<any>): Status Returns the status of a parser reply. The status indicates whether the parse succeeded ( Status.Ok ), failed ( Status.Fail ), or failed fatally ( Status.Fatal ). Parameters reply : A parse reply, presumably the return value of a call to parse . Returns Returns the status of that reply. See Also Reply Status parse succeeded","title":"status"},{"location":"tools/status/#parameters","text":"reply : A parse reply, presumably the return value of a call to parse .","title":"Parameters"},{"location":"tools/status/#returns","text":"Returns the status of that reply.","title":"Returns"},{"location":"tools/status/#see-also","text":"Reply Status parse succeeded","title":"See Also"},{"location":"tools/succeeded/","text":"succeeded(reply: Reply<any>): boolean Determines whether a parse reply indicates success. This utility function simply reads the status from the reply and returns true if it is Status.Ok and false otherwise. Parameters reply : A parse reply, presumably the return value of a call to parse . Returns Returns true if the reply was successful or false if it was not. See Also Reply parse status","title":"succeeded"},{"location":"tools/succeeded/#parameters","text":"reply : A parse reply, presumably the return value of a call to parse .","title":"Parameters"},{"location":"tools/succeeded/#returns","text":"Returns true if the reply was successful or false if it was not.","title":"Returns"},{"location":"tools/succeeded/#see-also","text":"Reply parse status","title":"See Also"},{"location":"tools/success/","text":"success(reply: Reply<T>): T | null Returns the parse result from a successful parse reply. If the reply is not, in fact, successful, this function returns null . Parameters reply : A parse reply, presumably the return value of a call to parse . Returns Returns the result that comes from the parse reply, if it was successful. If it failed, null is returned.. See Also Reply failure parse","title":"success"},{"location":"tools/success/#parameters","text":"reply : A parse reply, presumably the return value of a call to parse .","title":"Parameters"},{"location":"tools/success/#returns","text":"Returns the result that comes from the parse reply, if it was successful. If it failed, null is returned..","title":"Returns"},{"location":"tools/success/#see-also","text":"Reply failure parse","title":"See Also"},{"location":"tools/unexpected/","text":"unexpected(msg: string): [LocalError] Creates an error describing what outcome happened that was not expected. This error's type will be ErrorType.Unexpected . This is returned as a single-element ErrorList . For a larger list, use merge to join lists. Parameters msg : The error message describing what happened that was not expected Returns Returns a single-element array with one error in it. See Also ErrorList LocalError merge","title":"unexpected"},{"location":"tools/unexpected/#parameters","text":"msg : The error message describing what happened that was not expected","title":"Parameters"},{"location":"tools/unexpected/#returns","text":"Returns a single-element array with one error in it.","title":"Returns"},{"location":"tools/unexpected/#see-also","text":"ErrorList LocalError merge","title":"See Also"},{"location":"tutorial/ch-00/","text":"There's not a better way to learn how to use a package \u2014 or even just to learn what a package is really good for \u2014 than to actually use that package. To that end, this is a tutorial in which we use Kessel to create a parser that actually does something useful. So what should we parse? For the purpose of this tutorial, I was looking for a couple things. First, it had to be the right amount of complexity. There's an example of a CSV parser earlier in the documentation that's five lines long, which wouldn't make for much of a tutorial at all. On the other hand, one could write an entire book on parsing and compiling C (and in fact many such books have been written), and that's a bit much for a tutorial. The second requirement was that there be a clearly defined spec. I want the focus to be on how to write parsers, not on trying to decipher the language before being able to even figure out what parsers to write. With that in mind, I chose to base the tutorial on writing a TOML parser. TOML is a language for writing configuration files, much like JSON or YAML or even XML could be. It has more features than JSON, has a nicer and more consistent syntax than YAML, and...well, anything's better than XML. The fact that it's my favorite configuration language probably played a part in me picking it as well. The application developed in this tutorial will take a TOML file and spit out an equivalent JavaScript object. We'll have to get deep into the details when the writing actually starts, but to start, let's just get a quick look at TOML syntax. A 10,000 foot view of TOML We'll equate TOML structures to JavaScript structures, since after all we'll be turning the former into the latter. The first structure that we'll mention, briefly, is the file itself. Our parser is always going to output a single","title":"Introduction"},{"location":"tutorial/ch-00/#a-10000-foot-view-of-toml","text":"We'll equate TOML structures to JavaScript structures, since after all we'll be turning the former into the latter. The first structure that we'll mention, briefly, is the file itself. Our parser is always going to output a single","title":"A 10,000 foot view of TOML"},{"location":"types/compounderror/","text":"type CompoundError = { type: 'compound'; msg: string; ctx: Context; errors: ErrorList } An error that happens at a different location than that provided by the associated context. A compound error results from backtracking. The context changes when backtracking happens, which would lead to loss if information about the error that caused the backtracking if that information wasn't saved. That's the purpose of the nested error; it saves its own copy of the context where the error actually happened so that information can be put into an error message even after backtracking. A compound error has its own error list, which is where the error(s) which caused the backtracking will be. It also has a message which is used as a header to explain the backtracking. The compound error will then be in the error list returned by the result of the failed parse. Compound errors always have the type ErrorType.Compound . The attempt parser produces a compound error when it backtracks if an error message is provided to it. Properties type : The type of the error. This is always ErrorType.Compound for compound errors. msg : A message describing the circumstances of the backtracking. ctx : The context describing where the nested error occurred. errors : A list of the errors that caused the nested error to be created. See Also Context ErrorList ErrorType LocalError NestedError attempt compound","title":"CompoundError"},{"location":"types/compounderror/#properties","text":"type : The type of the error. This is always ErrorType.Compound for compound errors. msg : A message describing the circumstances of the backtracking. ctx : The context describing where the nested error occurred. errors : A list of the errors that caused the nested error to be created.","title":"Properties"},{"location":"types/compounderror/#see-also","text":"Context ErrorList ErrorType LocalError NestedError attempt compound","title":"See Also"},{"location":"types/context/","text":"type Context = { view: DataView; index: number; } A Context is used to keep record of the input being parsed and the current parsing position within that input. The view is the actual input, transformed into an array of bytes wrapped in a DataView . Kessel deals in UTF-8 characters, which may be anywhere between one and four bytes per character, and using an array of bytes to represent the input lets Kessel deal with the variable-length characters in the most flexible manner. The index is a byte-based index (as opposed to the output of error messages, which is character-based). Kessel ensures that, as long as the byte array is properly formed (i.e., that someone didn't pass in bytes that don't actually represent real characters), it will always have index pointing at the first byte of the next character. Contexts should be created using the functions okReply , failReply , and fatalReply because they ensure that no older contexts are overwritten (which can become important in nested and compound errors, which keep multiple contexts). Properties view : A DataView representing the input text. This view is created by the parsing functions parse and run from any of the legal types of input. index : A pointer that marks the current location in the view. The next byte read by a parser will be the byte at that location. See Also Reply failReply fatalReply Reply parse run","title":"Context"},{"location":"types/context/#properties","text":"view : A DataView representing the input text. This view is created by the parsing functions parse and run from any of the legal types of input. index : A pointer that marks the current location in the view. The next byte read by a parser will be the byte at that location.","title":"Properties"},{"location":"types/context/#see-also","text":"Reply failReply fatalReply Reply parse run","title":"See Also"},{"location":"types/errorlist/","text":"type ErrorList = (NestedError | CompoundError | LocalError)[] An ErrorList is simply an array of errors of mixed types. Unsuccessful results will have lists of errors because it is possible for more than one error to occur at the same location or from the same source. See Also CompoundError LocalError NestedError Result failReply fatalReply","title":"ErrorList"},{"location":"types/errorlist/#see-also","text":"CompoundError LocalError NestedError Result failReply fatalReply","title":"See Also"},{"location":"types/errortype/","text":"type ErrorType = symbol A symbol indicating the type of an error. The possible values are listed in the ErrorType namespace. namespace ErrorType { const Expected: symbol; const Unexpected: symbol; const Generic: symbol; const Nested: symbol; const Compound: symbol; const Other: symbol; } NestedError s must be of type ErrorType.Nested , while CompoundError s must be of type ErrorType.Compound . All other error types are used for LocalError s . See Also CompoundError LocalError NestedError","title":"ErrorType"},{"location":"types/errortype/#see-also","text":"CompoundError LocalError NestedError","title":"See Also"},{"location":"types/formatter/","text":"type Formatter = (errors: ErrorList, index: number, view: DataView, tabSize?: number, maxWidth?: number) => string This is the type for a custom formatting function that is passed to formatErrors . There is already a default formatter of this type used by formatErrors by default, but if a custom formatter is desired, this is the type it should be. Parameters errors : The error list being formatted by the formatter. index : The index into the input where the error(s) happened. view : The input text, as a data view. tabSize : The size of the tabs. This is typically used as tab stops, but there's no reason a custom formatter couldn't do otherwise. The formatter must set the default value. maxSize : The maximum width of the line to display. The formatter must decide exactly what this means and provide a default value. Returns Returns a formatted string describing the errors in whatever way is desired. See Also ErrorList formatErrors","title":"Formatter"},{"location":"types/formatter/#parameters","text":"errors : The error list being formatted by the formatter. index : The index into the input where the error(s) happened. view : The input text, as a data view. tabSize : The size of the tabs. This is typically used as tab stops, but there's no reason a custom formatter couldn't do otherwise. The formatter must set the default value. maxSize : The maximum width of the line to display. The formatter must decide exactly what this means and provide a default value.","title":"Parameters"},{"location":"types/formatter/#returns","text":"Returns a formatted string describing the errors in whatever way is desired.","title":"Returns"},{"location":"types/formatter/#see-also","text":"ErrorList formatErrors","title":"See Also"},{"location":"types/input/","text":"type Input = string | ArrayBuffer | DataView | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array A union of all of the types that can be provided as input to a parser. These are each converted by parse or run into a DataView , which is then inserted into a Context . See Also Context parse run","title":"Input"},{"location":"types/input/#see-also","text":"Context parse run","title":"See Also"},{"location":"types/localerror/","text":"type LocalError = { type: 'expected' | 'unexpected' | 'generic' | 'other'; msg: string; } An error that happens at a location indicated by an associated context. A parser returns a Reply ; this reply contains both a Result and a Context . The result has a list of errors if it is a failed parse, and the context indicates the position where those errors happened. Thus the errors themselves do not have to carry context information because the context is there to do it. Local errors can be of any kind other than ErrorType.Nested and ErrorType.Compound , each of which hold additional information and therefore are of types different from local errors. Properties type : The type of the local error. msg : The message describing the local error. See Also CompoundError ErrorType NestedError expected generic other unexpected","title":"LocalError"},{"location":"types/localerror/#properties","text":"type : The type of the local error. msg : The message describing the local error.","title":"Properties"},{"location":"types/localerror/#see-also","text":"CompoundError ErrorType NestedError expected generic other unexpected","title":"See Also"},{"location":"types/nestederror/","text":"type NestedError = { type: 'nested'; ctx: Context; errors: ErrorList } An error that happens at a different location than that provided by the associated context. A nested error typically results from backtracking. The context changes when backtracking happens, which would lead to loss if information about the error that caused the backtracking if that information wasn't saved. That's the purpose of the nested error; it saves its own copy of the context where the error actually happened so that information can be put into an error message even after backtracking. A nested error has its own error list, which is where the error(s) which caused the backtracking will be. The nested error will then be in the error list returned by the result of the failed parse. Nested errors always have the type ErrorType.Nested . The attempt parser produces nested errors when it backtracks, as do all backtracking parsers (those whose names end with B ). Properties type : The type of the error. This is always ErrorType.Nested for nested errors. ctx : The context describing where the nested error occurred. errors : A list of the errors that caused the nested error to be created. See Also CompoundError Context ErrorList ErrorType LocalError attempt nested","title":"NestedError"},{"location":"types/nestederror/#properties","text":"type : The type of the error. This is always ErrorType.Nested for nested errors. ctx : The context describing where the nested error occurred. errors : A list of the errors that caused the nested error to be created.","title":"Properties"},{"location":"types/nestederror/#see-also","text":"CompoundError Context ErrorList ErrorType LocalError attempt nested","title":"See Also"},{"location":"types/parser/","text":"type Parser<T> = (ctx: Context) => Reply<T> The type for a parsing function. This is, unsurprisingly, the most important type in Kessel. The parameter T refers to the type of the parser's result. any is of type Parser<string> , for example, because that parser produces a single character (which is, of course, a string). Since Reply is a tuple of a Context and a Result , a Parser is just a function that accepts a context and returns an updated context and a result. Parameters ctx : The context passed to the parser detailing the input and the current location in that input. Returns Returns a tuple of an updated, post-parse context and the result that the parse produced. See Also Context Reply Result","title":"Parser"},{"location":"types/parser/#parameters","text":"ctx : The context passed to the parser detailing the input and the current location in that input.","title":"Parameters"},{"location":"types/parser/#returns","text":"Returns a tuple of an updated, post-parse context and the result that the parse produced.","title":"Returns"},{"location":"types/parser/#see-also","text":"Context Reply Result","title":"See Also"},{"location":"types/reply/","text":"type Reply<T> = [Context, Result<T>] The type representing a reply from a parser. Each parser returns a value of this type, and parse does as well. Reply objects should be produced by okReply , failReply , and fatalReply rather than being produced by hand. This ensures that the context is copied so that there aren't accidental overwrites of the indexes of older contexts. A reply contains all of the information necessary to get a result and, if that result is a failure, to know what the failure was and where it happened. See Also Context Result failure status succeeded success","title":"Reply"},{"location":"types/reply/#see-also","text":"Context Result failure status succeeded success","title":"See Also"},{"location":"types/result/","text":"type Result<T> = { status: 'ok'; value: T; errors?: ErrorList } | { status: 'fail' | 'fatal'; value?: T; errors: ErrorList; } The result produced by a parser. This can either be a success or a failure, depending on the values of the properties. If the result is a success, then status should be Status.Ok and value will have the parsed value and errors will be optional. If the result is a failure, then status should be either Status.Fail or Status.Fatal and value is optional. This kind of emulates a Either type from Haskell by using status to determine which of value and errors is valid. The other is still legal, but is only used in certain circumstances; for example, errors is used in the 'ok' case only when the parser succeeds despite an underlying parser failing (such as in opt ). Properties status : The status of the parse result. This indicates whether the parse succeeded, failed, or failed fatally. value : The value returned by the parser on a successful parse. errors : The error list returned by the parser on an unsuccessful parse. See Also Reply Status","title":"Result"},{"location":"types/result/#properties","text":"status : The status of the parse result. This indicates whether the parse succeeded, failed, or failed fatally. value : The value returned by the parser on a successful parse. errors : The error list returned by the parser on an unsuccessful parse.","title":"Properties"},{"location":"types/result/#see-also","text":"Reply Status","title":"See Also"},{"location":"types/status/","text":"enum Status: 'ok' | 'fail' | 'fatal' A string indicating the status of a result. The possible values are listed in the Status namespace. namespace Status { const Ok: 'ok'; const Fail: 'fail'; const Fatal: 'fatal'; } This isn't typed as an enum because it's better for use with discriminated unions. Status.Ok indicates a successful result, while Status.Fail is for non-fatal failures and Status.Fatal for fatal failures. See Also Result status","title":"Status"},{"location":"types/status/#see-also","text":"Result status","title":"See Also"}]}